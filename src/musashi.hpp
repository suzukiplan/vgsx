// Auto-generated single-header Musashi aggregate. Do not edit manually.
// Generated by Codex automation to provide header-only API.

#pragma once

/*
 * This header aggregates Musashi sources (m68k.h, m68kcpu.c, m68kops.c,
 * m68kdasm.c, softfloat.c) and their dependencies into a single file
 * suitable for inclusion from C++ code. Define MUSASHI_IMPLEMENTATION in
 * exactly one translation unit before including this header to emit the
 * implementation.
 */

/* ----------------------------- Public API ----------------------------- */
/* ======================================================================== */
/* ========================= LICENSING & COPYRIGHT ======================== */
/* ======================================================================== */
/*
 *                                  MUSASHI
 *                                Version 3.32
 *
 * A portable Motorola M680x0 processor emulation engine.
 * Copyright Karl Stenerud.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#ifndef M68K__HEADER
#define M68K__HEADER

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(M68K_LIKELY)
#if defined(__GNUC__) || defined(__clang__)
#define M68K_HOT __attribute__((hot))
#define M68K_COLD __attribute__((cold))
#define M68K_FORCE_INLINE static inline __attribute__((always_inline))
#define M68K_LIKELY(x) __builtin_expect(!!(x), 1)
#define M68K_UNLIKELY(x) __builtin_expect(!!(x), 0)
#define M68K_RESTRICT __restrict__
#else
#define M68K_HOT
#define M68K_COLD
#define M68K_FORCE_INLINE static inline
#define M68K_LIKELY(x) (x)
#define M68K_UNLIKELY(x) (x)
#define M68K_RESTRICT
#endif
#endif

#ifndef ARRAY_LENGTH
#define ARRAY_LENGTH(x) (sizeof(x) / sizeof(x[0]))
#endif

#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif

/* ======================================================================== */
/* ============================= CONFIGURATION ============================ */
/* ======================================================================== */

/* Import the configuration for this build */
#ifdef MUSASHI_CNF
#include MUSASHI_CNF
#else
/* -- Begin embedded musashi/m68kconf.h -- */
/* ======================================================================== */
/* ========================= LICENSING & COPYRIGHT ======================== */
/* ======================================================================== */
/*
 *                                  MUSASHI
 *                                Version 3.32
 *
 * A portable Motorola M680x0 processor emulation engine.
 * Copyright Karl Stenerud.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#ifndef M68KCONF__HEADER
#define M68KCONF__HEADER

/* Configuration switches.
 * Use OPT_SPECIFY_HANDLER for configuration options that allow callbacks.
 * OPT_SPECIFY_HANDLER causes the core to link directly to the function
 * or macro you specify, rather than using callback functions whose pointer
 * must be passed in using m68k_set_xxx_callback().
 */
#define OPT_OFF 0
#define OPT_ON 1
#define OPT_SPECIFY_HANDLER 2

/* ======================================================================== */
/* ============================== MAME STUFF ============================== */
/* ======================================================================== */

/* If you're compiling this for MAME, only change M68K_COMPILE_FOR_MAME
 * to OPT_ON and use m68kmame.h to configure the 68k core.
 */
#ifndef M68K_COMPILE_FOR_MAME
#define M68K_COMPILE_FOR_MAME OPT_OFF
#endif /* M68K_COMPILE_FOR_MAME */

#if M68K_COMPILE_FOR_MAME == OPT_OFF

/* ======================================================================== */
/* ============================= CONFIGURATION ============================ */
/* ======================================================================== */

/* Turn ON if you want to use the following M68K variants */
#define M68K_EMULATE_010 OPT_ON
#define M68K_EMULATE_EC020 OPT_ON
#define M68K_EMULATE_020 OPT_ON
#define M68K_EMULATE_030 OPT_ON
#define M68K_EMULATE_040 OPT_ON

/* If ON, the CPU will call m68k_read_immediate_xx() for immediate addressing
 * and m68k_read_pcrelative_xx() for PC-relative addressing.
 * If off, all read requests from the CPU will be redirected to m68k_read_xx()
 */
#define M68K_SEPARATE_READS OPT_OFF

/* If ON, the CPU will call m68k_write_32_pd() when it executes move.l with a
 * predecrement destination EA mode instead of m68k_write_32().
 * To simulate real 68k behavior, m68k_write_32_pd() must first write the high
 * word to [address+2], and then write the low word to [address].
 */
#define M68K_SIMULATE_PD_WRITES OPT_OFF

/* If ON, CPU will call the interrupt acknowledge callback when it services an
 * interrupt.
 * If off, all interrupts will be autovectored and all interrupt requests will
 * auto-clear when the interrupt is serviced.
 */
#define M68K_EMULATE_INT_ACK OPT_OFF
#define M68K_INT_ACK_CALLBACK(A) your_int_ack_handler_function(A)

/* If ON, CPU will call the breakpoint acknowledge callback when it encounters
 * a breakpoint instruction and it is running a 68010+.
 */
#define M68K_EMULATE_BKPT_ACK OPT_OFF
#define M68K_BKPT_ACK_CALLBACK() your_bkpt_ack_handler_function()

/* If ON, the CPU will monitor the trace flags and take trace exceptions
 */
#define M68K_EMULATE_TRACE OPT_OFF

/* If ON, CPU will call the output reset callback when it encounters a reset
 * instruction.
 */
#define M68K_EMULATE_RESET OPT_OFF
#define M68K_RESET_CALLBACK() your_reset_handler_function()

/* If ON, CPU will call the callback when it encounters a cmpi.l #v, dn
 * instruction.
 */
#define M68K_CMPILD_HAS_CALLBACK OPT_OFF
#define M68K_CMPILD_CALLBACK(v, r) your_cmpild_handler_function(v, r)

/* If ON, CPU will call the callback when it encounters a rte
 * instruction.
 */
#define M68K_RTE_HAS_CALLBACK OPT_OFF
#define M68K_RTE_CALLBACK() your_rte_handler_function()

/* If ON, CPU will call the callback when it encounters a tas
 * instruction.
 */
#define M68K_TAS_HAS_CALLBACK OPT_OFF
#define M68K_TAS_CALLBACK() your_tas_handler_function()

/* If ON, CPU will call the callback when it encounters an illegal instruction
 * passing the opcode as argument. If the callback returns 1, then it's considered
 * as a normal instruction, and the illegal exception in canceled. If it returns 0,
 * the exception occurs normally.
 * The callback looks like int callback(int opcode)
 * You should put OPT_SPECIFY_HANDLER here if you cant to use it, otherwise it will
 * use a dummy default handler and you'll have to call m68k_set_illg_instr_callback explicitely
 */
#define M68K_ILLG_HAS_CALLBACK OPT_OFF
#define M68K_ILLG_CALLBACK(opcode) op_illg(opcode)

/* If ON, CPU will call the set fc callback on every memory access to
 * differentiate between user/supervisor, program/data access like a real
 * 68000 would.  This should be enabled and the callback should be set if you
 * want to properly emulate the m68010 or higher. (moves uses function codes
 * to read/write data from different address spaces)
 */
#define M68K_EMULATE_FC OPT_OFF
#define M68K_SET_FC_CALLBACK(A) your_set_fc_handler_function(A)

/* If ON, CPU will call the pc changed callback when it changes the PC by a
 * large value.  This allows host programs to be nicer when it comes to
 * fetching immediate data and instructions on a banked memory system.
 */
#define M68K_MONITOR_PC OPT_OFF
#define M68K_SET_PC_CALLBACK(A) your_pc_changed_handler_function(A)

/* If ON, CPU will call the instruction hook callback before every
 * instruction.
 */
#define M68K_INSTRUCTION_HOOK OPT_OFF
#define M68K_INSTRUCTION_CALLBACK(pc) your_instruction_hook_function(pc)

/* If ON, the CPU will emulate the 4-byte prefetch queue of a real 68000 */
#define M68K_EMULATE_PREFETCH OPT_OFF

/* If ON, the CPU will generate address error exceptions if it tries to
 * access a word or longword at an odd address.
 * NOTE: This is only emulated properly for 68000 mode.
 */
#define M68K_EMULATE_ADDRESS_ERROR OPT_OFF

/* Turn ON to enable logging of illegal instruction calls.
 * M68K_LOG_FILEHANDLE must be #defined to a stdio file stream.
 * Turn on M68K_LOG_1010_1111 to log all 1010 and 1111 calls.
 */
#define M68K_LOG_ENABLE OPT_OFF
#define M68K_LOG_1010_1111 OPT_OFF
#define M68K_LOG_FILEHANDLE some_file_handle

/* Emulate PMMU : if you enable this, there will be a test to see if the current chip has some enabled pmmu added to every memory access,
 * so enable this only if it's useful */
#define M68K_EMULATE_PMMU OPT_ON

/* ----------------------------- COMPATIBILITY ---------------------------- */

/* The following options set optimizations that violate the current ANSI
 * standard, but will be compliant under the forthcoming C9X standard.
 */

/* If ON, the enulation core will use 64-bit integers to speed up some
 * operations.
 */
#define M68K_USE_64_BIT OPT_ON

#endif /* M68K_COMPILE_FOR_MAME */

/* ======================================================================== */
/* ============================== END OF FILE ============================= */
/* ======================================================================== */

#endif /* M68KCONF__HEADER */
/* -- End embedded musashi/m68kconf.h -- */
#endif

/* ======================================================================== */
/* ============================ GENERAL DEFINES =========================== */

/* ======================================================================== */

/* There are 7 levels of interrupt to the 68K.
 * A transition from < 7 to 7 will cause a non-maskable interrupt (NMI).
 */
#define M68K_IRQ_NONE 0
#define M68K_IRQ_1 1
#define M68K_IRQ_2 2
#define M68K_IRQ_3 3
#define M68K_IRQ_4 4
#define M68K_IRQ_5 5
#define M68K_IRQ_6 6
#define M68K_IRQ_7 7

/* Special interrupt acknowledge values.
 * Use these as special returns from the interrupt acknowledge callback
 * (specified later in this header).
 */

/* Causes an interrupt autovector (0x18 + interrupt level) to be taken.
 * This happens in a real 68K if VPA or AVEC is asserted during an interrupt
 * acknowledge cycle instead of DTACK.
 */
#define M68K_INT_ACK_AUTOVECTOR 0xffffffff

/* Causes the spurious interrupt vector (0x18) to be taken
 * This happens in a real 68K if BERR is asserted during the interrupt
 * acknowledge cycle (i.e. no devices responded to the acknowledge).
 */
#define M68K_INT_ACK_SPURIOUS 0xfffffffe

/* CPU types for use in m68k_set_cpu_type() */
enum {
    M68K_CPU_TYPE_INVALID,
    M68K_CPU_TYPE_68000,
    M68K_CPU_TYPE_68010,
    M68K_CPU_TYPE_68EC020,
    M68K_CPU_TYPE_68020,
    M68K_CPU_TYPE_68EC030,
    M68K_CPU_TYPE_68030,
    M68K_CPU_TYPE_68EC040,
    M68K_CPU_TYPE_68LC040,
    M68K_CPU_TYPE_68040,
    M68K_CPU_TYPE_SCC68070
};

/* Registers used by m68k_get_reg() and m68k_set_reg() */
typedef enum {
    /* Real registers */
    M68K_REG_D0, /* Data registers */
    M68K_REG_D1,
    M68K_REG_D2,
    M68K_REG_D3,
    M68K_REG_D4,
    M68K_REG_D5,
    M68K_REG_D6,
    M68K_REG_D7,
    M68K_REG_A0, /* Address registers */
    M68K_REG_A1,
    M68K_REG_A2,
    M68K_REG_A3,
    M68K_REG_A4,
    M68K_REG_A5,
    M68K_REG_A6,
    M68K_REG_A7,
    M68K_REG_PC,   /* Program Counter */
    M68K_REG_SR,   /* Status Register */
    M68K_REG_SP,   /* The current Stack Pointer (located in A7) */
    M68K_REG_USP,  /* User Stack Pointer */
    M68K_REG_ISP,  /* Interrupt Stack Pointer */
    M68K_REG_MSP,  /* Master Stack Pointer */
    M68K_REG_SFC,  /* Source Function Code */
    M68K_REG_DFC,  /* Destination Function Code */
    M68K_REG_VBR,  /* Vector Base Register */
    M68K_REG_CACR, /* Cache Control Register */
    M68K_REG_CAAR, /* Cache Address Register */

    /* Assumed registers */
    /* These are cheat registers which emulate the 1-longword prefetch
     * present in the 68000 and 68010.
     */
    M68K_REG_PREF_ADDR, /* Last prefetch address */
    M68K_REG_PREF_DATA, /* Last prefetch data */

    /* Convenience registers */
    M68K_REG_PPC,     /* Previous value in the program counter */
    M68K_REG_IR,      /* Instruction register */
    M68K_REG_CPU_TYPE /* Type of CPU being run */
} m68k_register_t;

/* ======================================================================== */
/* ====================== FUNCTIONS CALLED BY THE CPU ===================== */
/* ======================================================================== */

/* You will have to implement these functions */

/* read/write functions called by the CPU to access memory.
 * while values used are 32 bits, only the appropriate number
 * of bits are relevant (i.e. in write_memory_8, only the lower 8 bits
 * of value should be written to memory).
 *
 * NOTE: I have separated the immediate and PC-relative memory fetches
 *       from the other memory fetches because some systems require
 *       differentiation between PROGRAM and DATA fetches (usually
 *       for security setups such as encryption).
 *       This separation can either be achieved by setting
 *       M68K_SEPARATE_READS in m68kconf.h and defining
 *       the read functions, or by setting M68K_EMULATE_FC and
 *       making a function code callback function.
 *       Using the callback offers better emulation coverage
 *       because you can also monitor whether the CPU is in SYSTEM or
 *       USER mode, but it is also slower.
 */

/* Read from anywhere */
unsigned int m68k_read_memory_8(unsigned int address);
unsigned int m68k_read_memory_16(unsigned int address);
unsigned int m68k_read_memory_32(unsigned int address);

/* Read data immediately following the PC */
unsigned int m68k_read_immediate_16(unsigned int address);
unsigned int m68k_read_immediate_32(unsigned int address);

/* Read data relative to the PC */
unsigned int m68k_read_pcrelative_8(unsigned int address);
unsigned int m68k_read_pcrelative_16(unsigned int address);
unsigned int m68k_read_pcrelative_32(unsigned int address);

/* Memory access for the disassembler */
unsigned int m68k_read_disassembler_8(unsigned int address);
unsigned int m68k_read_disassembler_16(unsigned int address);
unsigned int m68k_read_disassembler_32(unsigned int address);

/* Write to anywhere */
void m68k_write_memory_8(unsigned int address, unsigned int value);
void m68k_write_memory_16(unsigned int address, unsigned int value);
void m68k_write_memory_32(unsigned int address, unsigned int value);

/* Special call to simulate undocumented 68k behavior when move.l with a
 * predecrement destination mode is executed.
 * To simulate real 68k behavior, first write the high word to
 * [address+2], and then write the low word to [address].
 *
 * Enable this functionality with M68K_SIMULATE_PD_WRITES in m68kconf.h.
 */
void m68k_write_memory_32_pd(unsigned int address, unsigned int value);

/* ======================================================================== */
/* ============================== CALLBACKS =============================== */
/* ======================================================================== */

/* These functions allow you to set callbacks to the host when specific events
 * occur.  Note that you must enable the corresponding value in m68kconf.h
 * in order for these to do anything useful.
 * Note: I have defined default callbacks which are used if you have enabled
 * the corresponding #define in m68kconf.h but either haven't assigned a
 * callback or have assigned a callback of NULL.
 */

/* Set the callback for an interrupt acknowledge.
 * You must enable M68K_EMULATE_INT_ACK in m68kconf.h.
 * The CPU will call the callback with the interrupt level being acknowledged.
 * The host program must return either a vector from 0x02-0xff, or one of the
 * special interrupt acknowledge values specified earlier in this header.
 * If this is not implemented, the CPU will always assume an autovectored
 * interrupt, and will automatically clear the interrupt request when it
 * services the interrupt.
 * Default behavior: return M68K_INT_ACK_AUTOVECTOR.
 */
void m68k_set_int_ack_callback(int (*callback)(int int_level));

/* Set the callback for a breakpoint acknowledge (68010+).
 * You must enable M68K_EMULATE_BKPT_ACK in m68kconf.h.
 * The CPU will call the callback with whatever was in the data field of the
 * BKPT instruction for 68020+, or 0 for 68010.
 * Default behavior: do nothing.
 */
void m68k_set_bkpt_ack_callback(void (*callback)(unsigned int data));

/* Set the callback for the RESET instruction.
 * You must enable M68K_EMULATE_RESET in m68kconf.h.
 * The CPU calls this callback every time it encounters a RESET instruction.
 * Default behavior: do nothing.
 */
void m68k_set_reset_instr_callback(void (*callback)(void));

/* Set the callback for informing of a large PC change.
 * You must enable M68K_MONITOR_PC in m68kconf.h.
 * The CPU calls this callback with the new PC value every time the PC changes
 * by a large value (currently set for changes by longwords).
 * Default behavior: do nothing.
 */
void m68k_set_pc_changed_callback(void (*callback)(unsigned int new_pc));

/* Set the callback for the TAS instruction.
 * You must enable M68K_TAS_HAS_CALLBACK in m68kconf.h.
 * The CPU calls this callback every time it encounters a TAS instruction.
 * Default behavior: return 1, allow writeback.
 */
void m68k_set_tas_instr_callback(int (*callback)(void));

/* Set the callback for illegal instructions.
 * You must enable M68K_ILLG_HAS_CALLBACK in m68kconf.h.
 * The CPU calls this callback every time it encounters an illegal instruction
 * which must return 1 if it handles the instruction normally or 0 if it's really an illegal instruction.
 * Default behavior: return 0, exception will occur.
 */
void m68k_set_illg_instr_callback(int (*callback)(int));

/* Set the callback for CPU function code changes.
 * You must enable M68K_EMULATE_FC in m68kconf.h.
 * The CPU calls this callback with the function code before every memory
 * access to set the CPU's function code according to what kind of memory
 * access it is (supervisor/user, program/data and such).
 * Default behavior: do nothing.
 */
void m68k_set_fc_callback(void (*callback)(unsigned int new_fc));

/* Set a callback for the instruction cycle of the CPU.
 * You must enable M68K_INSTRUCTION_HOOK in m68kconf.h.
 * The CPU calls this callback just before fetching the opcode in the
 * instruction cycle.
 * Default behavior: do nothing.
 */
void m68k_set_instr_hook_callback(void (*callback)(unsigned int pc));

/* ======================================================================== */
/* ====================== FUNCTIONS TO ACCESS THE CPU ===================== */
/* ======================================================================== */

/* Use this function to set the CPU type you want to emulate.
 * Currently supported types are: M68K_CPU_TYPE_68000, M68K_CPU_TYPE_68010,
 * M68K_CPU_TYPE_EC020, and M68K_CPU_TYPE_68020.
 */
void m68k_set_cpu_type(unsigned int cpu_type);

/* Do whatever initialisations the core requires.  Should be called
 * at least once at init time.
 */
void m68k_init(void);

/* Pulse the RESET pin on the CPU.
 * You *MUST* reset the CPU at least once to initialize the emulation
 * Note: If you didn't call m68k_set_cpu_type() before resetting
 *       the CPU for the first time, the CPU will be set to
 *       M68K_CPU_TYPE_68000.
 */
void m68k_pulse_reset(void);

/* execute num_cycles worth of instructions.  returns number of cycles used */
M68K_HOT int m68k_execute(int num_cycles);

/* These functions let you read/write/modify the number of cycles left to run
 * while m68k_execute() is running.
 * These are useful if the 68k accesses a memory-mapped port on another device
 * that requires immediate processing by another CPU.
 */
M68K_HOT int m68k_cycles_run(void);              /* Number of cycles run so far */
M68K_HOT int m68k_cycles_remaining(void);        /* Number of cycles left */
M68K_HOT void m68k_modify_timeslice(int cycles); /* Modify cycles left */
M68K_HOT void m68k_end_timeslice(void);          /* End timeslice now */

/* Set the IPL0-IPL2 pins on the CPU (IRQ).
 * A transition from < 7 to 7 will cause a non-maskable interrupt (NMI).
 * Setting IRQ to 0 will clear an interrupt request.
 */
void m68k_set_irq(unsigned int int_level);

/* Set the virtual irq lines, where the highest level
 * active line is automatically selected.  If you use this function,
 * do not use m68k_set_irq.
 */
void m68k_set_virq(unsigned int level, unsigned int active);
unsigned int m68k_get_virq(unsigned int level);

/* Halt the CPU as if you pulsed the HALT pin. */
void m68k_pulse_halt(void);

/* Trigger a bus error exception */
void m68k_pulse_bus_error(void);

/* Context switching to allow multiple CPUs */

/* Get the size of the cpu context in bytes */
unsigned int m68k_context_size(void);

/* Get a cpu context */
unsigned int m68k_get_context(void* dst);

/* set the current cpu context */
void m68k_set_context(void* dst);

/* Register the CPU state information */
void m68k_state_register(const char* type, int index);

/* Peek at the internals of a CPU context.  This can either be a context
 * retrieved using m68k_get_context() or the currently running context.
 * If context is NULL, the currently running CPU context will be used.
 */
unsigned int m68k_get_reg(void* context, m68k_register_t reg);

/* Poke values into the internals of the currently running CPU context */
void m68k_set_reg(m68k_register_t reg, unsigned int value);

/* Check if an instruction is valid for the specified CPU type */
unsigned int m68k_is_valid_instruction(unsigned int instruction, unsigned int cpu_type);

/* Disassemble 1 instruction using the epecified CPU type at pc.  Stores
 * disassembly in str_buff and returns the size of the instruction in bytes.
 */
unsigned int m68k_disassemble(char* str_buff, unsigned int pc, unsigned int cpu_type);

/* Same as above but accepts raw opcode data directly rather than fetching
 * via the read/write interfaces.
 */
unsigned int m68k_disassemble_raw(char* str_buff, unsigned int pc, const unsigned char* opdata, const unsigned char* argdata, unsigned int cpu_type);

/* ======================================================================== */
/* ============================== MAME STUFF ============================== */
/* ======================================================================== */

#if M68K_COMPILE_FOR_MAME == OPT_ON
#include "m68kmame.h"
#endif /* M68K_COMPILE_FOR_MAME */

/* ======================================================================== */
/* ============================== END OF FILE ============================= */
/* ======================================================================== */

#ifdef __cplusplus
}
#endif

#endif /* M68K__HEADER */

/* --------------------------- Internal Headers ------------------------ */
/* ======================================================================== */
/* ========================= LICENSING & COPYRIGHT ======================== */
/* ======================================================================== */
/*
 *                                  MUSASHI
 *                                Version 4.5
 *
 * A portable Motorola M680x0 processor emulation engine.
 * Copyright Karl Stenerud.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#ifndef M68KCPU__HEADER
#define M68KCPU__HEADER

#ifdef __cplusplus
extern "C" {
#endif

#include <limits.h>
#include <string.h>

#include <setjmp.h>

/* ======================================================================== */
/* ==================== ARCHITECTURE-DEPENDANT DEFINES ==================== */
/* ======================================================================== */

/* Check for > 32bit sizes */
#if UINT_MAX > 0xffffffff
#define M68K_INT_GT_32_BIT 1
#else
#define M68K_INT_GT_32_BIT 0
#endif

/* Data types used in this emulation core */
#undef sint8
#undef sint16
#undef sint32
#undef sint64
#undef uint8
#undef uint16
#undef uint32
#undef uint64
#undef sint
#undef uint

typedef signed char sint8; /* ASG: changed from char to signed char */
typedef signed short sint16;
typedef signed int sint32; /* AWJ: changed from long to int */
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32; /* AWJ: changed from long to int */

/* signed and unsigned int must be at least 32 bits wide */
typedef signed int sint;
typedef unsigned int uint;

#if M68K_USE_64_BIT
typedef signed long long sint64;
typedef unsigned long long uint64;
#else
typedef sint32 sint64;
typedef uint32 uint64;
#endif /* M68K_USE_64_BIT */

/* U64 and S64 are used to wrap long integer constants. */
#ifdef __GNUC__
#define U64(val) val##ULL
#define S64(val) val##LL
#else
#define U64(val) val
#define S64(val) val
#endif

/* -- Begin embedded musashi/softfloat/milieu.h -- */

/*============================================================================

This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
Package, Release 2b.

Written by John R. Hauser.  This work was made possible in part by the
International Computer Science Institute, located at Suite 600, 1947 Center
Street, Berkeley, California 94704.  Funding was partially provided by the
National Science Foundation under grant MIP-9311980.  The original version
of this code was written as part of a project to build a fixed-point vector
processor in collaboration with the University of California at Berkeley,
overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
arithmetic/SoftFloat.html'.

THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.

Derivative works are acceptable, even for commercial purposes, so long as
(1) the source code for the derivative work includes prominent notice that
the work is derivative, and (2) the source code includes prominent notice with
these four paragraphs for those parts of this code that are retained.

=============================================================================*/

/*----------------------------------------------------------------------------
| Include common integer types and flags.
*----------------------------------------------------------------------------*/
/* -- Begin embedded musashi/softfloat/mamesf.h -- */
/*----------------------------------------------------------------------------
| One of the macros `BIGENDIAN' or `LITTLEENDIAN' must be defined.
*----------------------------------------------------------------------------*/
#ifdef LSB_FIRST
#define LITTLEENDIAN
#else
#define BIGENDIAN
#endif

/*----------------------------------------------------------------------------
| The macro `BITS64' can be defined to indicate that 64-bit integer types are
| supported by the compiler.
*----------------------------------------------------------------------------*/
#define BITS64

/*----------------------------------------------------------------------------
| Each of the following `typedef's defines the most convenient type that holds
| integers of at least as many bits as specified.  For example, `uint8' should
| be the most convenient type that can hold unsigned integers of as many as
| 8 bits.  The `flag' type must be able to hold either a 0 or 1.  For most
| implementations of C, `flag', `uint8', and `int8' should all be `typedef'ed
| to the same as `int'.
*----------------------------------------------------------------------------*/

typedef sint8 flag;
typedef sint8 int8;
typedef sint16 int16;
typedef sint32 int32;
typedef sint64 int64;

/*----------------------------------------------------------------------------
| Each of the following `typedef's defines a type that holds integers
| of _exactly_ the number of bits specified.  For instance, for most
| implementation of C, `bits16' and `sbits16' should be `typedef'ed to
| `unsigned short int' and `signed short int' (or `short int'), respectively.
*----------------------------------------------------------------------------*/
typedef uint8 bits8;
typedef sint8 sbits8;
typedef uint16 bits16;
typedef sint16 sbits16;
typedef uint32 bits32;
typedef sint32 sbits32;
typedef uint64 bits64;
typedef sint64 sbits64;

/*----------------------------------------------------------------------------
| The `LIT64' macro takes as its argument a textual integer literal and
| if necessary ``marks'' the literal as having a 64-bit integer type.
| For example, the GNU C Compiler (`gcc') requires that 64-bit literals be
| appended with the letters `LL' standing for `long long', which is `gcc's
| name for the 64-bit integer type.  Some compilers may allow `LIT64' to be
| defined as the identity macro:  `#define LIT64( a ) a'.
*----------------------------------------------------------------------------*/
#define LIT64(a) a##ULL

/*----------------------------------------------------------------------------
| The macro `INLINE' can be used before functions that should be inlined.  If
| a compiler does not support explicit inlining, this macro should be defined
| to be `static'.
*----------------------------------------------------------------------------*/
// MAME defines INLINE
/* -- End embedded musashi/softfloat/mamesf.h -- */

/*----------------------------------------------------------------------------
| Symbolic Boolean literals.
*----------------------------------------------------------------------------*/
#define FALSE 0
#define TRUE 1
/* -- End embedded musashi/softfloat/milieu.h -- */
/* -- Begin embedded musashi/softfloat/softfloat.h -- */

/*============================================================================

This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
Package, Release 2b.

Written by John R. Hauser.  This work was made possible in part by the
International Computer Science Institute, located at Suite 600, 1947 Center
Street, Berkeley, California 94704.  Funding was partially provided by the
National Science Foundation under grant MIP-9311980.  The original version
of this code was written as part of a project to build a fixed-point vector
processor in collaboration with the University of California at Berkeley,
overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
arithmetic/SoftFloat.html'.

THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.

Derivative works are acceptable, even for commercial purposes, so long as
(1) the source code for the derivative work includes prominent notice that
the work is derivative, and (2) the source code includes prominent notice with
these four paragraphs for those parts of this code that are retained.

=============================================================================*/

/*----------------------------------------------------------------------------
| The macro `FLOATX80' must be defined to enable the extended double-precision
| floating-point format `floatx80'.  If this macro is not defined, the
| `floatx80' type will not be defined, and none of the functions that either
| input or output the `floatx80' type will be defined.  The same applies to
| the `FLOAT128' macro and the quadruple-precision format `float128'.
*----------------------------------------------------------------------------*/
#define FLOATX80
#define FLOAT128

/*----------------------------------------------------------------------------
| Software IEC/IEEE floating-point types.
*----------------------------------------------------------------------------*/
typedef bits32 float32;
typedef bits64 float64;
#ifdef FLOATX80
typedef struct
{
    bits16 high;
    bits64 low;
} floatx80;
#endif
#ifdef FLOAT128
typedef struct
{
    bits64 high, low;
} float128;
#endif

/*----------------------------------------------------------------------------
| Primitive arithmetic functions, including multi-word arithmetic, and
| division and square root approximations.  (Can be specialized to target if
| desired.)
*----------------------------------------------------------------------------*/
/* -- Begin embedded musashi/softfloat/softfloat-macros -- */

/*============================================================================

This C source fragment is part of the SoftFloat IEC/IEEE Floating-point
Arithmetic Package, Release 2b.

Written by John R. Hauser.  This work was made possible in part by the
International Computer Science Institute, located at Suite 600, 1947 Center
Street, Berkeley, California 94704.  Funding was partially provided by the
National Science Foundation under grant MIP-9311980.  The original version
of this code was written as part of a project to build a fixed-point vector
processor in collaboration with the University of California at Berkeley,
overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
arithmetic/SoftFloat.html'.

THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
INSTITUTE (possibly via similar legal notice) AGAINST ALL LOSSES, COSTS, OR
OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.

Derivative works are acceptable, even for commercial purposes, so long as
(1) the source code for the derivative work includes prominent notice that
the work is derivative, and (2) the source code includes prominent notice with
these four paragraphs for those parts of this code that are retained.

=============================================================================*/

/*----------------------------------------------------------------------------
| Shifts `a' right by the number of bits given in `count'.  If any nonzero
| bits are shifted off, they are ``jammed'' into the least significant bit of
| the result by setting the least significant bit to 1.  The value of `count'
| can be arbitrarily large; in particular, if `count' is greater than 32, the
| result will be either 0 or 1, depending on whether `a' is zero or nonzero.
| The result is stored in the location pointed to by `zPtr'.
*----------------------------------------------------------------------------*/

static inline void shift32RightJamming(bits32 a, int16 count, bits32* zPtr)
{
    bits32 z;

    if (count == 0) {
        z = a;
    } else if (count < 32) {
        z = (a >> count) | ((a << ((-count) & 31)) != 0);
    } else {
        z = (a != 0);
    }
    *zPtr = z;
}

/*----------------------------------------------------------------------------
| Shifts `a' right by the number of bits given in `count'.  If any nonzero
| bits are shifted off, they are ``jammed'' into the least significant bit of
| the result by setting the least significant bit to 1.  The value of `count'
| can be arbitrarily large; in particular, if `count' is greater than 64, the
| result will be either 0 or 1, depending on whether `a' is zero or nonzero.
| The result is stored in the location pointed to by `zPtr'.
*----------------------------------------------------------------------------*/

static inline void shift64RightJamming(bits64 a, int16 count, bits64* zPtr)
{
    bits64 z;

    if (count == 0) {
        z = a;
    } else if (count < 64) {
        z = (a >> count) | ((a << ((-count) & 63)) != 0);
    } else {
        z = (a != 0);
    }
    *zPtr = z;
}

/*----------------------------------------------------------------------------
| Shifts the 128-bit value formed by concatenating `a0' and `a1' right by 64
| _plus_ the number of bits given in `count'.  The shifted result is at most
| 64 nonzero bits; this is stored at the location pointed to by `z0Ptr'.  The
| bits shifted off form a second 64-bit result as follows:  The _last_ bit
| shifted off is the most-significant bit of the extra result, and the other
| 63 bits of the extra result are all zero if and only if _all_but_the_last_
| bits shifted off were all zero.  This extra result is stored in the location
| pointed to by `z1Ptr'.  The value of `count' can be arbitrarily large.
|     (This routine makes more sense if `a0' and `a1' are considered to form
| a fixed-point value with binary point between `a0' and `a1'.  This fixed-
| point value is shifted right by the number of bits given in `count', and
| the integer part of the result is returned at the location pointed to by
| `z0Ptr'.  The fractional part of the result may be slightly corrupted as
| described above, and is returned at the location pointed to by `z1Ptr'.)
*----------------------------------------------------------------------------*/

static inline void
shift64ExtraRightJamming(
    bits64 a0, bits64 a1, int16 count, bits64* z0Ptr, bits64* z1Ptr)
{
    bits64 z0, z1;
    int8 negCount = (-count) & 63;

    if (count == 0) {
        z1 = a1;
        z0 = a0;
    } else if (count < 64) {
        z1 = (a0 << negCount) | (a1 != 0);
        z0 = a0 >> count;
    } else {
        if (count == 64) {
            z1 = a0 | (a1 != 0);
        } else {
            z1 = ((a0 | a1) != 0);
        }
        z0 = 0;
    }
    *z1Ptr = z1;
    *z0Ptr = z0;
}

/*----------------------------------------------------------------------------
| Shifts the 128-bit value formed by concatenating `a0' and `a1' right by the
| number of bits given in `count'.  Any bits shifted off are lost.  The value
| of `count' can be arbitrarily large; in particular, if `count' is greater
| than 128, the result will be 0.  The result is broken into two 64-bit pieces
| which are stored at the locations pointed to by `z0Ptr' and `z1Ptr'.
*----------------------------------------------------------------------------*/

static inline void
shift128Right(
    bits64 a0, bits64 a1, int16 count, bits64* z0Ptr, bits64* z1Ptr)
{
    bits64 z0, z1;
    int8 negCount = (-count) & 63;

    if (count == 0) {
        z1 = a1;
        z0 = a0;
    } else if (count < 64) {
        z1 = (a0 << negCount) | (a1 >> count);
        z0 = a0 >> count;
    } else {
        z1 = (count < 64) ? (a0 >> (count & 63)) : 0;
        z0 = 0;
    }
    *z1Ptr = z1;
    *z0Ptr = z0;
}

/*----------------------------------------------------------------------------
| Shifts the 128-bit value formed by concatenating `a0' and `a1' right by the
| number of bits given in `count'.  If any nonzero bits are shifted off, they
| are ``jammed'' into the least significant bit of the result by setting the
| least significant bit to 1.  The value of `count' can be arbitrarily large;
| in particular, if `count' is greater than 128, the result will be either
| 0 or 1, depending on whether the concatenation of `a0' and `a1' is zero or
| nonzero.  The result is broken into two 64-bit pieces which are stored at
| the locations pointed to by `z0Ptr' and `z1Ptr'.
*----------------------------------------------------------------------------*/

static inline void
shift128RightJamming(
    bits64 a0, bits64 a1, int16 count, bits64* z0Ptr, bits64* z1Ptr)
{
    bits64 z0, z1;
    int8 negCount = (-count) & 63;

    if (count == 0) {
        z1 = a1;
        z0 = a0;
    } else if (count < 64) {
        z1 = (a0 << negCount) | (a1 >> count) | ((a1 << negCount) != 0);
        z0 = a0 >> count;
    } else {
        if (count == 64) {
            z1 = a0 | (a1 != 0);
        } else if (count < 128) {
            z1 = (a0 >> (count & 63)) | (((a0 << negCount) | a1) != 0);
        } else {
            z1 = ((a0 | a1) != 0);
        }
        z0 = 0;
    }
    *z1Ptr = z1;
    *z0Ptr = z0;
}

/*----------------------------------------------------------------------------
| Shifts the 192-bit value formed by concatenating `a0', `a1', and `a2' right
| by 64 _plus_ the number of bits given in `count'.  The shifted result is
| at most 128 nonzero bits; these are broken into two 64-bit pieces which are
| stored at the locations pointed to by `z0Ptr' and `z1Ptr'.  The bits shifted
| off form a third 64-bit result as follows:  The _last_ bit shifted off is
| the most-significant bit of the extra result, and the other 63 bits of the
| extra result are all zero if and only if _all_but_the_last_ bits shifted off
| were all zero.  This extra result is stored in the location pointed to by
| `z2Ptr'.  The value of `count' can be arbitrarily large.
|     (This routine makes more sense if `a0', `a1', and `a2' are considered
| to form a fixed-point value with binary point between `a1' and `a2'.  This
| fixed-point value is shifted right by the number of bits given in `count',
| and the integer part of the result is returned at the locations pointed to
| by `z0Ptr' and `z1Ptr'.  The fractional part of the result may be slightly
| corrupted as described above, and is returned at the location pointed to by
| `z2Ptr'.)
*----------------------------------------------------------------------------*/

static inline void
shift128ExtraRightJamming(
    bits64 a0,
    bits64 a1,
    bits64 a2,
    int16 count,
    bits64* z0Ptr,
    bits64* z1Ptr,
    bits64* z2Ptr)
{
    bits64 z0, z1, z2;
    int8 negCount = (-count) & 63;

    if (count == 0) {
        z2 = a2;
        z1 = a1;
        z0 = a0;
    } else {
        if (count < 64) {
            z2 = a1 << negCount;
            z1 = (a0 << negCount) | (a1 >> count);
            z0 = a0 >> count;
        } else {
            if (count == 64) {
                z2 = a1;
                z1 = a0;
            } else {
                a2 |= a1;
                if (count < 128) {
                    z2 = a0 << negCount;
                    z1 = a0 >> (count & 63);
                } else {
                    z2 = (count == 128) ? a0 : (a0 != 0);
                    z1 = 0;
                }
            }
            z0 = 0;
        }
        z2 |= (a2 != 0);
    }
    *z2Ptr = z2;
    *z1Ptr = z1;
    *z0Ptr = z0;
}

/*----------------------------------------------------------------------------
| Shifts the 128-bit value formed by concatenating `a0' and `a1' left by the
| number of bits given in `count'.  Any bits shifted off are lost.  The value
| of `count' must be less than 64.  The result is broken into two 64-bit
| pieces which are stored at the locations pointed to by `z0Ptr' and `z1Ptr'.
*----------------------------------------------------------------------------*/

static inline void
shortShift128Left(
    bits64 a0, bits64 a1, int16 count, bits64* z0Ptr, bits64* z1Ptr)
{

    *z1Ptr = a1 << count;
    *z0Ptr =
        (count == 0) ? a0 : (a0 << count) | (a1 >> ((-count) & 63));
}

/*----------------------------------------------------------------------------
| Shifts the 192-bit value formed by concatenating `a0', `a1', and `a2' left
| by the number of bits given in `count'.  Any bits shifted off are lost.
| The value of `count' must be less than 64.  The result is broken into three
| 64-bit pieces which are stored at the locations pointed to by `z0Ptr',
| `z1Ptr', and `z2Ptr'.
*----------------------------------------------------------------------------*/

static inline void
shortShift192Left(
    bits64 a0,
    bits64 a1,
    bits64 a2,
    int16 count,
    bits64* z0Ptr,
    bits64* z1Ptr,
    bits64* z2Ptr)
{
    bits64 z0, z1, z2;
    int8 negCount;

    z2 = a2 << count;
    z1 = a1 << count;
    z0 = a0 << count;
    if (0 < count) {
        negCount = ((-count) & 63);
        z1 |= a2 >> negCount;
        z0 |= a1 >> negCount;
    }
    *z2Ptr = z2;
    *z1Ptr = z1;
    *z0Ptr = z0;
}

/*----------------------------------------------------------------------------
| Adds the 128-bit value formed by concatenating `a0' and `a1' to the 128-bit
| value formed by concatenating `b0' and `b1'.  Addition is modulo 2^128, so
| any carry out is lost.  The result is broken into two 64-bit pieces which
| are stored at the locations pointed to by `z0Ptr' and `z1Ptr'.
*----------------------------------------------------------------------------*/

static inline void
add128(
    bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64* z0Ptr, bits64* z1Ptr)
{
    bits64 z1;

    z1 = a1 + b1;
    *z1Ptr = z1;
    *z0Ptr = a0 + b0 + (z1 < a1);
}

/*----------------------------------------------------------------------------
| Adds the 192-bit value formed by concatenating `a0', `a1', and `a2' to the
| 192-bit value formed by concatenating `b0', `b1', and `b2'.  Addition is
| modulo 2^192, so any carry out is lost.  The result is broken into three
| 64-bit pieces which are stored at the locations pointed to by `z0Ptr',
| `z1Ptr', and `z2Ptr'.
*----------------------------------------------------------------------------*/

static inline void
add192(
    bits64 a0,
    bits64 a1,
    bits64 a2,
    bits64 b0,
    bits64 b1,
    bits64 b2,
    bits64* z0Ptr,
    bits64* z1Ptr,
    bits64* z2Ptr)
{
    bits64 z0, z1, z2;
    uint8 carry0, carry1;

    z2 = a2 + b2;
    carry1 = (z2 < a2);
    z1 = a1 + b1;
    carry0 = (z1 < a1);
    z0 = a0 + b0;
    z1 += carry1;
    z0 += (z1 < carry1);
    z0 += carry0;
    *z2Ptr = z2;
    *z1Ptr = z1;
    *z0Ptr = z0;
}

/*----------------------------------------------------------------------------
| Subtracts the 128-bit value formed by concatenating `b0' and `b1' from the
| 128-bit value formed by concatenating `a0' and `a1'.  Subtraction is modulo
| 2^128, so any borrow out (carry out) is lost.  The result is broken into two
| 64-bit pieces which are stored at the locations pointed to by `z0Ptr' and
| `z1Ptr'.
*----------------------------------------------------------------------------*/

static inline void
sub128(
    bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64* z0Ptr, bits64* z1Ptr)
{

    *z1Ptr = a1 - b1;
    *z0Ptr = a0 - b0 - (a1 < b1);
}

/*----------------------------------------------------------------------------
| Subtracts the 192-bit value formed by concatenating `b0', `b1', and `b2'
| from the 192-bit value formed by concatenating `a0', `a1', and `a2'.
| Subtraction is modulo 2^192, so any borrow out (carry out) is lost.  The
| result is broken into three 64-bit pieces which are stored at the locations
| pointed to by `z0Ptr', `z1Ptr', and `z2Ptr'.
*----------------------------------------------------------------------------*/

static inline void
sub192(
    bits64 a0,
    bits64 a1,
    bits64 a2,
    bits64 b0,
    bits64 b1,
    bits64 b2,
    bits64* z0Ptr,
    bits64* z1Ptr,
    bits64* z2Ptr)
{
    bits64 z0, z1, z2;
    uint8 borrow0, borrow1;

    z2 = a2 - b2;
    borrow1 = (a2 < b2);
    z1 = a1 - b1;
    borrow0 = (a1 < b1);
    z0 = a0 - b0;
    z0 -= (z1 < borrow1);
    z1 -= borrow1;
    z0 -= borrow0;
    *z2Ptr = z2;
    *z1Ptr = z1;
    *z0Ptr = z0;
}

/*----------------------------------------------------------------------------
| Multiplies `a' by `b' to obtain a 128-bit product.  The product is broken
| into two 64-bit pieces which are stored at the locations pointed to by
| `z0Ptr' and `z1Ptr'.
*----------------------------------------------------------------------------*/

static inline void mul64To128(bits64 a, bits64 b, bits64* z0Ptr, bits64* z1Ptr)
{
    bits32 aHigh, aLow, bHigh, bLow;
    bits64 z0, zMiddleA, zMiddleB, z1;

    aLow = a;
    aHigh = a >> 32;
    bLow = b;
    bHigh = b >> 32;
    z1 = ((bits64)aLow) * bLow;
    zMiddleA = ((bits64)aLow) * bHigh;
    zMiddleB = ((bits64)aHigh) * bLow;
    z0 = ((bits64)aHigh) * bHigh;
    zMiddleA += zMiddleB;
    z0 += (((bits64)(zMiddleA < zMiddleB)) << 32) + (zMiddleA >> 32);
    zMiddleA <<= 32;
    z1 += zMiddleA;
    z0 += (z1 < zMiddleA);
    *z1Ptr = z1;
    *z0Ptr = z0;
}

/*----------------------------------------------------------------------------
| Multiplies the 128-bit value formed by concatenating `a0' and `a1' by
| `b' to obtain a 192-bit product.  The product is broken into three 64-bit
| pieces which are stored at the locations pointed to by `z0Ptr', `z1Ptr', and
| `z2Ptr'.
*----------------------------------------------------------------------------*/

static inline void
mul128By64To192(
    bits64 a0,
    bits64 a1,
    bits64 b,
    bits64* z0Ptr,
    bits64* z1Ptr,
    bits64* z2Ptr)
{
    bits64 z0, z1, z2, more1;

    mul64To128(a1, b, &z1, &z2);
    mul64To128(a0, b, &z0, &more1);
    add128(z0, more1, 0, z1, &z0, &z1);
    *z2Ptr = z2;
    *z1Ptr = z1;
    *z0Ptr = z0;
}

/*----------------------------------------------------------------------------
| Multiplies the 128-bit value formed by concatenating `a0' and `a1' to the
| 128-bit value formed by concatenating `b0' and `b1' to obtain a 256-bit
| product.  The product is broken into four 64-bit pieces which are stored at
| the locations pointed to by `z0Ptr', `z1Ptr', `z2Ptr', and `z3Ptr'.
*----------------------------------------------------------------------------*/

static inline void
mul128To256(
    bits64 a0,
    bits64 a1,
    bits64 b0,
    bits64 b1,
    bits64* z0Ptr,
    bits64* z1Ptr,
    bits64* z2Ptr,
    bits64* z3Ptr)
{
    bits64 z0, z1, z2, z3;
    bits64 more1, more2;

    mul64To128(a1, b1, &z2, &z3);
    mul64To128(a1, b0, &z1, &more2);
    add128(z1, more2, 0, z2, &z1, &z2);
    mul64To128(a0, b0, &z0, &more1);
    add128(z0, more1, 0, z1, &z0, &z1);
    mul64To128(a0, b1, &more1, &more2);
    add128(more1, more2, 0, z2, &more1, &z2);
    add128(z0, z1, 0, more1, &z0, &z1);
    *z3Ptr = z3;
    *z2Ptr = z2;
    *z1Ptr = z1;
    *z0Ptr = z0;
}

/*----------------------------------------------------------------------------
| Returns an approximation to the 64-bit integer quotient obtained by dividing
| `b' into the 128-bit value formed by concatenating `a0' and `a1'.  The
| divisor `b' must be at least 2^63.  If q is the exact quotient truncated
| toward zero, the approximation returned lies between q and q + 2 inclusive.
| If the exact quotient q is larger than 64 bits, the maximum positive 64-bit
| unsigned integer is returned.
*----------------------------------------------------------------------------*/

static inline bits64 estimateDiv128To64(bits64 a0, bits64 a1, bits64 b)
{
    bits64 b0, b1;
    bits64 rem0, rem1, term0, term1;
    bits64 z;

    if (b <= a0) {
        return LIT64(0xFFFFFFFFFFFFFFFF);
    }
    b0 = b >> 32;
    z = (b0 << 32 <= a0) ? LIT64(0xFFFFFFFF00000000) : (a0 / b0) << 32;
    mul64To128(b, z, &term0, &term1);
    sub128(a0, a1, term0, term1, &rem0, &rem1);
    while (((sbits64)rem0) < 0) {
        z -= LIT64(0x100000000);
        b1 = b << 32;
        add128(rem0, rem1, b0, b1, &rem0, &rem1);
    }
    rem0 = (rem0 << 32) | (rem1 >> 32);
    z |= (b0 << 32 <= rem0) ? 0xFFFFFFFF : rem0 / b0;
    return z;
}

/*----------------------------------------------------------------------------
| Returns an approximation to the square root of the 32-bit significand given
| by `a'.  Considered as an integer, `a' must be at least 2^31.  If bit 0 of
| `aExp' (the least significant bit) is 1, the integer returned approximates
| 2^31*sqrt(`a'/2^31), where `a' is considered an integer.  If bit 0 of `aExp'
| is 0, the integer returned approximates 2^31*sqrt(`a'/2^30).  In either
| case, the approximation returned lies strictly within +/-2 of the exact
| value.
*----------------------------------------------------------------------------*/

static inline bits32 estimateSqrt32(int16 aExp, bits32 a)
{
    static const bits16 sqrtOddAdjustments[] = {
        0x0004, 0x0022, 0x005D, 0x00B1, 0x011D, 0x019F, 0x0236, 0x02E0,
        0x039C, 0x0468, 0x0545, 0x0631, 0x072B, 0x0832, 0x0946, 0x0A67};
    static const bits16 sqrtEvenAdjustments[] = {
        0x0A2D, 0x08AF, 0x075A, 0x0629, 0x051A, 0x0429, 0x0356, 0x029E,
        0x0200, 0x0179, 0x0109, 0x00AF, 0x0068, 0x0034, 0x0012, 0x0002};
    int8 index;
    bits32 z;

    index = (a >> 27) & 15;
    if (aExp & 1) {
        z = 0x4000 + (a >> 17) - sqrtOddAdjustments[index];
        z = ((a / z) << 14) + (z << 15);
        a >>= 1;
    } else {
        z = 0x8000 + (a >> 17) - sqrtEvenAdjustments[index];
        z = a / z + z;
        z = (0x20000 <= z) ? 0xFFFF8000 : (z << 15);
        if (z <= a) {
            return (bits32)(((sbits32)a) >> 1);
        }
    }
    return ((bits32)((((bits64)a) << 31) / z)) + (z >> 1);
}

/*----------------------------------------------------------------------------
| Returns the number of leading 0 bits before the most-significant 1 bit of
| `a'.  If `a' is zero, 32 is returned.
*----------------------------------------------------------------------------*/

static int8 countLeadingZeros32(bits32 a)
{
    static const int8 countLeadingZerosHigh[] = {
        8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    int8 shiftCount;

    shiftCount = 0;
    if (a < 0x10000) {
        shiftCount += 16;
        a <<= 16;
    }
    if (a < 0x1000000) {
        shiftCount += 8;
        a <<= 8;
    }
    shiftCount += countLeadingZerosHigh[a >> 24];
    return shiftCount;
}

/*----------------------------------------------------------------------------
| Returns the number of leading 0 bits before the most-significant 1 bit of
| `a'.  If `a' is zero, 64 is returned.
*----------------------------------------------------------------------------*/

static int8 countLeadingZeros64(bits64 a)
{
    int8 shiftCount;

    shiftCount = 0;
    if (a < ((bits64)1) << 32) {
        shiftCount += 32;
    } else {
        a >>= 32;
    }
    shiftCount += countLeadingZeros32(a);
    return shiftCount;
}

/*----------------------------------------------------------------------------
| Returns 1 if the 128-bit value formed by concatenating `a0' and `a1'
| is equal to the 128-bit value formed by concatenating `b0' and `b1'.
| Otherwise, returns 0.
*----------------------------------------------------------------------------*/

static inline flag eq128(bits64 a0, bits64 a1, bits64 b0, bits64 b1)
{

    return (a0 == b0) && (a1 == b1);
}

/*----------------------------------------------------------------------------
| Returns 1 if the 128-bit value formed by concatenating `a0' and `a1' is less
| than or equal to the 128-bit value formed by concatenating `b0' and `b1'.
| Otherwise, returns 0.
*----------------------------------------------------------------------------*/

static inline flag le128(bits64 a0, bits64 a1, bits64 b0, bits64 b1)
{

    return (a0 < b0) || ((a0 == b0) && (a1 <= b1));
}

/*----------------------------------------------------------------------------
| Returns 1 if the 128-bit value formed by concatenating `a0' and `a1' is less
| than the 128-bit value formed by concatenating `b0' and `b1'.  Otherwise,
| returns 0.
*----------------------------------------------------------------------------*/

static inline flag lt128(bits64 a0, bits64 a1, bits64 b0, bits64 b1)
{

    return (a0 < b0) || ((a0 == b0) && (a1 < b1));
}

/*----------------------------------------------------------------------------
| Returns 1 if the 128-bit value formed by concatenating `a0' and `a1' is
| not equal to the 128-bit value formed by concatenating `b0' and `b1'.
| Otherwise, returns 0.
*----------------------------------------------------------------------------*/

static inline flag ne128(bits64 a0, bits64 a1, bits64 b0, bits64 b1)
{

    return (a0 != b0) || (a1 != b1);
}

/*-----------------------------------------------------------------------------
| Changes the sign of the extended double-precision floating-point value 'a'.
| The operation is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

static inline floatx80 floatx80_chs(floatx80 reg)
{
    reg.high ^= 0x8000;
    return reg;
}

/* -- End embedded musashi/softfloat/softfloat-macros -- */

/*----------------------------------------------------------------------------
| Software IEC/IEEE floating-point underflow tininess-detection mode.
*----------------------------------------------------------------------------*/
extern int8 float_detect_tininess;
enum {
    float_tininess_after_rounding = 0,
    float_tininess_before_rounding = 1
};

/*----------------------------------------------------------------------------
| Software IEC/IEEE floating-point rounding mode.
*----------------------------------------------------------------------------*/
extern int8 float_rounding_mode;
enum {
    float_round_nearest_even = 0,
    float_round_to_zero = 1,
    float_round_down = 2,
    float_round_up = 3
};

/*----------------------------------------------------------------------------
| Software IEC/IEEE floating-point exception flags.
*----------------------------------------------------------------------------*/
extern int8 float_exception_flags;
enum {
    float_flag_invalid = 0x01,
    float_flag_denormal = 0x02,
    float_flag_divbyzero = 0x04,
    float_flag_overflow = 0x08,
    float_flag_underflow = 0x10,
    float_flag_inexact = 0x20
};

/*----------------------------------------------------------------------------
| Routine to raise any or all of the software IEC/IEEE floating-point
| exception flags.
*----------------------------------------------------------------------------*/
void float_raise(int8);

/*----------------------------------------------------------------------------
| Software IEC/IEEE integer-to-floating-point conversion routines.
*----------------------------------------------------------------------------*/
float32 int32_to_float32(int32);
float64 int32_to_float64(int32);
#ifdef FLOATX80
floatx80 int32_to_floatx80(int32);
#endif
#ifdef FLOAT128
float128 int32_to_float128(int32);
#endif
float32 int64_to_float32(int64);
float64 int64_to_float64(int64);
#ifdef FLOATX80
floatx80 int64_to_floatx80(int64);
#endif
#ifdef FLOAT128
float128 int64_to_float128(int64);
#endif

/*----------------------------------------------------------------------------
| Software IEC/IEEE single-precision conversion routines.
*----------------------------------------------------------------------------*/
int32 float32_to_int32(float32);
int32 float32_to_int32_round_to_zero(float32);
int64 float32_to_int64(float32);
int64 float32_to_int64_round_to_zero(float32);
float64 float32_to_float64(float32);
#ifdef FLOATX80
floatx80 float32_to_floatx80(float32);
#endif
#ifdef FLOAT128
float128 float32_to_float128(float32);
#endif

/*----------------------------------------------------------------------------
| Software IEC/IEEE single-precision operations.
*----------------------------------------------------------------------------*/
float32 float32_round_to_int(float32);
float32 float32_add(float32, float32);
float32 float32_sub(float32, float32);
float32 float32_mul(float32, float32);
float32 float32_div(float32, float32);
float32 float32_rem(float32, float32);
float32 float32_sqrt(float32);
flag float32_eq(float32, float32);
flag float32_le(float32, float32);
flag float32_lt(float32, float32);
flag float32_eq_signaling(float32, float32);
flag float32_le_quiet(float32, float32);
flag float32_lt_quiet(float32, float32);
flag float32_is_signaling_nan(float32);

/*----------------------------------------------------------------------------
| Software IEC/IEEE double-precision conversion routines.
*----------------------------------------------------------------------------*/
int32 float64_to_int32(float64);
int32 float64_to_int32_round_to_zero(float64);
int64 float64_to_int64(float64);
int64 float64_to_int64_round_to_zero(float64);
float32 float64_to_float32(float64);
#ifdef FLOATX80
floatx80 float64_to_floatx80(float64);
#endif
#ifdef FLOAT128
float128 float64_to_float128(float64);
#endif

/*----------------------------------------------------------------------------
| Software IEC/IEEE double-precision operations.
*----------------------------------------------------------------------------*/
float64 float64_round_to_int(float64);
float64 float64_add(float64, float64);
float64 float64_sub(float64, float64);
float64 float64_mul(float64, float64);
float64 float64_div(float64, float64);
float64 float64_rem(float64, float64);
float64 float64_sqrt(float64);
flag float64_eq(float64, float64);
flag float64_le(float64, float64);
flag float64_lt(float64, float64);
flag float64_eq_signaling(float64, float64);
flag float64_le_quiet(float64, float64);
flag float64_lt_quiet(float64, float64);
flag float64_is_signaling_nan(float64);

#ifdef FLOATX80

/*----------------------------------------------------------------------------
| Software IEC/IEEE extended double-precision conversion routines.
*----------------------------------------------------------------------------*/
int32 floatx80_to_int32(floatx80);
int32 floatx80_to_int32_round_to_zero(floatx80);
int64 floatx80_to_int64(floatx80);
int64 floatx80_to_int64_round_to_zero(floatx80);
float32 floatx80_to_float32(floatx80);
float64 floatx80_to_float64(floatx80);
#ifdef FLOAT128
float128 floatx80_to_float128(floatx80);
#endif
floatx80 floatx80_scale(floatx80 a, floatx80 b);

/*----------------------------------------------------------------------------
| Packs the sign `zSign', exponent `zExp', and significand `zSig' into an
| extended double-precision floating-point value, returning the result.
*----------------------------------------------------------------------------*/

static inline floatx80 packFloatx80(flag zSign, int32 zExp, bits64 zSig)
{
    floatx80 z;

    z.low = zSig;
    z.high = (((bits16)zSign) << 15) + zExp;
    return z;
}

/*----------------------------------------------------------------------------
| Software IEC/IEEE extended double-precision rounding precision.  Valid
| values are 32, 64, and 80.
*----------------------------------------------------------------------------*/
extern int8 floatx80_rounding_precision;

/*----------------------------------------------------------------------------
| Software IEC/IEEE extended double-precision operations.
*----------------------------------------------------------------------------*/
floatx80 floatx80_round_to_int(floatx80);
floatx80 floatx80_add(floatx80, floatx80);
floatx80 floatx80_sub(floatx80, floatx80);
floatx80 floatx80_mul(floatx80, floatx80);
floatx80 floatx80_div(floatx80, floatx80);
floatx80 floatx80_rem(floatx80, floatx80);
floatx80 floatx80_sqrt(floatx80);
flag floatx80_eq(floatx80, floatx80);
flag floatx80_le(floatx80, floatx80);
flag floatx80_lt(floatx80, floatx80);
flag floatx80_eq_signaling(floatx80, floatx80);
flag floatx80_le_quiet(floatx80, floatx80);
flag floatx80_lt_quiet(floatx80, floatx80);
flag floatx80_is_signaling_nan(floatx80);

/* int floatx80_fsin(floatx80 &a);
int floatx80_fcos(floatx80 &a);
int floatx80_ftan(floatx80 &a); */

floatx80 floatx80_flognp1(floatx80 a);
floatx80 floatx80_flogn(floatx80 a);
floatx80 floatx80_flog2(floatx80 a);
floatx80 floatx80_flog10(floatx80 a);

// roundAndPackFloatx80 used to be in softfloat-round-pack, is now in softfloat.c
floatx80 roundAndPackFloatx80(int8 roundingPrecision, flag zSign, int32 zExp, bits64 zSig0, bits64 zSig1);

#endif

#ifdef FLOAT128

/*----------------------------------------------------------------------------
| Software IEC/IEEE quadruple-precision conversion routines.
*----------------------------------------------------------------------------*/
int32 float128_to_int32(float128);
int32 float128_to_int32_round_to_zero(float128);
int64 float128_to_int64(float128);
int64 float128_to_int64_round_to_zero(float128);
float32 float128_to_float32(float128);
float64 float128_to_float64(float128);
#ifdef FLOATX80
floatx80 float128_to_floatx80(float128);
#endif

/*----------------------------------------------------------------------------
| Software IEC/IEEE quadruple-precision operations.
*----------------------------------------------------------------------------*/
float128 float128_round_to_int(float128);
float128 float128_add(float128, float128);
float128 float128_sub(float128, float128);
float128 float128_mul(float128, float128);
float128 float128_div(float128, float128);
float128 float128_rem(float128, float128);
float128 float128_sqrt(float128);
flag float128_eq(float128, float128);
flag float128_le(float128, float128);
flag float128_lt(float128, float128);
flag float128_eq_signaling(float128, float128);
flag float128_le_quiet(float128, float128);
flag float128_lt_quiet(float128, float128);
flag float128_is_signaling_nan(float128);

/*----------------------------------------------------------------------------
| Packs the sign `zSign', the exponent `zExp', and the significand formed
| by the concatenation of `zSig0' and `zSig1' into a quadruple-precision
| floating-point value, returning the result.  After being shifted into the
| proper positions, the three fields `zSign', `zExp', and `zSig0' are simply
| added together to form the most significant 32 bits of the result.  This
| means that any integer portion of `zSig0' will be added into the exponent.
| Since a properly normalized significand will have an integer portion equal
| to 1, the `zExp' input should be 1 less than the desired result exponent
| whenever `zSig0' and `zSig1' concatenated form a complete, normalized
| significand.
*----------------------------------------------------------------------------*/

static inline float128
packFloat128(flag zSign, int32 zExp, bits64 zSig0, bits64 zSig1)
{
    float128 z;

    z.low = zSig1;
    z.high = (((bits64)zSign) << 63) + (((bits64)zExp) << 48) + zSig0;
    return z;
}

/*----------------------------------------------------------------------------
| Takes an abstract floating-point value having sign `zSign', exponent `zExp',
| and extended significand formed by the concatenation of `zSig0', `zSig1',
| and `zSig2', and returns the proper quadruple-precision floating-point value
| corresponding to the abstract input.  Ordinarily, the abstract value is
| simply rounded and packed into the quadruple-precision format, with the
| inexact exception raised if the abstract input cannot be represented
| exactly.  However, if the abstract value is too large, the overflow and
| inexact exceptions are raised and an infinity or maximal finite value is
| returned.  If the abstract value is too small, the input value is rounded to
| a subnormal number, and the underflow and inexact exceptions are raised if
| the abstract input cannot be represented exactly as a subnormal quadruple-
| precision floating-point number.
|     The input significand must be normalized or smaller.  If the input
| significand is not normalized, `zExp' must be 0; in that case, the result
| returned is a subnormal number, and it must not require rounding.  In the
| usual case that the input significand is normalized, `zExp' must be 1 less
| than the ``true'' floating-point exponent.  The handling of underflow and
| overflow follows the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

static inline float128
roundAndPackFloat128(
    flag zSign, int32 zExp, bits64 zSig0, bits64 zSig1, bits64 zSig2)
{
    int8 roundingMode;
    flag roundNearestEven, increment, isTiny;

    roundingMode = float_rounding_mode;
    roundNearestEven = (roundingMode == float_round_nearest_even);
    increment = ((sbits64)zSig2 < 0);
    if (!roundNearestEven) {
        if (roundingMode == float_round_to_zero) {
            increment = 0;
        } else {
            if (zSign) {
                increment = (roundingMode == float_round_down) && zSig2;
            } else {
                increment = (roundingMode == float_round_up) && zSig2;
            }
        }
    }
    if (0x7FFD <= (bits32)zExp) {
        if ((0x7FFD < zExp) || ((zExp == 0x7FFD) && eq128(LIT64(0x0001FFFFFFFFFFFF), LIT64(0xFFFFFFFFFFFFFFFF), zSig0, zSig1) && increment)) {
            float_raise(float_flag_overflow | float_flag_inexact);
            if ((roundingMode == float_round_to_zero) || (zSign && (roundingMode == float_round_up)) || (!zSign && (roundingMode == float_round_down))) {
                return packFloat128(
                    zSign,
                    0x7FFE,
                    LIT64(0x0000FFFFFFFFFFFF),
                    LIT64(0xFFFFFFFFFFFFFFFF));
            }
            return packFloat128(zSign, 0x7FFF, 0, 0);
        }
        if (zExp < 0) {
            isTiny =
                (float_detect_tininess == float_tininess_before_rounding) || (zExp < -1) || !increment || lt128(zSig0, zSig1, LIT64(0x0001FFFFFFFFFFFF), LIT64(0xFFFFFFFFFFFFFFFF));
            shift128ExtraRightJamming(
                zSig0, zSig1, zSig2, -zExp, &zSig0, &zSig1, &zSig2);
            zExp = 0;
            if (isTiny && zSig2) {
                float_raise(float_flag_underflow);
            }
            if (roundNearestEven) {
                increment = ((sbits64)zSig2 < 0);
            } else {
                if (zSign) {
                    increment = (roundingMode == float_round_down) && zSig2;
                } else {
                    increment = (roundingMode == float_round_up) && zSig2;
                }
            }
        }
    }
    if (zSig2) {
        float_exception_flags |= float_flag_inexact;
    }
    if (increment) {
        add128(zSig0, zSig1, 0, 1, &zSig0, &zSig1);
        zSig1 &= ~((zSig2 + zSig2 == 0) & roundNearestEven);
    } else {
        if ((zSig0 | zSig1) == 0) {
            zExp = 0;
        }
    }
    return packFloat128(zSign, zExp, zSig0, zSig1);
}

/*----------------------------------------------------------------------------
| Takes an abstract floating-point value having sign `zSign', exponent `zExp',
| and significand formed by the concatenation of `zSig0' and `zSig1', and
| returns the proper quadruple-precision floating-point value corresponding
| to the abstract input.  This routine is just like `roundAndPackFloat128'
| except that the input significand has fewer bits and does not have to be
| normalized.  In all cases, `zExp' must be 1 less than the ``true'' floating-
| point exponent.
*----------------------------------------------------------------------------*/

static inline float128
normalizeRoundAndPackFloat128(
    flag zSign, int32 zExp, bits64 zSig0, bits64 zSig1)
{
    int8 shiftCount;
    bits64 zSig2;

    if (zSig0 == 0) {
        zSig0 = zSig1;
        zSig1 = 0;
        zExp -= 64;
    }
    shiftCount = countLeadingZeros64(zSig0) - 15;
    if (0 <= shiftCount) {
        zSig2 = 0;
        shortShift128Left(zSig0, zSig1, shiftCount, &zSig0, &zSig1);
    } else {
        shift128ExtraRightJamming(
            zSig0, zSig1, 0, -shiftCount, &zSig0, &zSig1, &zSig2);
    }
    zExp -= shiftCount;
    return roundAndPackFloat128(zSign, zExp, zSig0, zSig1, zSig2);
}
#endif
/* -- End embedded musashi/softfloat/softfloat.h -- */

/* Allow for architectures that don't have 8-bit sizes */
#if UCHAR_MAX == 0xff
#define MAKE_INT_8(A) (sint8)(A)
#else
#undef sint8
#define sint8 signed int
#undef uint8
#define uint8 unsigned int
static inline sint MAKE_INT_8(uint value)
{
    return (value & 0x80) ? value | ~0xff : value & 0xff;
}
#endif /* UCHAR_MAX == 0xff */

/* Allow for architectures that don't have 16-bit sizes */
#if USHRT_MAX == 0xffff
#define MAKE_INT_16(A) (sint16)(A)
#else
#undef sint16
#define sint16 signed int
#undef uint16
#define uint16 unsigned int
static inline sint MAKE_INT_16(uint value)
{
    return (value & 0x8000) ? value | ~0xffff : value & 0xffff;
}
#endif /* USHRT_MAX == 0xffff */

/* Allow for architectures that don't have 32-bit sizes */
#if UINT_MAX == 0xffffffff
#define MAKE_INT_32(A) (sint32)(A)
#else
#undef sint32
#define sint32 signed int
#undef uint32
#define uint32 unsigned int
static inline sint MAKE_INT_32(uint value)
{
    return (value & 0x80000000) ? value | ~0xffffffff : value & 0xffffffff;
}
#endif /* UINT_MAX == 0xffffffff */

/* ======================================================================== */
/* ============================ GENERAL DEFINES =========================== */
/* ======================================================================== */

/* Exception Vectors handled by emulation */
#define EXCEPTION_RESET 0
#define EXCEPTION_BUS_ERROR 2     /* This one is not emulated! */
#define EXCEPTION_ADDRESS_ERROR 3 /* This one is partially emulated (doesn't stack a proper frame yet) */
#define EXCEPTION_ILLEGAL_INSTRUCTION 4
#define EXCEPTION_ZERO_DIVIDE 5
#define EXCEPTION_CHK 6
#define EXCEPTION_TRAPV 7
#define EXCEPTION_PRIVILEGE_VIOLATION 8
#define EXCEPTION_TRACE 9
#define EXCEPTION_1010 10
#define EXCEPTION_1111 11
#define EXCEPTION_FORMAT_ERROR 14
#define EXCEPTION_UNINITIALIZED_INTERRUPT 15
#define EXCEPTION_SPURIOUS_INTERRUPT 24
#define EXCEPTION_INTERRUPT_AUTOVECTOR 24
#define EXCEPTION_TRAP_BASE 32

/* Function codes set by CPU during data/address bus activity */
#define FUNCTION_CODE_USER_DATA 1
#define FUNCTION_CODE_USER_PROGRAM 2
#define FUNCTION_CODE_SUPERVISOR_DATA 5
#define FUNCTION_CODE_SUPERVISOR_PROGRAM 6
#define FUNCTION_CODE_CPU_SPACE 7

/* CPU types for deciding what to emulate */
#define CPU_TYPE_000 (0x00000001)
#define CPU_TYPE_008 (0x00000002)
#define CPU_TYPE_010 (0x00000004)
#define CPU_TYPE_EC020 (0x00000008)
#define CPU_TYPE_020 (0x00000010)
#define CPU_TYPE_EC030 (0x00000020)
#define CPU_TYPE_030 (0x00000040)
#define CPU_TYPE_EC040 (0x00000080)
#define CPU_TYPE_LC040 (0x00000100)
#define CPU_TYPE_040 (0x00000200)
#define CPU_TYPE_SCC070 (0x00000400)

/* Different ways to stop the CPU */
#define STOP_LEVEL_STOP 1
#define STOP_LEVEL_HALT 2

/* Used for 68000 address error processing */
#define INSTRUCTION_YES 0
#define INSTRUCTION_NO 0x08
#define MODE_READ 0x10
#define MODE_WRITE 0

#define RUN_MODE_NORMAL 0
#define RUN_MODE_BERR_AERR_RESET_WSF 1 /* writing stack frame */
#define RUN_MODE_BERR_AERR_RESET 2     /* stack frame done */

#ifndef NULL
#define NULL ((void*)0)
#endif

/* ======================================================================== */
/* ================================ MACROS ================================ */
/* ======================================================================== */

/* ---------------------------- General Macros ---------------------------- */

/* Bit Isolation Macros */
#define BIT_0(A) ((A) & 0x00000001)
#define BIT_1(A) ((A) & 0x00000002)
#define BIT_2(A) ((A) & 0x00000004)
#define BIT_3(A) ((A) & 0x00000008)
#define BIT_4(A) ((A) & 0x00000010)
#define BIT_5(A) ((A) & 0x00000020)
#define BIT_6(A) ((A) & 0x00000040)
#define BIT_7(A) ((A) & 0x00000080)
#define BIT_8(A) ((A) & 0x00000100)
#define BIT_9(A) ((A) & 0x00000200)
#define BIT_A(A) ((A) & 0x00000400)
#define BIT_B(A) ((A) & 0x00000800)
#define BIT_C(A) ((A) & 0x00001000)
#define BIT_D(A) ((A) & 0x00002000)
#define BIT_E(A) ((A) & 0x00004000)
#define BIT_F(A) ((A) & 0x00008000)
#define BIT_10(A) ((A) & 0x00010000)
#define BIT_11(A) ((A) & 0x00020000)
#define BIT_12(A) ((A) & 0x00040000)
#define BIT_13(A) ((A) & 0x00080000)
#define BIT_14(A) ((A) & 0x00100000)
#define BIT_15(A) ((A) & 0x00200000)
#define BIT_16(A) ((A) & 0x00400000)
#define BIT_17(A) ((A) & 0x00800000)
#define BIT_18(A) ((A) & 0x01000000)
#define BIT_19(A) ((A) & 0x02000000)
#define BIT_1A(A) ((A) & 0x04000000)
#define BIT_1B(A) ((A) & 0x08000000)
#define BIT_1C(A) ((A) & 0x10000000)
#define BIT_1D(A) ((A) & 0x20000000)
#define BIT_1E(A) ((A) & 0x40000000)
#define BIT_1F(A) ((A) & 0x80000000)

/* Get the most significant bit for specific sizes */
#define GET_MSB_8(A) ((A) & 0x80)
#define GET_MSB_9(A) ((A) & 0x100)
#define GET_MSB_16(A) ((A) & 0x8000)
#define GET_MSB_17(A) ((A) & 0x10000)
#define GET_MSB_32(A) ((A) & 0x80000000)
#if M68K_USE_64_BIT
#define GET_MSB_33(A) ((A) & 0x100000000)
#endif /* M68K_USE_64_BIT */

/* Isolate nibbles */
#define LOW_NIBBLE(A) ((A) & 0x0f)
#define HIGH_NIBBLE(A) ((A) & 0xf0)

/* These are used to isolate 8, 16, and 32 bit sizes */
#define MASK_OUT_ABOVE_2(A) ((A) & 3)
#define MASK_OUT_ABOVE_8(A) ((A) & 0xff)
#define MASK_OUT_ABOVE_16(A) ((A) & 0xffff)
#define MASK_OUT_BELOW_2(A) ((A) & ~3)
#define MASK_OUT_BELOW_8(A) ((A) & ~0xff)
#define MASK_OUT_BELOW_16(A) ((A) & ~0xffff)

/* No need to mask if we are 32 bit */
#if M68K_INT_GT_32_BIT || M68K_USE_64_BIT
#define MASK_OUT_ABOVE_32(A) ((A) & 0xffffffff)
#define MASK_OUT_BELOW_32(A) ((A) & ~0xffffffff)
#else
#define MASK_OUT_ABOVE_32(A) (A)
#define MASK_OUT_BELOW_32(A) 0
#endif /* M68K_INT_GT_32_BIT || M68K_USE_64_BIT */

/* Simulate address lines of 68k family */
#define ADDRESS_68K(A) ((A) & CPU_ADDRESS_MASK)

/* Shift & Rotate Macros. */
#define LSL(A, C) ((A) << (C))
#define LSR(A, C) ((A) >> (C))

/* Some > 32-bit optimizations */
#if M68K_INT_GT_32_BIT
/* Shift left and right */
#define LSR_32(A, C) ((A) >> (C))
#define LSL_32(A, C) ((A) << (C))
#else
/* We have to do this because the morons at ANSI decided that shifts
 * by >= data size are undefined.
 */
#define LSR_32(A, C) ((C) < 32 ? (A) >> (C) : 0)
#define LSL_32(A, C) ((C) < 32 ? (A) << (C) : 0)
#endif /* M68K_INT_GT_32_BIT */

#if M68K_USE_64_BIT
#define LSL_32_64(A, C) ((A) << (C))
#define LSR_32_64(A, C) ((A) >> (C))
#define ROL_33_64(A, C) (LSL_32_64(A, C) | LSR_32_64(A, 33 - (C)))
#define ROR_33_64(A, C) (LSR_32_64(A, C) | LSL_32_64(A, 33 - (C)))
#endif /* M68K_USE_64_BIT */

#define ROL_8(A, C) MASK_OUT_ABOVE_8(LSL(A, C) | LSR(A, 8 - (C)))
#define ROL_9(A, C) (LSL(A, C) | LSR(A, 9 - (C)))
#define ROL_16(A, C) MASK_OUT_ABOVE_16(LSL(A, C) | LSR(A, 16 - (C)))
#define ROL_17(A, C) (LSL(A, C) | LSR(A, 17 - (C)))
#define ROL_32(A, C) MASK_OUT_ABOVE_32(LSL_32(A, C) | LSR_32(A, 32 - (C)))
#define ROL_33(A, C) (LSL_32(A, C) | LSR_32(A, 33 - (C)))

#define ROR_8(A, C) MASK_OUT_ABOVE_8(LSR(A, C) | LSL(A, 8 - (C)))
#define ROR_9(A, C) (LSR(A, C) | LSL(A, 9 - (C)))
#define ROR_16(A, C) MASK_OUT_ABOVE_16(LSR(A, C) | LSL(A, 16 - (C)))
#define ROR_17(A, C) (LSR(A, C) | LSL(A, 17 - (C)))
#define ROR_32(A, C) MASK_OUT_ABOVE_32(LSR_32(A, C) | LSL_32(A, 32 - (C)))
#define ROR_33(A, C) (LSR_32(A, C) | LSL_32(A, 33 - (C)))

/* ------------------------------ CPU Access ------------------------------ */

/* Access the CPU registers */
#define CPU_TYPE m68ki_cpu.cpu_type

#define REG_DA m68ki_cpu.dar /* easy access to data and address regs */
#define REG_DA_SAVE m68ki_cpu.dar_save
#define REG_D m68ki_cpu.dar
#define REG_A (m68ki_cpu.dar + 8)
#define REG_PPC m68ki_cpu.ppc
#define REG_PC m68ki_cpu.pc
#define REG_SP_BASE m68ki_cpu.sp
#define REG_USP m68ki_cpu.sp[0]
#define REG_ISP m68ki_cpu.sp[4]
#define REG_MSP m68ki_cpu.sp[6]
#define REG_SP m68ki_cpu.dar[15]
#define REG_VBR m68ki_cpu.vbr
#define REG_SFC m68ki_cpu.sfc
#define REG_DFC m68ki_cpu.dfc
#define REG_CACR m68ki_cpu.cacr
#define REG_CAAR m68ki_cpu.caar
#define REG_IR m68ki_cpu.ir

#define REG_FP m68ki_cpu.fpr
#define REG_FPCR m68ki_cpu.fpcr
#define REG_FPSR m68ki_cpu.fpsr
#define REG_FPIAR m68ki_cpu.fpiar

#define FLAG_T1 m68ki_cpu.t1_flag
#define FLAG_T0 m68ki_cpu.t0_flag
#define FLAG_S m68ki_cpu.s_flag
#define FLAG_M m68ki_cpu.m_flag
#define FLAG_X m68ki_cpu.x_flag
#define FLAG_N m68ki_cpu.n_flag
#define FLAG_Z m68ki_cpu.not_z_flag
#define FLAG_V m68ki_cpu.v_flag
#define FLAG_C m68ki_cpu.c_flag
#define FLAG_INT_MASK m68ki_cpu.int_mask

#define CPU_INT_LEVEL m68ki_cpu.int_level /* ASG: changed from CPU_INTS_PENDING */
#define CPU_STOPPED m68ki_cpu.stopped
#define CPU_PREF_ADDR m68ki_cpu.pref_addr
#define CPU_PREF_DATA m68ki_cpu.pref_data
#define CPU_ADDRESS_MASK m68ki_cpu.address_mask
#define CPU_SR_MASK m68ki_cpu.sr_mask
#define CPU_INSTR_MODE m68ki_cpu.instr_mode
#define CPU_RUN_MODE m68ki_cpu.run_mode

#define CYC_INSTRUCTION m68ki_cpu.cyc_instruction
#define CYC_EXCEPTION m68ki_cpu.cyc_exception
#define CYC_BCC_NOTAKE_B m68ki_cpu.cyc_bcc_notake_b
#define CYC_BCC_NOTAKE_W m68ki_cpu.cyc_bcc_notake_w
#define CYC_DBCC_F_NOEXP m68ki_cpu.cyc_dbcc_f_noexp
#define CYC_DBCC_F_EXP m68ki_cpu.cyc_dbcc_f_exp
#define CYC_SCC_R_TRUE m68ki_cpu.cyc_scc_r_true
#define CYC_MOVEM_W m68ki_cpu.cyc_movem_w
#define CYC_MOVEM_L m68ki_cpu.cyc_movem_l
#define CYC_SHIFT m68ki_cpu.cyc_shift
#define CYC_RESET m68ki_cpu.cyc_reset
#define HAS_PMMU m68ki_cpu.has_pmmu
#define PMMU_ENABLED m68ki_cpu.pmmu_enabled
#define RESET_CYCLES m68ki_cpu.reset_cycles

#define CALLBACK_INT_ACK m68ki_cpu.int_ack_callback
#define CALLBACK_BKPT_ACK m68ki_cpu.bkpt_ack_callback
#define CALLBACK_RESET_INSTR m68ki_cpu.reset_instr_callback
#define CALLBACK_CMPILD_INSTR m68ki_cpu.cmpild_instr_callback
#define CALLBACK_RTE_INSTR m68ki_cpu.rte_instr_callback
#define CALLBACK_TAS_INSTR m68ki_cpu.tas_instr_callback
#define CALLBACK_ILLG_INSTR m68ki_cpu.illg_instr_callback
#define CALLBACK_PC_CHANGED m68ki_cpu.pc_changed_callback
#define CALLBACK_SET_FC m68ki_cpu.set_fc_callback
#define CALLBACK_INSTR_HOOK m68ki_cpu.instr_hook_callback

/* ----------------------------- Configuration ---------------------------- */

/* These defines are dependant on the configuration defines in m68kconf.h */

/* Disable certain comparisons if we're not using all CPU types */
#if M68K_EMULATE_040
#define CPU_TYPE_IS_040_PLUS(A) ((A) & (CPU_TYPE_040 | CPU_TYPE_EC040))
#define CPU_TYPE_IS_040_LESS(A) 1
#else
#define CPU_TYPE_IS_040_PLUS(A) 0
#define CPU_TYPE_IS_040_LESS(A) 1
#endif

#if M68K_EMULATE_030
#define CPU_TYPE_IS_030_PLUS(A) ((A) & (CPU_TYPE_030 | CPU_TYPE_EC030 | CPU_TYPE_040 | CPU_TYPE_EC040))
#define CPU_TYPE_IS_030_LESS(A) 1
#else
#define CPU_TYPE_IS_030_PLUS(A) 0
#define CPU_TYPE_IS_030_LESS(A) 1
#endif

#if M68K_EMULATE_020
#define CPU_TYPE_IS_020_PLUS(A) ((A) & (CPU_TYPE_020 | CPU_TYPE_030 | CPU_TYPE_EC030 | CPU_TYPE_040 | CPU_TYPE_EC040))
#define CPU_TYPE_IS_020_LESS(A) 1
#else
#define CPU_TYPE_IS_020_PLUS(A) 0
#define CPU_TYPE_IS_020_LESS(A) 1
#endif

#if M68K_EMULATE_EC020
#define CPU_TYPE_IS_EC020_PLUS(A) ((A) & (CPU_TYPE_EC020 | CPU_TYPE_020 | CPU_TYPE_030 | CPU_TYPE_EC030 | CPU_TYPE_040 | CPU_TYPE_EC040))
#define CPU_TYPE_IS_EC020_LESS(A) ((A) & (CPU_TYPE_000 | CPU_TYPE_010 | CPU_TYPE_EC020))
#else
#define CPU_TYPE_IS_EC020_PLUS(A) CPU_TYPE_IS_020_PLUS(A)
#define CPU_TYPE_IS_EC020_LESS(A) CPU_TYPE_IS_020_LESS(A)
#endif

#if M68K_EMULATE_010
#define CPU_TYPE_IS_010(A) ((A) == CPU_TYPE_010)
#define CPU_TYPE_IS_010_PLUS(A) ((A) & (CPU_TYPE_010 | CPU_TYPE_EC020 | CPU_TYPE_020 | CPU_TYPE_EC030 | CPU_TYPE_030 | CPU_TYPE_040 | CPU_TYPE_EC040))
#define CPU_TYPE_IS_010_LESS(A) ((A) & (CPU_TYPE_000 | CPU_TYPE_008 | CPU_TYPE_010))
#else
#define CPU_TYPE_IS_010(A) 0
#define CPU_TYPE_IS_010_PLUS(A) CPU_TYPE_IS_EC020_PLUS(A)
#define CPU_TYPE_IS_010_LESS(A) CPU_TYPE_IS_EC020_LESS(A)
#endif

#if M68K_EMULATE_020 || M68K_EMULATE_EC020
#define CPU_TYPE_IS_020_VARIANT(A) ((A) & (CPU_TYPE_EC020 | CPU_TYPE_020))
#else
#define CPU_TYPE_IS_020_VARIANT(A) 0
#endif

#if M68K_EMULATE_040 || M68K_EMULATE_020 || M68K_EMULATE_EC020 || M68K_EMULATE_010
#define CPU_TYPE_IS_000(A) ((A) == CPU_TYPE_000)
#else
#define CPU_TYPE_IS_000(A) 1
#endif

#if !M68K_SEPARATE_READS
#define m68k_read_immediate_16(A) m68ki_read_program_16(A)
#define m68k_read_immediate_32(A) m68ki_read_program_32(A)

#define m68k_read_pcrelative_8(A) m68ki_read_program_8(A)
#define m68k_read_pcrelative_16(A) m68ki_read_program_16(A)
#define m68k_read_pcrelative_32(A) m68ki_read_program_32(A)
#endif /* M68K_SEPARATE_READS */

/* Enable or disable callback functions */
#if M68K_EMULATE_INT_ACK
#if M68K_EMULATE_INT_ACK == OPT_SPECIFY_HANDLER
#define m68ki_int_ack(A) M68K_INT_ACK_CALLBACK(A)
#else
#define m68ki_int_ack(A) CALLBACK_INT_ACK(A)
#endif
#else
/* Default action is to used autovector mode, which is most common */
#define m68ki_int_ack(A) M68K_INT_ACK_AUTOVECTOR
#endif /* M68K_EMULATE_INT_ACK */

#if M68K_EMULATE_BKPT_ACK
#if M68K_EMULATE_BKPT_ACK == OPT_SPECIFY_HANDLER
#define m68ki_bkpt_ack(A) M68K_BKPT_ACK_CALLBACK(A)
#else
#define m68ki_bkpt_ack(A) CALLBACK_BKPT_ACK(A)
#endif
#else
#define m68ki_bkpt_ack(A)
#endif /* M68K_EMULATE_BKPT_ACK */

#if M68K_EMULATE_RESET
#if M68K_EMULATE_RESET == OPT_SPECIFY_HANDLER
#define m68ki_output_reset() M68K_RESET_CALLBACK()
#else
#define m68ki_output_reset() CALLBACK_RESET_INSTR()
#endif
#else
#define m68ki_output_reset()
#endif /* M68K_EMULATE_RESET */

#if M68K_CMPILD_HAS_CALLBACK
#if M68K_CMPILD_HAS_CALLBACK == OPT_SPECIFY_HANDLER
#define m68ki_cmpild_callback(v, r) M68K_CMPILD_CALLBACK(v, r)
#else
#define m68ki_cmpild_callback(v, r) CALLBACK_CMPILD_INSTR(v, r)
#endif
#else
#define m68ki_cmpild_callback(v, r)
#endif /* M68K_CMPILD_HAS_CALLBACK */

#if M68K_RTE_HAS_CALLBACK
#if M68K_RTE_HAS_CALLBACK == OPT_SPECIFY_HANDLER
#define m68ki_rte_callback() M68K_RTE_CALLBACK()
#else
#define m68ki_rte_callback() CALLBACK_RTE_INSTR()
#endif
#else
#define m68ki_rte_callback()
#endif /* M68K_RTE_HAS_CALLBACK */

#if M68K_TAS_HAS_CALLBACK
#if M68K_TAS_HAS_CALLBACK == OPT_SPECIFY_HANDLER
#define m68ki_tas_callback() M68K_TAS_CALLBACK()
#else
#define m68ki_tas_callback() CALLBACK_TAS_INSTR()
#endif
#else
#define m68ki_tas_callback() 1
#endif /* M68K_TAS_HAS_CALLBACK */

#if M68K_ILLG_HAS_CALLBACK
#if M68K_ILLG_HAS_CALLBACK == OPT_SPECIFY_HANDLER
#define m68ki_illg_callback(opcode) M68K_ILLG_CALLBACK(opcode)
#else
#define m68ki_illg_callback(opcode) CALLBACK_ILLG_INSTR(opcode)
#endif
#else
#define m68ki_illg_callback(opcode) 0 // Default is 0 = not handled, exception will occur
#endif                                /* M68K_ILLG_HAS_CALLBACK */

#if M68K_INSTRUCTION_HOOK
#if M68K_INSTRUCTION_HOOK == OPT_SPECIFY_HANDLER
#define m68ki_instr_hook(pc) M68K_INSTRUCTION_CALLBACK(pc)
#else
#define m68ki_instr_hook(pc) CALLBACK_INSTR_HOOK(pc)
#endif
#else
#define m68ki_instr_hook(pc)
#endif /* M68K_INSTRUCTION_HOOK */

#if M68K_MONITOR_PC
#if M68K_MONITOR_PC == OPT_SPECIFY_HANDLER
#define m68ki_pc_changed(A) M68K_SET_PC_CALLBACK(ADDRESS_68K(A))
#else
#define m68ki_pc_changed(A) CALLBACK_PC_CHANGED(ADDRESS_68K(A))
#endif
#else
#define m68ki_pc_changed(A)
#endif /* M68K_MONITOR_PC */

/* Enable or disable function code emulation */
#if M68K_EMULATE_FC
#if M68K_EMULATE_FC == OPT_SPECIFY_HANDLER
#define m68ki_set_fc(A) M68K_SET_FC_CALLBACK(A)
#else
#define m68ki_set_fc(A) CALLBACK_SET_FC(A)
#endif
#define m68ki_use_data_space() m68ki_address_space = FUNCTION_CODE_USER_DATA
#define m68ki_use_program_space() m68ki_address_space = FUNCTION_CODE_USER_PROGRAM
#define m68ki_get_address_space() m68ki_address_space
#else
#define m68ki_set_fc(A)
#define m68ki_use_data_space()
#define m68ki_use_program_space()
#define m68ki_get_address_space() FUNCTION_CODE_USER_DATA
#endif /* M68K_EMULATE_FC */

/* Enable or disable trace emulation */
#if M68K_EMULATE_TRACE
/* Initiates trace checking before each instruction (t1) */
#define m68ki_trace_t1() m68ki_tracing = FLAG_T1
/* adds t0 to trace checking if we encounter change of flow */
#define m68ki_trace_t0() m68ki_tracing |= FLAG_T0
/* Clear all tracing */
#define m68ki_clear_trace() m68ki_tracing = 0
/* Cause a trace exception if we are tracing */
#define m68ki_exception_if_trace() \
    if (m68ki_tracing)             \
    m68ki_exception_trace()
#else
#define m68ki_trace_t1()
#define m68ki_trace_t0()
#define m68ki_clear_trace()
#define m68ki_exception_if_trace()
#endif /* M68K_EMULATE_TRACE */

/* Address error */
#if M68K_EMULATE_ADDRESS_ERROR
#include <setjmp.h>

/* sigjmp() on Mac OS X and *BSD in general saves signal contexts and is super-slow, use sigsetjmp() to tell it not to */
#ifdef _BSD_SETJMP_H
extern sigjmp_buf m68ki_aerr_trap;
#define m68ki_set_address_error_trap(m68k)    \
    if (sigsetjmp(m68ki_aerr_trap, 0) != 0) { \
        m68ki_exception_address_error(m68k);  \
        if (CPU_STOPPED) {                    \
            if (m68ki_remaining_cycles > 0)   \
                m68ki_remaining_cycles = 0;   \
            return m68ki_initial_cycles;      \
        }                                     \
    }

#define m68ki_check_address_error(ADDR, WRITE_MODE, FC) \
    if ((ADDR) & 1) {                                   \
        m68ki_aerr_address = ADDR;                      \
        m68ki_aerr_write_mode = WRITE_MODE;             \
        m68ki_aerr_fc = FC;                             \
        siglongjmp(m68ki_aerr_trap, 1);                 \
    }
#else
extern jmp_buf m68ki_aerr_trap;
#define m68ki_set_address_error_trap()                          \
    if (setjmp(m68ki_aerr_trap) != 0) {                         \
        m68ki_exception_address_error();                        \
        if (CPU_STOPPED) {                                      \
            SET_CYCLES(0);                                      \
            return m68ki_initial_cycles;                        \
        }                                                       \
        /* ensure we don't re-enter execution loop after an     \
           address error if there's no more cycles remaining */ \
        if (GET_CYCLES() <= 0) {                                \
            /* return how many clocks we used */                \
            return m68ki_initial_cycles - GET_CYCLES();         \
        }                                                       \
    }

#define m68ki_check_address_error(ADDR, WRITE_MODE, FC) \
    if ((ADDR) & 1) {                                   \
        m68ki_aerr_address = ADDR;                      \
        m68ki_aerr_write_mode = WRITE_MODE;             \
        m68ki_aerr_fc = FC;                             \
        longjmp(m68ki_aerr_trap, 1);                    \
    }
#endif

#define m68ki_check_address_error_010_less(ADDR, WRITE_MODE, FC) \
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {                        \
        m68ki_check_address_error(ADDR, WRITE_MODE, FC)          \
    }
#else
#define m68ki_set_address_error_trap()
#define m68ki_check_address_error(ADDR, WRITE_MODE, FC)
#define m68ki_check_address_error_010_less(ADDR, WRITE_MODE, FC)
#endif /* M68K_ADDRESS_ERROR */

/* Logging */
#if M68K_LOG_ENABLE
#include <stdio.h>
extern FILE* M68K_LOG_FILEHANDLE extern const char* const m68ki_cpu_names[];

#define M68K_DO_LOG(A)       \
    if (M68K_LOG_FILEHANDLE) \
    fprintf A
#if M68K_LOG_1010_1111
#define M68K_DO_LOG_EMU(A)   \
    if (M68K_LOG_FILEHANDLE) \
    fprintf A
#else
#define M68K_DO_LOG_EMU(A)
#endif
#else
#define M68K_DO_LOG(A)
#define M68K_DO_LOG_EMU(A)
#endif

/* -------------------------- EA / Operand Access ------------------------- */

/*
 * The general instruction format follows this pattern:
 * .... XXX. .... .YYY
 * where XXX is register X and YYY is register Y
 */
/* Data Register Isolation */
#define DX (REG_D[(REG_IR >> 9) & 7])
#define DY (REG_D[REG_IR & 7])
/* Address Register Isolation */
#define AX (REG_A[(REG_IR >> 9) & 7])
#define AY (REG_A[REG_IR & 7])

/* Effective Address Calculations */
#define EA_AY_AI_8() AY /* address register indirect */
#define EA_AY_AI_16() EA_AY_AI_8()
#define EA_AY_AI_32() EA_AY_AI_8()
#define EA_AY_PI_8() (AY++)                                  /* postincrement (size = byte) */
#define EA_AY_PI_16() ((AY += 2) - 2)                        /* postincrement (size = word) */
#define EA_AY_PI_32() ((AY += 4) - 4)                        /* postincrement (size = long) */
#define EA_AY_PD_8() (--AY)                                  /* predecrement (size = byte) */
#define EA_AY_PD_16() (AY -= 2)                              /* predecrement (size = word) */
#define EA_AY_PD_32() (AY -= 4)                              /* predecrement (size = long) */
#define EA_AY_DI_8() (AY + MAKE_INT_16(m68ki_read_imm_16())) /* displacement */
#define EA_AY_DI_16() EA_AY_DI_8()
#define EA_AY_DI_32() EA_AY_DI_8()
#define EA_AY_IX_8() m68ki_get_ea_ix(AY) /* indirect + index */
#define EA_AY_IX_16() EA_AY_IX_8()
#define EA_AY_IX_32() EA_AY_IX_8()

#define EA_AX_AI_8() AX
#define EA_AX_AI_16() EA_AX_AI_8()
#define EA_AX_AI_32() EA_AX_AI_8()
#define EA_AX_PI_8() (AX++)
#define EA_AX_PI_16() ((AX += 2) - 2)
#define EA_AX_PI_32() ((AX += 4) - 4)
#define EA_AX_PD_8() (--AX)
#define EA_AX_PD_16() (AX -= 2)
#define EA_AX_PD_32() (AX -= 4)
#define EA_AX_DI_8() (AX + MAKE_INT_16(m68ki_read_imm_16()))
#define EA_AX_DI_16() EA_AX_DI_8()
#define EA_AX_DI_32() EA_AX_DI_8()
#define EA_AX_IX_8() m68ki_get_ea_ix(AX)
#define EA_AX_IX_16() EA_AX_IX_8()
#define EA_AX_IX_32() EA_AX_IX_8()

#define EA_A7_PI_8() ((REG_A[7] += 2) - 2)
#define EA_A7_PD_8() (REG_A[7] -= 2)

#define EA_AW_8() MAKE_INT_16(m68ki_read_imm_16()) /* absolute word */
#define EA_AW_16() EA_AW_8()
#define EA_AW_32() EA_AW_8()
#define EA_AL_8() m68ki_read_imm_32() /* absolute long */
#define EA_AL_16() EA_AL_8()
#define EA_AL_32() EA_AL_8()
#define EA_PCDI_8() m68ki_get_ea_pcdi() /* pc indirect + displacement */
#define EA_PCDI_16() EA_PCDI_8()
#define EA_PCDI_32() EA_PCDI_8()
#define EA_PCIX_8() m68ki_get_ea_pcix() /* pc indirect + index */
#define EA_PCIX_16() EA_PCIX_8()
#define EA_PCIX_32() EA_PCIX_8()

#define OPER_I_8() m68ki_read_imm_8()
#define OPER_I_16() m68ki_read_imm_16()
#define OPER_I_32() m68ki_read_imm_32()

/* --------------------------- Status Register ---------------------------- */

/* Flag Calculation Macros */
#define CFLAG_8(A) (A)
#define CFLAG_16(A) ((A) >> 8)

#if M68K_INT_GT_32_BIT
#define CFLAG_ADD_32(S, D, R) ((R) >> 24)
#define CFLAG_SUB_32(S, D, R) ((R) >> 24)
#else
#define CFLAG_ADD_32(S, D, R) (((S & D) | (~R & (S | D))) >> 23)
#define CFLAG_SUB_32(S, D, R) (((S & R) | (~D & (S | R))) >> 23)
#endif /* M68K_INT_GT_32_BIT */

#define VFLAG_ADD_8(S, D, R) ((S ^ R) & (D ^ R))
#define VFLAG_ADD_16(S, D, R) (((S ^ R) & (D ^ R)) >> 8)
#define VFLAG_ADD_32(S, D, R) (((S ^ R) & (D ^ R)) >> 24)

#define VFLAG_SUB_8(S, D, R) ((S ^ D) & (R ^ D))
#define VFLAG_SUB_16(S, D, R) (((S ^ D) & (R ^ D)) >> 8)
#define VFLAG_SUB_32(S, D, R) (((S ^ D) & (R ^ D)) >> 24)

#define NFLAG_8(A) (A)
#define NFLAG_16(A) ((A) >> 8)
#define NFLAG_32(A) ((A) >> 24)
#define NFLAG_64(A) ((A) >> 56)

#define ZFLAG_8(A) MASK_OUT_ABOVE_8(A)
#define ZFLAG_16(A) MASK_OUT_ABOVE_16(A)
#define ZFLAG_32(A) MASK_OUT_ABOVE_32(A)

/* Flag values */
#define NFLAG_SET 0x80
#define NFLAG_CLEAR 0
#define CFLAG_SET 0x100
#define CFLAG_CLEAR 0
#define XFLAG_SET 0x100
#define XFLAG_CLEAR 0
#define VFLAG_SET 0x80
#define VFLAG_CLEAR 0
#define ZFLAG_SET 0
#define ZFLAG_CLEAR 0xffffffff

#define SFLAG_SET 4
#define SFLAG_CLEAR 0
#define MFLAG_SET 2
#define MFLAG_CLEAR 0

/* Turn flag values into 1 or 0 */
#define XFLAG_AS_1() ((FLAG_X >> 8) & 1)
#define NFLAG_AS_1() ((FLAG_N >> 7) & 1)
#define VFLAG_AS_1() ((FLAG_V >> 7) & 1)
#define ZFLAG_AS_1() (!FLAG_Z)
#define CFLAG_AS_1() ((FLAG_C >> 8) & 1)

/* Conditions */
#define COND_CS() (FLAG_C & 0x100)
#define COND_CC() (!COND_CS())
#define COND_VS() (FLAG_V & 0x80)
#define COND_VC() (!COND_VS())
#define COND_NE() FLAG_Z
#define COND_EQ() (!COND_NE())
#define COND_MI() (FLAG_N & 0x80)
#define COND_PL() (!COND_MI())
#define COND_LT() ((FLAG_N ^ FLAG_V) & 0x80)
#define COND_GE() (!COND_LT())
#define COND_HI() (COND_CC() && COND_NE())
#define COND_LS() (COND_CS() || COND_EQ())
#define COND_GT() (COND_GE() && COND_NE())
#define COND_LE() (COND_LT() || COND_EQ())

/* Reversed conditions */
#define COND_NOT_CS() COND_CC()
#define COND_NOT_CC() COND_CS()
#define COND_NOT_VS() COND_VC()
#define COND_NOT_VC() COND_VS()
#define COND_NOT_NE() COND_EQ()
#define COND_NOT_EQ() COND_NE()
#define COND_NOT_MI() COND_PL()
#define COND_NOT_PL() COND_MI()
#define COND_NOT_LT() COND_GE()
#define COND_NOT_GE() COND_LT()
#define COND_NOT_HI() COND_LS()
#define COND_NOT_LS() COND_HI()
#define COND_NOT_GT() COND_LE()
#define COND_NOT_LE() COND_GT()

/* Not real conditions, but here for convenience */
#define COND_XS() (FLAG_X & 0x100)
#define COND_XC() (!COND_XS)

/* Get the condition code register */
#define m68ki_get_ccr() ((COND_XS() >> 4) | \
                         (COND_MI() >> 4) | \
                         (COND_EQ() << 2) | \
                         (COND_VS() >> 6) | \
                         (COND_CS() >> 8))

/* Get the status register */
#define m68ki_get_sr() (FLAG_T1 |        \
                        FLAG_T0 |        \
                        (FLAG_S << 11) | \
                        (FLAG_M << 11) | \
                        FLAG_INT_MASK |  \
                        m68ki_get_ccr())

/* ---------------------------- Cycle Counting ---------------------------- */

#define ADD_CYCLES(A) m68ki_remaining_cycles += (A)
#define USE_CYCLES(A) m68ki_remaining_cycles -= (A)
#define SET_CYCLES(A) m68ki_remaining_cycles = A
#define GET_CYCLES() m68ki_remaining_cycles
#define USE_ALL_CYCLES() m68ki_remaining_cycles %= CYC_INSTRUCTION[REG_IR]

/* ----------------------------- Read / Write ----------------------------- */

/* Read from the current address space */
#define m68ki_read_8(A) m68ki_read_8_fc(A, FLAG_S | m68ki_get_address_space())
#define m68ki_read_16(A) m68ki_read_16_fc(A, FLAG_S | m68ki_get_address_space())
#define m68ki_read_32(A) m68ki_read_32_fc(A, FLAG_S | m68ki_get_address_space())

/* Write to the current data space */
#define m68ki_write_8(A, V) m68ki_write_8_fc(A, FLAG_S | FUNCTION_CODE_USER_DATA, V)
#define m68ki_write_16(A, V) m68ki_write_16_fc(A, FLAG_S | FUNCTION_CODE_USER_DATA, V)
#define m68ki_write_32(A, V) m68ki_write_32_fc(A, FLAG_S | FUNCTION_CODE_USER_DATA, V)

#if M68K_SIMULATE_PD_WRITES
#define m68ki_write_32_pd(A, V) m68ki_write_32_pd_fc(A, FLAG_S | FUNCTION_CODE_USER_DATA, V)
#else
#define m68ki_write_32_pd(A, V) m68ki_write_32_fc(A, FLAG_S | FUNCTION_CODE_USER_DATA, V)
#endif

/* Map PC-relative reads */
#define m68ki_read_pcrel_8(A) m68k_read_pcrelative_8(A)
#define m68ki_read_pcrel_16(A) m68k_read_pcrelative_16(A)
#define m68ki_read_pcrel_32(A) m68k_read_pcrelative_32(A)

/* Read from the program space */
#define m68ki_read_program_8(A) m68ki_read_8_fc(A, FLAG_S | FUNCTION_CODE_USER_PROGRAM)
#define m68ki_read_program_16(A) m68ki_read_16_fc(A, FLAG_S | FUNCTION_CODE_USER_PROGRAM)
#define m68ki_read_program_32(A) m68ki_read_32_fc(A, FLAG_S | FUNCTION_CODE_USER_PROGRAM)

/* Read from the data space */
#define m68ki_read_data_8(A) m68ki_read_8_fc(A, FLAG_S | FUNCTION_CODE_USER_DATA)
#define m68ki_read_data_16(A) m68ki_read_16_fc(A, FLAG_S | FUNCTION_CODE_USER_DATA)
#define m68ki_read_data_32(A) m68ki_read_32_fc(A, FLAG_S | FUNCTION_CODE_USER_DATA)

/* ======================================================================== */
/* =============================== PROTOTYPES ============================= */
/* ======================================================================== */

typedef union {
    uint64 i;
    double f;
} fp_reg;

typedef struct
{
    uint cpu_type;      /* CPU Type: 68000, 68008, 68010, 68EC020, 68020, 68EC030, 68030, 68EC040, or 68040 */
    uint dar[16];       /* Data and Address Registers */
    uint dar_save[16];  /* Saved Data and Address Registers (pushed onto the
                           stack when a bus error occurs)*/
    uint ppc;           /* Previous program counter */
    uint pc;            /* Program Counter */
    uint sp[7];         /* User, Interrupt, and Master Stack Pointers */
    uint vbr;           /* Vector Base Register (m68010+) */
    uint sfc;           /* Source Function Code Register (m68010+) */
    uint dfc;           /* Destination Function Code Register (m68010+) */
    uint cacr;          /* Cache Control Register (m68020, unemulated) */
    uint caar;          /* Cache Address Register (m68020, unemulated) */
    uint ir;            /* Instruction Register */
    floatx80 fpr[8];    /* FPU Data Register (m68030/040) */
    uint fpiar;         /* FPU Instruction Address Register (m68040) */
    uint fpsr;          /* FPU Status Register (m68040) */
    uint fpcr;          /* FPU Control Register (m68040) */
    uint t1_flag;       /* Trace 1 */
    uint t0_flag;       /* Trace 0 */
    uint s_flag;        /* Supervisor */
    uint m_flag;        /* Master/Interrupt state */
    uint x_flag;        /* Extend */
    uint n_flag;        /* Negative */
    uint not_z_flag;    /* Zero, inverted for speedups */
    uint v_flag;        /* Overflow */
    uint c_flag;        /* Carry */
    uint int_mask;      /* I0-I2 */
    uint int_level;     /* State of interrupt pins IPL0-IPL2 -- ASG: changed from ints_pending */
    uint stopped;       /* Stopped state */
    uint pref_addr;     /* Last prefetch address */
    uint pref_data;     /* Data in the prefetch queue */
    uint address_mask;  /* Available address pins */
    uint sr_mask;       /* Implemented status register bits */
    uint instr_mode;    /* Stores whether we are in instruction mode or group 0/1 exception mode */
    uint run_mode;      /* Stores whether we are processing a reset, bus error, address error, or something else */
    int has_pmmu;       /* Indicates if a PMMU available (yes on 030, 040, no on EC030) */
    int pmmu_enabled;   /* Indicates if the PMMU is enabled */
    int fpu_just_reset; /* Indicates the FPU was just reset */
    uint reset_cycles;

    /* Clocks required for instructions / exceptions */
    uint cyc_bcc_notake_b;
    uint cyc_bcc_notake_w;
    uint cyc_dbcc_f_noexp;
    uint cyc_dbcc_f_exp;
    uint cyc_scc_r_true;
    uint cyc_movem_w;
    uint cyc_movem_l;
    uint cyc_shift;
    uint cyc_reset;

    /* Virtual IRQ lines state */
    uint virq_state;
    uint nmi_pending;

    /* PMMU registers */
    uint mmu_crp_aptr, mmu_crp_limit;
    uint mmu_srp_aptr, mmu_srp_limit;
    uint mmu_tc;
    uint16 mmu_sr;

    const uint8* cyc_instruction;
    const uint8* cyc_exception;

    /* Callbacks to host */
    int (*int_ack_callback)(int int_line);            /* Interrupt Acknowledge */
    void (*bkpt_ack_callback)(unsigned int data);     /* Breakpoint Acknowledge */
    void (*reset_instr_callback)(void);               /* Called when a RESET instruction is encountered */
    void (*cmpild_instr_callback)(unsigned int, int); /* Called when a CMPI.L #v, Dn instruction is encountered */
    void (*rte_instr_callback)(void);                 /* Called when a RTE instruction is encountered */
    int (*tas_instr_callback)(void);                  /* Called when a TAS instruction is encountered, allows / disallows writeback */
    int (*illg_instr_callback)(int);                  /* Called when an illegal instruction is encountered, allows handling */
    void (*pc_changed_callback)(unsigned int new_pc); /* Called when the PC changes by a large amount */
    void (*set_fc_callback)(unsigned int new_fc);     /* Called when the CPU function code changes */
    void (*instr_hook_callback)(unsigned int pc);     /* Called every instruction cycle prior to execution */

} m68ki_cpu_core;

extern m68ki_cpu_core m68ki_cpu;
extern sint m68ki_remaining_cycles;
extern uint m68ki_tracing;
extern const uint8 m68ki_shift_8_table[];
extern const uint16 m68ki_shift_16_table[];
extern const uint m68ki_shift_32_table[];
extern const uint8 m68ki_exception_cycle_table[][256];
extern uint m68ki_address_space;
extern const uint8 m68ki_ea_idx_cycle_table[];

extern uint m68ki_aerr_address;
extern uint m68ki_aerr_write_mode;
extern uint m68ki_aerr_fc;

/* Forward declarations to keep some of the macros happy */
static inline uint m68ki_read_16_fc(uint address, uint fc);
static inline uint m68ki_read_32_fc(uint address, uint fc);
static inline uint m68ki_get_ea_ix(uint An);
M68K_FORCE_INLINE void m68ki_check_interrupts(void); /* ASG: check for interrupts */

/* quick disassembly (used for logging) */
char* m68ki_disassemble_quick(unsigned int pc, unsigned int cpu_type);

/* ======================================================================== */
/* =========================== UTILITY FUNCTIONS ========================== */
/* ======================================================================== */

/* ---------------------------- Read Immediate ---------------------------- */

extern uint pmmu_translate_addr(uint addr_in);

/* Handles all immediate reads, does address error check, function code setting,
 * and prefetching if they are enabled in m68kconf.h
 */
static inline uint m68ki_read_imm_16(void)
{
    m68ki_set_fc(FLAG_S | FUNCTION_CODE_USER_PROGRAM);                                 /* auto-disable (see m68kcpu.h) */
    m68ki_check_address_error(REG_PC, MODE_READ, FLAG_S | FUNCTION_CODE_USER_PROGRAM); /* auto-disable (see m68kcpu.h) */

#if M68K_SEPARATE_READS
#if M68K_EMULATE_PMMU
    if (PMMU_ENABLED) {
        address = pmmu_translate_addr(address);
    }
#endif
#endif

#if M68K_EMULATE_PREFETCH
    {
        uint result;
        if (REG_PC != CPU_PREF_ADDR) {
            CPU_PREF_ADDR = REG_PC;
            CPU_PREF_DATA = m68k_read_immediate_16(ADDRESS_68K(CPU_PREF_ADDR));
        }
        result = MASK_OUT_ABOVE_16(CPU_PREF_DATA);
        REG_PC += 2;
        CPU_PREF_ADDR = REG_PC;
        CPU_PREF_DATA = m68k_read_immediate_16(ADDRESS_68K(CPU_PREF_ADDR));
        return result;
    }
#else
    REG_PC += 2;
    return m68k_read_immediate_16(ADDRESS_68K(REG_PC - 2));
#endif /* M68K_EMULATE_PREFETCH */
}

static inline uint m68ki_read_imm_8(void)
{
    /* map read immediate 8 to read immediate 16 */
    return MASK_OUT_ABOVE_8(m68ki_read_imm_16());
}

static inline uint m68ki_read_imm_32(void)
{
#if M68K_SEPARATE_READS
#if M68K_EMULATE_PMMU
    if (PMMU_ENABLED) {
        address = pmmu_translate_addr(address);
    }
#endif
#endif

#if M68K_EMULATE_PREFETCH
    uint temp_val;

    m68ki_set_fc(FLAG_S | FUNCTION_CODE_USER_PROGRAM);                                 /* auto-disable (see m68kcpu.h) */
    m68ki_check_address_error(REG_PC, MODE_READ, FLAG_S | FUNCTION_CODE_USER_PROGRAM); /* auto-disable (see m68kcpu.h) */

    if (REG_PC != CPU_PREF_ADDR) {
        CPU_PREF_ADDR = REG_PC;
        CPU_PREF_DATA = m68k_read_immediate_16(ADDRESS_68K(CPU_PREF_ADDR));
    }
    temp_val = MASK_OUT_ABOVE_16(CPU_PREF_DATA);
    REG_PC += 2;
    CPU_PREF_ADDR = REG_PC;
    CPU_PREF_DATA = m68k_read_immediate_16(ADDRESS_68K(CPU_PREF_ADDR));

    temp_val = MASK_OUT_ABOVE_32((temp_val << 16) | MASK_OUT_ABOVE_16(CPU_PREF_DATA));
    REG_PC += 2;
    CPU_PREF_ADDR = REG_PC;
    CPU_PREF_DATA = m68k_read_immediate_16(ADDRESS_68K(CPU_PREF_ADDR));

    return temp_val;
#else
    m68ki_set_fc(FLAG_S | FUNCTION_CODE_USER_PROGRAM);                                 /* auto-disable (see m68kcpu.h) */
    m68ki_check_address_error(REG_PC, MODE_READ, FLAG_S | FUNCTION_CODE_USER_PROGRAM); /* auto-disable (see m68kcpu.h) */
    REG_PC += 4;
    return m68k_read_immediate_32(ADDRESS_68K(REG_PC - 4));
#endif /* M68K_EMULATE_PREFETCH */
}

/* ------------------------- Top level read/write ------------------------- */

/* Handles all memory accesses (except for immediate reads if they are
 * configured to use separate functions in m68kconf.h).
 * All memory accesses must go through these top level functions.
 * These functions will also check for address error and set the function
 * code if they are enabled in m68kconf.h.
 */
static inline uint m68ki_read_8_fc(uint address, uint fc)
{
    (void)fc;
    m68ki_set_fc(fc); /* auto-disable (see m68kcpu.h) */

#if M68K_EMULATE_PMMU
    if (PMMU_ENABLED) {
        address = pmmu_translate_addr(address);
    }
#endif

    return m68k_read_memory_8(ADDRESS_68K(address));
}
static inline uint m68ki_read_16_fc(uint address, uint fc)
{
    (void)fc;
    m68ki_set_fc(fc);                                           /* auto-disable (see m68kcpu.h) */
    m68ki_check_address_error_010_less(address, MODE_READ, fc); /* auto-disable (see m68kcpu.h) */

#if M68K_EMULATE_PMMU
    if (PMMU_ENABLED) {
        address = pmmu_translate_addr(address);
    }
#endif

    return m68k_read_memory_16(ADDRESS_68K(address));
}
static inline uint m68ki_read_32_fc(uint address, uint fc)
{
    (void)fc;
    m68ki_set_fc(fc);                                           /* auto-disable (see m68kcpu.h) */
    m68ki_check_address_error_010_less(address, MODE_READ, fc); /* auto-disable (see m68kcpu.h) */

#if M68K_EMULATE_PMMU
    if (PMMU_ENABLED) {
        address = pmmu_translate_addr(address);
    }
#endif

    return m68k_read_memory_32(ADDRESS_68K(address));
}

static inline void m68ki_write_8_fc(uint address, uint fc, uint value)
{
    (void)fc;
    m68ki_set_fc(fc); /* auto-disable (see m68kcpu.h) */

#if M68K_EMULATE_PMMU
    if (PMMU_ENABLED) {
        address = pmmu_translate_addr(address);
    }
#endif

    m68k_write_memory_8(ADDRESS_68K(address), value);
}
static inline void m68ki_write_16_fc(uint address, uint fc, uint value)
{
    (void)fc;
    m68ki_set_fc(fc);                                            /* auto-disable (see m68kcpu.h) */
    m68ki_check_address_error_010_less(address, MODE_WRITE, fc); /* auto-disable (see m68kcpu.h) */

#if M68K_EMULATE_PMMU
    if (PMMU_ENABLED) {
        address = pmmu_translate_addr(address);
    }
#endif

    m68k_write_memory_16(ADDRESS_68K(address), value);
}
static inline void m68ki_write_32_fc(uint address, uint fc, uint value)
{
    (void)fc;
    m68ki_set_fc(fc);                                            /* auto-disable (see m68kcpu.h) */
    m68ki_check_address_error_010_less(address, MODE_WRITE, fc); /* auto-disable (see m68kcpu.h) */

#if M68K_EMULATE_PMMU
    if (PMMU_ENABLED) {
        address = pmmu_translate_addr(address);
    }
#endif

    m68k_write_memory_32(ADDRESS_68K(address), value);
}

#if M68K_SIMULATE_PD_WRITES
static inline void m68ki_write_32_pd_fc(uint address, uint fc, uint value)
{
    (void)fc;
    m68ki_set_fc(fc);                                            /* auto-disable (see m68kcpu.h) */
    m68ki_check_address_error_010_less(address, MODE_WRITE, fc); /* auto-disable (see m68kcpu.h) */

#if M68K_EMULATE_PMMU
    if (PMMU_ENABLED) {
        address = pmmu_translate_addr(address);
    }
#endif

    m68k_write_memory_32_pd(ADDRESS_68K(address), value);
}
#endif

/* --------------------- Effective Address Calculation -------------------- */

/* The program counter relative addressing modes cause operands to be
 * retrieved from program space, not data space.
 */
static inline uint m68ki_get_ea_pcdi(void)
{
    uint old_pc = REG_PC;
    m68ki_use_program_space(); /* auto-disable */
    return old_pc + MAKE_INT_16(m68ki_read_imm_16());
}

static inline uint m68ki_get_ea_pcix(void)
{
    m68ki_use_program_space(); /* auto-disable */
    return m68ki_get_ea_ix(REG_PC);
}

/* Indexed addressing modes are encoded as follows:
 *
 * Base instruction format:
 * F E D C B A 9 8 7 6 | 5 4 3 | 2 1 0
 * x x x x x x x x x x | 1 1 0 | BASE REGISTER      (An)
 *
 * Base instruction format for destination EA in move instructions:
 * F E D C | B A 9    | 8 7 6 | 5 4 3 2 1 0
 * x x x x | BASE REG | 1 1 0 | X X X X X X       (An)
 *
 * Brief extension format:
 *  F  |  E D C   |  B  |  A 9  | 8 | 7 6 5 4 3 2 1 0
 * D/A | REGISTER | W/L | SCALE | 0 |  DISPLACEMENT
 *
 * Full extension format:
 *  F     E D C      B     A 9    8   7    6    5 4       3   2 1 0
 * D/A | REGISTER | W/L | SCALE | 1 | BS | IS | BD SIZE | 0 | I/IS
 * BASE DISPLACEMENT (0, 16, 32 bit)                (bd)
 * OUTER DISPLACEMENT (0, 16, 32 bit)               (od)
 *
 * D/A:     0 = Dn, 1 = An                          (Xn)
 * W/L:     0 = W (sign extend), 1 = L              (.SIZE)
 * SCALE:   00=1, 01=2, 10=4, 11=8                  (*SCALE)
 * BS:      0=add base reg, 1=suppress base reg     (An suppressed)
 * IS:      0=add index, 1=suppress index           (Xn suppressed)
 * BD SIZE: 00=reserved, 01=NULL, 10=Word, 11=Long  (size of bd)
 *
 * IS I/IS Operation
 * 0  000  No Memory Indirect
 * 0  001  indir prex with null outer
 * 0  010  indir prex with word outer
 * 0  011  indir prex with long outer
 * 0  100  reserved
 * 0  101  indir postx with null outer
 * 0  110  indir postx with word outer
 * 0  111  indir postx with long outer
 * 1  000  no memory indirect
 * 1  001  mem indir with null outer
 * 1  010  mem indir with word outer
 * 1  011  mem indir with long outer
 * 1  100-111  reserved
 */
static inline uint m68ki_get_ea_ix(uint An)
{
    /* An = base register */
    uint extension = m68ki_read_imm_16();
    uint Xn = 0; /* Index register */
    uint bd = 0; /* Base Displacement */
    uint od = 0; /* Outer Displacement */

    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        /* Calculate index */
        Xn = REG_DA[extension >> 12]; /* Xn */
        if (!BIT_B(extension))        /* W/L */
        {
            Xn = MAKE_INT_16(Xn);
        }

        /* Add base register and displacement and return */
        return An + Xn + MAKE_INT_8(extension);
    }

    /* Brief extension format */
    if (!BIT_8(extension)) {
        /* Calculate index */
        Xn = REG_DA[extension >> 12]; /* Xn */
        if (!BIT_B(extension))        /* W/L */
        {
            Xn = MAKE_INT_16(Xn);
        }
        /* Add scale if proper CPU type */
        if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
            Xn <<= (extension >> 9) & 3; /* SCALE */
        }

        /* Add base register and displacement and return */
        return An + Xn + MAKE_INT_8(extension);
    }

    /* Full extension format */

    USE_CYCLES(m68ki_ea_idx_cycle_table[extension & 0x3f]);

    /* Check if base register is present */
    if (BIT_7(extension)) { /* BS */
        An = 0;
    } /* An */

    /* Check if index is present */
    if (!BIT_6(extension)) /* IS */
    {
        Xn = REG_DA[extension >> 12]; /* Xn */
        if (!BIT_B(extension))        /* W/L */
        {
            Xn = MAKE_INT_16(Xn);
        }
        Xn <<= (extension >> 9) & 3; /* SCALE */
    }

    /* Check if base displacement is present */
    if (BIT_5(extension)) { /* BD SIZE */
        bd = BIT_4(extension) ? m68ki_read_imm_32() : (uint32)MAKE_INT_16(m68ki_read_imm_16());
    }

    /* If no indirect action, we are done */
    if (!(extension & 7)) { /* No Memory Indirect */
        return An + bd + Xn;
    }

    /* Check if outer displacement is present */
    if (BIT_1(extension)) { /* I/IS:  od */
        od = BIT_0(extension) ? m68ki_read_imm_32() : (uint32)MAKE_INT_16(m68ki_read_imm_16());
    }

    /* Postindex */
    if (BIT_2(extension)) { /* I/IS:  0 = preindex, 1 = postindex */
        return m68ki_read_32(An + bd) + Xn + od;
    }

    /* Preindex */
    return m68ki_read_32(An + bd + Xn) + od;
}

/* Fetch operands */
static inline uint OPER_AY_AI_8(void)
{
    uint ea = EA_AY_AI_8();
    return m68ki_read_8(ea);
}
static inline uint OPER_AY_AI_16(void)
{
    uint ea = EA_AY_AI_16();
    return m68ki_read_16(ea);
}
static inline uint OPER_AY_AI_32(void)
{
    uint ea = EA_AY_AI_32();
    return m68ki_read_32(ea);
}
static inline uint OPER_AY_PI_8(void)
{
    uint ea = EA_AY_PI_8();
    return m68ki_read_8(ea);
}
static inline uint OPER_AY_PI_16(void)
{
    uint ea = EA_AY_PI_16();
    return m68ki_read_16(ea);
}
static inline uint OPER_AY_PI_32(void)
{
    uint ea = EA_AY_PI_32();
    return m68ki_read_32(ea);
}
static inline uint OPER_AY_PD_8(void)
{
    uint ea = EA_AY_PD_8();
    return m68ki_read_8(ea);
}
static inline uint OPER_AY_PD_16(void)
{
    uint ea = EA_AY_PD_16();
    return m68ki_read_16(ea);
}
static inline uint OPER_AY_PD_32(void)
{
    uint ea = EA_AY_PD_32();
    return m68ki_read_32(ea);
}
static inline uint OPER_AY_DI_8(void)
{
    uint ea = EA_AY_DI_8();
    return m68ki_read_8(ea);
}
static inline uint OPER_AY_DI_16(void)
{
    uint ea = EA_AY_DI_16();
    return m68ki_read_16(ea);
}
static inline uint OPER_AY_DI_32(void)
{
    uint ea = EA_AY_DI_32();
    return m68ki_read_32(ea);
}
static inline uint OPER_AY_IX_8(void)
{
    uint ea = EA_AY_IX_8();
    return m68ki_read_8(ea);
}
static inline uint OPER_AY_IX_16(void)
{
    uint ea = EA_AY_IX_16();
    return m68ki_read_16(ea);
}
static inline uint OPER_AY_IX_32(void)
{
    uint ea = EA_AY_IX_32();
    return m68ki_read_32(ea);
}

static inline uint OPER_AX_AI_8(void)
{
    uint ea = EA_AX_AI_8();
    return m68ki_read_8(ea);
}
static inline uint OPER_AX_AI_16(void)
{
    uint ea = EA_AX_AI_16();
    return m68ki_read_16(ea);
}
static inline uint OPER_AX_AI_32(void)
{
    uint ea = EA_AX_AI_32();
    return m68ki_read_32(ea);
}
static inline uint OPER_AX_PI_8(void)
{
    uint ea = EA_AX_PI_8();
    return m68ki_read_8(ea);
}
static inline uint OPER_AX_PI_16(void)
{
    uint ea = EA_AX_PI_16();
    return m68ki_read_16(ea);
}
static inline uint OPER_AX_PI_32(void)
{
    uint ea = EA_AX_PI_32();
    return m68ki_read_32(ea);
}
static inline uint OPER_AX_PD_8(void)
{
    uint ea = EA_AX_PD_8();
    return m68ki_read_8(ea);
}
static inline uint OPER_AX_PD_16(void)
{
    uint ea = EA_AX_PD_16();
    return m68ki_read_16(ea);
}
static inline uint OPER_AX_PD_32(void)
{
    uint ea = EA_AX_PD_32();
    return m68ki_read_32(ea);
}
static inline uint OPER_AX_DI_8(void)
{
    uint ea = EA_AX_DI_8();
    return m68ki_read_8(ea);
}
static inline uint OPER_AX_DI_16(void)
{
    uint ea = EA_AX_DI_16();
    return m68ki_read_16(ea);
}
static inline uint OPER_AX_DI_32(void)
{
    uint ea = EA_AX_DI_32();
    return m68ki_read_32(ea);
}
static inline uint OPER_AX_IX_8(void)
{
    uint ea = EA_AX_IX_8();
    return m68ki_read_8(ea);
}
static inline uint OPER_AX_IX_16(void)
{
    uint ea = EA_AX_IX_16();
    return m68ki_read_16(ea);
}
static inline uint OPER_AX_IX_32(void)
{
    uint ea = EA_AX_IX_32();
    return m68ki_read_32(ea);
}

static inline uint OPER_A7_PI_8(void)
{
    uint ea = EA_A7_PI_8();
    return m68ki_read_8(ea);
}
static inline uint OPER_A7_PD_8(void)
{
    uint ea = EA_A7_PD_8();
    return m68ki_read_8(ea);
}

static inline uint OPER_AW_8(void)
{
    uint ea = EA_AW_8();
    return m68ki_read_8(ea);
}
static inline uint OPER_AW_16(void)
{
    uint ea = EA_AW_16();
    return m68ki_read_16(ea);
}
static inline uint OPER_AW_32(void)
{
    uint ea = EA_AW_32();
    return m68ki_read_32(ea);
}
static inline uint OPER_AL_8(void)
{
    uint ea = EA_AL_8();
    return m68ki_read_8(ea);
}
static inline uint OPER_AL_16(void)
{
    uint ea = EA_AL_16();
    return m68ki_read_16(ea);
}
static inline uint OPER_AL_32(void)
{
    uint ea = EA_AL_32();
    return m68ki_read_32(ea);
}
static inline uint OPER_PCDI_8(void)
{
    uint ea = EA_PCDI_8();
    return m68ki_read_pcrel_8(ea);
}
static inline uint OPER_PCDI_16(void)
{
    uint ea = EA_PCDI_16();
    return m68ki_read_pcrel_16(ea);
}
static inline uint OPER_PCDI_32(void)
{
    uint ea = EA_PCDI_32();
    return m68ki_read_pcrel_32(ea);
}
static inline uint OPER_PCIX_8(void)
{
    uint ea = EA_PCIX_8();
    return m68ki_read_pcrel_8(ea);
}
static inline uint OPER_PCIX_16(void)
{
    uint ea = EA_PCIX_16();
    return m68ki_read_pcrel_16(ea);
}
static inline uint OPER_PCIX_32(void)
{
    uint ea = EA_PCIX_32();
    return m68ki_read_pcrel_32(ea);
}

/* ---------------------------- Stack Functions --------------------------- */

/* Push/pull data from the stack */
static inline void m68ki_push_16(uint value)
{
    REG_SP = MASK_OUT_ABOVE_32(REG_SP - 2);
    m68ki_write_16(REG_SP, value);
}

static inline void m68ki_push_32(uint value)
{
    REG_SP = MASK_OUT_ABOVE_32(REG_SP - 4);
    m68ki_write_32(REG_SP, value);
}

static inline uint m68ki_pull_16(void)
{
    REG_SP = MASK_OUT_ABOVE_32(REG_SP + 2);
    return m68ki_read_16(REG_SP - 2);
}

static inline uint m68ki_pull_32(void)
{
    REG_SP = MASK_OUT_ABOVE_32(REG_SP + 4);
    return m68ki_read_32(REG_SP - 4);
}

/* Increment/decrement the stack as if doing a push/pull but
 * don't do any memory access.
 */
static inline void m68ki_fake_push_16(void)
{
    REG_SP = MASK_OUT_ABOVE_32(REG_SP - 2);
}

static inline void m68ki_fake_push_32(void)
{
    REG_SP = MASK_OUT_ABOVE_32(REG_SP - 4);
}

static inline void m68ki_fake_pull_16(void)
{
    REG_SP = MASK_OUT_ABOVE_32(REG_SP + 2);
}

static inline void m68ki_fake_pull_32(void)
{
    REG_SP = MASK_OUT_ABOVE_32(REG_SP + 4);
}

/* ----------------------------- Program Flow ----------------------------- */

/* Jump to a new program location or vector.
 * These functions will also call the pc_changed callback if it was enabled
 * in m68kconf.h.
 */
static inline void m68ki_jump(uint new_pc)
{
    REG_PC = new_pc;
    m68ki_pc_changed(REG_PC);
}

static inline void m68ki_jump_vector(uint vector)
{
    REG_PC = (vector << 2) + REG_VBR;
    REG_PC = m68ki_read_data_32(REG_PC);
    m68ki_pc_changed(REG_PC);
}

/* Branch to a new memory location.
 * The 32-bit branch will call pc_changed if it was enabled in m68kconf.h.
 * So far I've found no problems with not calling pc_changed for 8 or 16
 * bit branches.
 */
static inline void m68ki_branch_8(uint offset)
{
    REG_PC += MAKE_INT_8(offset);
}

static inline void m68ki_branch_16(uint offset)
{
    REG_PC += MAKE_INT_16(offset);
}

static inline void m68ki_branch_32(uint offset)
{
    REG_PC += offset;
    m68ki_pc_changed(REG_PC);
}

/* ---------------------------- Status Register --------------------------- */

/* Set the S flag and change the active stack pointer.
 * Note that value MUST be 4 or 0.
 */
static inline void m68ki_set_s_flag(uint value)
{
    /* Backup the old stack pointer */
    REG_SP_BASE[FLAG_S | ((FLAG_S >> 1) & FLAG_M)] = REG_SP;
    /* Set the S flag */
    FLAG_S = value;
    /* Set the new stack pointer */
    REG_SP = REG_SP_BASE[FLAG_S | ((FLAG_S >> 1) & FLAG_M)];
}

/* Set the S and M flags and change the active stack pointer.
 * Note that value MUST be 0, 2, 4, or 6 (bit2 = S, bit1 = M).
 */
static inline void m68ki_set_sm_flag(uint value)
{
    /* Backup the old stack pointer */
    REG_SP_BASE[FLAG_S | ((FLAG_S >> 1) & FLAG_M)] = REG_SP;
    /* Set the S and M flags */
    FLAG_S = value & SFLAG_SET;
    FLAG_M = value & MFLAG_SET;
    /* Set the new stack pointer */
    REG_SP = REG_SP_BASE[FLAG_S | ((FLAG_S >> 1) & FLAG_M)];
}

/* Set the S and M flags.  Don't touch the stack pointer. */
static inline void m68ki_set_sm_flag_nosp(uint value)
{
    /* Set the S and M flags */
    FLAG_S = value & SFLAG_SET;
    FLAG_M = value & MFLAG_SET;
}

/* Set the condition code register */
static inline void m68ki_set_ccr(uint value)
{
    FLAG_X = BIT_4(value) << 4;
    FLAG_N = BIT_3(value) << 4;
    FLAG_Z = !BIT_2(value);
    FLAG_V = BIT_1(value) << 6;
    FLAG_C = BIT_0(value) << 8;
}

/* Set the status register but don't check for interrupts */
static inline void m68ki_set_sr_noint(uint value)
{
    /* Mask out the "unimplemented" bits */
    value &= CPU_SR_MASK;

    /* Now set the status register */
    FLAG_T1 = BIT_F(value);
    FLAG_T0 = BIT_E(value);
    FLAG_INT_MASK = value & 0x0700;
    m68ki_set_ccr(value);
    m68ki_set_sm_flag((value >> 11) & 6);
}

/* Set the status register but don't check for interrupts nor
 * change the stack pointer
 */
static inline void m68ki_set_sr_noint_nosp(uint value)
{
    /* Mask out the "unimplemented" bits */
    value &= CPU_SR_MASK;

    /* Now set the status register */
    FLAG_T1 = BIT_F(value);
    FLAG_T0 = BIT_E(value);
    FLAG_INT_MASK = value & 0x0700;
    m68ki_set_ccr(value);
    m68ki_set_sm_flag_nosp((value >> 11) & 6);
}

/* Set the status register and check for interrupts */
static inline void m68ki_set_sr(uint value)
{
    m68ki_set_sr_noint(value);
    m68ki_check_interrupts();
}

/* ------------------------- Exception Processing ------------------------- */

/* Initiate exception processing */
static inline uint m68ki_init_exception(void)
{
    /* Save the old status register */
    uint sr = m68ki_get_sr();

    /* Turn off trace flag, clear pending traces */
    FLAG_T1 = FLAG_T0 = 0;
    m68ki_clear_trace();
    /* Enter supervisor mode */
    m68ki_set_s_flag(SFLAG_SET);

    return sr;
}

/* 3 word stack frame (68000 only) */
static inline void m68ki_stack_frame_3word(uint pc, uint sr)
{
    m68ki_push_32(pc);
    m68ki_push_16(sr);
}

/* Format 0 stack frame.
 * This is the standard stack frame for 68010+.
 */
static inline void m68ki_stack_frame_0000(uint pc, uint sr, uint vector)
{
    /* Stack a 3-word frame if we are 68000 */
    if (CPU_TYPE == CPU_TYPE_000) {
        m68ki_stack_frame_3word(pc, sr);
        return;
    }
    m68ki_push_16(vector << 2);
    m68ki_push_32(pc);
    m68ki_push_16(sr);
}

/* Format 1 stack frame (68020).
 * For 68020, this is the 4 word throwaway frame.
 */
static inline void m68ki_stack_frame_0001(uint pc, uint sr, uint vector)
{
    m68ki_push_16(0x1000 | (vector << 2));
    m68ki_push_32(pc);
    m68ki_push_16(sr);
}

/* Format 2 stack frame.
 * This is used only by 68020 for trap exceptions.
 */
static inline void m68ki_stack_frame_0010(uint sr, uint vector)
{
    m68ki_push_32(REG_PPC);
    m68ki_push_16(0x2000 | (vector << 2));
    m68ki_push_32(REG_PC);
    m68ki_push_16(sr);
}

/* Bus error stack frame (68000 only).
 */
static inline void m68ki_stack_frame_buserr(uint sr)
{
    m68ki_push_32(REG_PC);
    m68ki_push_16(sr);
    m68ki_push_16(REG_IR);
    m68ki_push_32(m68ki_aerr_address); /* access address */
    /* 0 0 0 0 0 0 0 0 0 0 0 R/W I/N FC
     * R/W  0 = write, 1 = read
     * I/N  0 = instruction, 1 = not
     * FC   3-bit function code
     */
    m68ki_push_16(m68ki_aerr_write_mode | CPU_INSTR_MODE | m68ki_aerr_fc);
}

/* Format 8 stack frame (68010).
 * 68010 only.  This is the 29 word bus/address error frame.
 */
static inline void m68ki_stack_frame_1000(uint pc, uint sr, uint vector)
{
    /* VERSION
     * NUMBER
     * INTERNAL INFORMATION, 16 WORDS
     */
    m68ki_fake_push_32();
    m68ki_fake_push_32();
    m68ki_fake_push_32();
    m68ki_fake_push_32();
    m68ki_fake_push_32();
    m68ki_fake_push_32();
    m68ki_fake_push_32();
    m68ki_fake_push_32();

    /* INSTRUCTION INPUT BUFFER */
    m68ki_push_16(0);

    /* UNUSED, RESERVED (not written) */
    m68ki_fake_push_16();

    /* DATA INPUT BUFFER */
    m68ki_push_16(0);

    /* UNUSED, RESERVED (not written) */
    m68ki_fake_push_16();

    /* DATA OUTPUT BUFFER */
    m68ki_push_16(0);

    /* UNUSED, RESERVED (not written) */
    m68ki_fake_push_16();

    /* FAULT ADDRESS */
    m68ki_push_32(0);

    /* SPECIAL STATUS WORD */
    m68ki_push_16(0);

    /* 1000, VECTOR OFFSET */
    m68ki_push_16(0x8000 | (vector << 2));

    /* PROGRAM COUNTER */
    m68ki_push_32(pc);

    /* STATUS REGISTER */
    m68ki_push_16(sr);
}

/* Format A stack frame (short bus fault).
 * This is used only by 68020 for bus fault and address error
 * if the error happens at an instruction boundary.
 * PC stacked is address of next instruction.
 */
static inline void m68ki_stack_frame_1010(uint sr, uint vector, uint pc)
{
    /* INTERNAL REGISTER */
    m68ki_push_16(0);

    /* INTERNAL REGISTER */
    m68ki_push_16(0);

    /* DATA OUTPUT BUFFER (2 words) */
    m68ki_push_32(0);

    /* INTERNAL REGISTER */
    m68ki_push_16(0);

    /* INTERNAL REGISTER */
    m68ki_push_16(0);

    /* DATA CYCLE FAULT ADDRESS (2 words) */
    m68ki_push_32(0);

    /* INSTRUCTION PIPE STAGE B */
    m68ki_push_16(0);

    /* INSTRUCTION PIPE STAGE C */
    m68ki_push_16(0);

    /* SPECIAL STATUS REGISTER */
    m68ki_push_16(0);

    /* INTERNAL REGISTER */
    m68ki_push_16(0);

    /* 1010, VECTOR OFFSET */
    m68ki_push_16(0xa000 | (vector << 2));

    /* PROGRAM COUNTER */
    m68ki_push_32(pc);

    /* STATUS REGISTER */
    m68ki_push_16(sr);
}

/* Format B stack frame (long bus fault).
 * This is used only by 68020 for bus fault and address error
 * if the error happens during instruction execution.
 * PC stacked is address of instruction in progress.
 */
static inline void m68ki_stack_frame_1011(uint sr, uint vector, uint pc)
{
    /* INTERNAL REGISTERS (18 words) */
    m68ki_push_32(0);
    m68ki_push_32(0);
    m68ki_push_32(0);
    m68ki_push_32(0);
    m68ki_push_32(0);
    m68ki_push_32(0);
    m68ki_push_32(0);
    m68ki_push_32(0);
    m68ki_push_32(0);

    /* VERSION# (4 bits), INTERNAL INFORMATION */
    m68ki_push_16(0);

    /* INTERNAL REGISTERS (3 words) */
    m68ki_push_32(0);
    m68ki_push_16(0);

    /* DATA INTPUT BUFFER (2 words) */
    m68ki_push_32(0);

    /* INTERNAL REGISTERS (2 words) */
    m68ki_push_32(0);

    /* STAGE B ADDRESS (2 words) */
    m68ki_push_32(0);

    /* INTERNAL REGISTER (4 words) */
    m68ki_push_32(0);
    m68ki_push_32(0);

    /* DATA OUTPUT BUFFER (2 words) */
    m68ki_push_32(0);

    /* INTERNAL REGISTER */
    m68ki_push_16(0);

    /* INTERNAL REGISTER */
    m68ki_push_16(0);

    /* DATA CYCLE FAULT ADDRESS (2 words) */
    m68ki_push_32(0);

    /* INSTRUCTION PIPE STAGE B */
    m68ki_push_16(0);

    /* INSTRUCTION PIPE STAGE C */
    m68ki_push_16(0);

    /* SPECIAL STATUS REGISTER */
    m68ki_push_16(0);

    /* INTERNAL REGISTER */
    m68ki_push_16(0);

    /* 1011, VECTOR OFFSET */
    m68ki_push_16(0xb000 | (vector << 2));

    /* PROGRAM COUNTER */
    m68ki_push_32(pc);

    /* STATUS REGISTER */
    m68ki_push_16(sr);
}

/* Used for Group 2 exceptions.
 * These stack a type 2 frame on the 020.
 */
static inline void m68ki_exception_trap(uint vector)
{
    uint sr = m68ki_init_exception();

    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        m68ki_stack_frame_0000(REG_PC, sr, vector);
    } else {
        m68ki_stack_frame_0010(sr, vector);
    }

    m68ki_jump_vector(vector);

    /* Use up some clock cycles and undo the instruction's cycles */
    USE_CYCLES(CYC_EXCEPTION[vector] - CYC_INSTRUCTION[REG_IR]);
}

/* Trap#n stacks a 0 frame but behaves like group2 otherwise */
static inline void m68ki_exception_trapN(uint vector)
{
    uint sr = m68ki_init_exception();
    m68ki_stack_frame_0000(REG_PC, sr, vector);
    m68ki_jump_vector(vector);

    /* Use up some clock cycles and undo the instruction's cycles */
    USE_CYCLES(CYC_EXCEPTION[vector] - CYC_INSTRUCTION[REG_IR]);
}

/* Exception for trace mode */
static inline void m68ki_exception_trace(void)
{
    uint sr = m68ki_init_exception();

    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
#if M68K_EMULATE_ADDRESS_ERROR == OPT_ON
        if (CPU_TYPE_IS_000(CPU_TYPE)) {
            CPU_INSTR_MODE = INSTRUCTION_NO;
        }
#endif /* M68K_EMULATE_ADDRESS_ERROR */
        m68ki_stack_frame_0000(REG_PC, sr, EXCEPTION_TRACE);
    } else {
        m68ki_stack_frame_0010(sr, EXCEPTION_TRACE);
    }

    m68ki_jump_vector(EXCEPTION_TRACE);

    /* Trace nullifies a STOP instruction */
    CPU_STOPPED &= ~STOP_LEVEL_STOP;

    /* Use up some clock cycles */
    USE_CYCLES(CYC_EXCEPTION[EXCEPTION_TRACE]);
}

/* Exception for privilege violation */
static inline void m68ki_exception_privilege_violation(void)
{
    uint sr = m68ki_init_exception();

#if M68K_EMULATE_ADDRESS_ERROR == OPT_ON
    if (CPU_TYPE_IS_000(CPU_TYPE)) {
        CPU_INSTR_MODE = INSTRUCTION_NO;
    }
#endif /* M68K_EMULATE_ADDRESS_ERROR */

    m68ki_stack_frame_0000(REG_PPC, sr, EXCEPTION_PRIVILEGE_VIOLATION);
    m68ki_jump_vector(EXCEPTION_PRIVILEGE_VIOLATION);

    /* Use up some clock cycles and undo the instruction's cycles */
    USE_CYCLES(CYC_EXCEPTION[EXCEPTION_PRIVILEGE_VIOLATION] - CYC_INSTRUCTION[REG_IR]);
}

extern jmp_buf m68ki_bus_error_jmp_buf;

#define m68ki_check_bus_error_trap() setjmp(m68ki_bus_error_jmp_buf)

/* Exception for bus error */
static inline void m68ki_exception_bus_error(void)
{
    int i;

    /* If we were processing a bus error, address error, or reset,
     * while writing the stack frame, this is a catastrophic failure.
     * Halt the CPU
     */
    if (CPU_RUN_MODE == RUN_MODE_BERR_AERR_RESET_WSF) {
        m68k_read_memory_8(0x00ffff01);
        CPU_STOPPED = STOP_LEVEL_HALT;
        return;
    }
    CPU_RUN_MODE = RUN_MODE_BERR_AERR_RESET_WSF;

    /* Use up some clock cycles and undo the instruction's cycles */
    USE_CYCLES(CYC_EXCEPTION[EXCEPTION_BUS_ERROR] - CYC_INSTRUCTION[REG_IR]);

    for (i = 15; i >= 0; i--) {
        REG_DA[i] = REG_DA_SAVE[i];
    }

    uint sr = m68ki_init_exception();

    /* Note: This is implemented for 68010 only! */
    m68ki_stack_frame_1000(REG_PPC, sr, EXCEPTION_BUS_ERROR);

    m68ki_jump_vector(EXCEPTION_BUS_ERROR);

    CPU_RUN_MODE = RUN_MODE_BERR_AERR_RESET;

    longjmp(m68ki_bus_error_jmp_buf, 1);
}

extern int cpu_log_enabled;

/* Exception for A-Line instructions */
static inline void m68ki_exception_1010(void)
{
    uint sr;
#if M68K_LOG_1010_1111 == OPT_ON
    M68K_DO_LOG_EMU((M68K_LOG_FILEHANDLE "%s at %08x: called 1010 instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PPC), REG_IR,
                     m68ki_disassemble_quick(ADDRESS_68K(REG_PPC))));
#endif

    sr = m68ki_init_exception();
    m68ki_stack_frame_0000(REG_PPC, sr, EXCEPTION_1010);
    m68ki_jump_vector(EXCEPTION_1010);

    /* Use up some clock cycles and undo the instruction's cycles */
    USE_CYCLES(CYC_EXCEPTION[EXCEPTION_1010] - CYC_INSTRUCTION[REG_IR]);
}

/* Exception for F-Line instructions */
static inline void m68ki_exception_1111(void)
{
    uint sr;

#if M68K_LOG_1010_1111 == OPT_ON
    M68K_DO_LOG_EMU((M68K_LOG_FILEHANDLE "%s at %08x: called 1111 instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PPC), REG_IR,
                     m68ki_disassemble_quick(ADDRESS_68K(REG_PPC))));
#endif

    sr = m68ki_init_exception();
    m68ki_stack_frame_0000(REG_PPC, sr, EXCEPTION_1111);
    m68ki_jump_vector(EXCEPTION_1111);

    /* Use up some clock cycles and undo the instruction's cycles */
    USE_CYCLES(CYC_EXCEPTION[EXCEPTION_1111] - CYC_INSTRUCTION[REG_IR]);
}

#if M68K_ILLG_HAS_CALLBACK == OPT_SPECIFY_HANDLER
extern int m68ki_illg_callback(int);
#endif

/* Exception for illegal instructions */
static inline void m68ki_exception_illegal(void)
{
    uint sr;

    M68K_DO_LOG((M68K_LOG_FILEHANDLE "%s at %08x: illegal instruction %04x (%s)\n",
                 m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PPC), REG_IR,
                 m68ki_disassemble_quick(ADDRESS_68K(REG_PPC))));
    if (m68ki_illg_callback(REG_IR)) {
        return;
    }

    sr = m68ki_init_exception();

#if M68K_EMULATE_ADDRESS_ERROR == OPT_ON
    if (CPU_TYPE_IS_000(CPU_TYPE)) {
        CPU_INSTR_MODE = INSTRUCTION_NO;
    }
#endif /* M68K_EMULATE_ADDRESS_ERROR */

    m68ki_stack_frame_0000(REG_PPC, sr, EXCEPTION_ILLEGAL_INSTRUCTION);
    m68ki_jump_vector(EXCEPTION_ILLEGAL_INSTRUCTION);

    /* Use up some clock cycles and undo the instruction's cycles */
    USE_CYCLES(CYC_EXCEPTION[EXCEPTION_ILLEGAL_INSTRUCTION] - CYC_INSTRUCTION[REG_IR]);
}

/* Exception for format errror in RTE */
static inline void m68ki_exception_format_error(void)
{
    uint sr = m68ki_init_exception();
    m68ki_stack_frame_0000(REG_PC, sr, EXCEPTION_FORMAT_ERROR);
    m68ki_jump_vector(EXCEPTION_FORMAT_ERROR);

    /* Use up some clock cycles and undo the instruction's cycles */
    USE_CYCLES(CYC_EXCEPTION[EXCEPTION_FORMAT_ERROR] - CYC_INSTRUCTION[REG_IR]);
}

/* Exception for address error */
static inline void m68ki_exception_address_error(void)
{
    uint sr = m68ki_init_exception();

    /* If we were processing a bus error, address error, or reset,
     * while writing the stack frame, this is a catastrophic failure.
     * Halt the CPU
     */
    if (CPU_RUN_MODE == RUN_MODE_BERR_AERR_RESET_WSF) {
        m68k_read_memory_8(0x00ffff01);
        CPU_STOPPED = STOP_LEVEL_HALT;
        return;
    }
    CPU_RUN_MODE = RUN_MODE_BERR_AERR_RESET_WSF;

    /* Note: This is implemented for 68000 only! */
    m68ki_stack_frame_buserr(sr);

    m68ki_jump_vector(EXCEPTION_ADDRESS_ERROR);

    CPU_RUN_MODE = RUN_MODE_BERR_AERR_RESET;

    /* Use up some clock cycles. Note that we don't need to undo the
    instruction's cycles here as we've longjmp:ed directly from the
    instruction handler without passing the part of the excecute loop
    that deducts instruction cycles */
    USE_CYCLES(CYC_EXCEPTION[EXCEPTION_ADDRESS_ERROR]);
}

/* Service an interrupt request and start exception processing */
M68K_FORCE_INLINE void m68ki_exception_interrupt(uint int_level)
{
    uint vector;
    uint sr;
    uint new_pc;

#if M68K_EMULATE_ADDRESS_ERROR == OPT_ON
    if (CPU_TYPE_IS_000(CPU_TYPE)) {
        CPU_INSTR_MODE = INSTRUCTION_NO;
    }
#endif /* M68K_EMULATE_ADDRESS_ERROR */

    /* Turn off the stopped state */
    CPU_STOPPED &= ~STOP_LEVEL_STOP;

    /* If we are halted, don't do anything */
    if (CPU_STOPPED) {
        return;
    }

    /* Acknowledge the interrupt */
    vector = m68ki_int_ack(int_level);

    /* Get the interrupt vector */
    if (vector == M68K_INT_ACK_AUTOVECTOR) {
        /* Use the autovectors.  This is the most commonly used implementation */
        vector = EXCEPTION_INTERRUPT_AUTOVECTOR + int_level;
    } else if (vector == M68K_INT_ACK_SPURIOUS) {
        /* Called if no devices respond to the interrupt acknowledge */
        vector = EXCEPTION_SPURIOUS_INTERRUPT;
    } else if (vector > 255) {
        M68K_DO_LOG_EMU((M68K_LOG_FILEHANDLE "%s at %08x: Interrupt acknowledge returned invalid vector $%x\n",
                         m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PC), vector));
        return;
    }

    /* Start exception processing */
    sr = m68ki_init_exception();

    /* Set the interrupt mask to the level of the one being serviced */
    FLAG_INT_MASK = int_level << 8;

    /* Get the new PC */
    new_pc = m68ki_read_data_32((vector << 2) + REG_VBR);

    /* If vector is uninitialized, call the uninitialized interrupt vector */
    if (new_pc == 0) {
        new_pc = m68ki_read_data_32((EXCEPTION_UNINITIALIZED_INTERRUPT << 2) + REG_VBR);
    }

    /* Generate a stack frame */
    m68ki_stack_frame_0000(REG_PC, sr, vector);
    if (FLAG_M && CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        /* Create throwaway frame */
        m68ki_set_sm_flag(FLAG_S); /* clear M */
        sr |= 0x2000;              /* Same as SR in master stack frame except S is forced high */
        m68ki_stack_frame_0001(REG_PC, sr, vector);
    }

    m68ki_jump(new_pc);

    /* Defer cycle counting until later */
    USE_CYCLES(CYC_EXCEPTION[vector]);

#if !M68K_EMULATE_INT_ACK
    /* Automatically clear IRQ if we are not using an acknowledge scheme */
    CPU_INT_LEVEL = 0;
#endif /* M68K_EMULATE_INT_ACK */
}

/* ASG: Check for interrupts */
M68K_FORCE_INLINE void m68ki_check_interrupts(void)
{
    if (m68ki_cpu.nmi_pending) {
        m68ki_cpu.nmi_pending = FALSE;
        m68ki_exception_interrupt(7);
    } else if (CPU_INT_LEVEL > FLAG_INT_MASK) {
        m68ki_exception_interrupt(CPU_INT_LEVEL >> 8);
    }
}

/* ======================================================================== */
/* ============================== END OF FILE ============================= */
/* ======================================================================== */

#ifdef __cplusplus
}
#endif

#endif /* M68KCPU__HEADER */

#ifdef MUSASHI_IMPLEMENTATION

/* ------------------------ Implementation Section --------------------- */

/* -- Begin embedded musashi/m68kops.h -- */
#ifndef M68KOPS__HEADER
#define M68KOPS__HEADER

/* ======================================================================== */
/* ============================ OPCODE HANDLERS =========================== */
/* ======================================================================== */

/* Build the opcode handler table */
void m68ki_build_opcode_table(void);

extern void (*m68ki_instruction_jump_table[0x10000])(void); /* opcode handler jump table */
extern unsigned char m68ki_cycles[][0x10000];

/* ======================================================================== */
/* ============================== END OF FILE ============================= */
/* ======================================================================== */

#endif /* M68KOPS__HEADER */

/* -- End embedded musashi/m68kops.h -- */

/* -- Begin embedded musashi/m68kfpu.c -- */
#include <math.h>
#include <stdio.h>
#include <stdarg.h>

static void fatalerror(const char* format, ...)
{
    va_list ap;
    va_start(ap, format);
    vfprintf(stderr, format, ap); // JFF: fixed. Was using fprintf and arguments were wrong
    va_end(ap);
    exit(1);
}

#define FPCC_N 0x08000000
#define FPCC_Z 0x04000000
#define FPCC_I 0x02000000
#define FPCC_NAN 0x01000000

#define DOUBLE_INFINITY (unsigned long long)(0x7ff0000000000000)
#define DOUBLE_EXPONENT (unsigned long long)(0x7ff0000000000000)
#define DOUBLE_MANTISSA (unsigned long long)(0x000fffffffffffff)

extern flag floatx80_is_nan(floatx80 a);

// masks for packed dwords, positive k-factor
static uint32 pkmask2[18] =
    {
        0xffffffff, 0, 0xf0000000, 0xff000000, 0xfff00000, 0xffff0000,
        0xfffff000, 0xffffff00, 0xfffffff0, 0xffffffff,
        0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
        0xffffffff, 0xffffffff, 0xffffffff};

static uint32 pkmask3[18] =
    {
        0xffffffff,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0xf0000000,
        0xff000000,
        0xfff00000,
        0xffff0000,
        0xfffff000,
        0xffffff00,
        0xfffffff0,
        0xffffffff,
};

static inline double fx80_to_double(floatx80 fx)
{
    uint64 d;
    double* foo;

    foo = (double*)&d;

    d = floatx80_to_float64(fx);

    return *foo;
}

static inline floatx80 double_to_fx80(double in)
{
    uint64* d;

    d = (uint64*)&in;

    return float64_to_floatx80(*d);
}

static inline floatx80 load_extended_float80(uint32 ea)
{
    uint32 d1, d2;
    uint16 d3;
    floatx80 fp;

    d3 = m68ki_read_16(ea);
    d1 = m68ki_read_32(ea + 4);
    d2 = m68ki_read_32(ea + 8);

    fp.high = d3;
    fp.low = ((uint64)d1 << 32) | (d2 & 0xffffffff);

    return fp;
}

static inline void store_extended_float80(uint32 ea, floatx80 fpr)
{
    m68ki_write_16(ea + 0, fpr.high);
    m68ki_write_16(ea + 2, 0);
    m68ki_write_32(ea + 4, (fpr.low >> 32) & 0xffffffff);
    m68ki_write_32(ea + 8, fpr.low & 0xffffffff);
}

static inline floatx80 load_pack_float80(uint32 ea)
{
    uint32 dw1, dw2, dw3;
    floatx80 result;
    double tmp;
    char str[128], *ch;

    dw1 = m68ki_read_32(ea);
    dw2 = m68ki_read_32(ea + 4);
    dw3 = m68ki_read_32(ea + 8);

    ch = &str[0];
    if (dw1 & 0x80000000) // mantissa sign
    {
        *ch++ = '-';
    }
    *ch++ = (char)((dw1 & 0xf) + '0');
    *ch++ = '.';
    *ch++ = (char)(((dw2 >> 28) & 0xf) + '0');
    *ch++ = (char)(((dw2 >> 24) & 0xf) + '0');
    *ch++ = (char)(((dw2 >> 20) & 0xf) + '0');
    *ch++ = (char)(((dw2 >> 16) & 0xf) + '0');
    *ch++ = (char)(((dw2 >> 12) & 0xf) + '0');
    *ch++ = (char)(((dw2 >> 8) & 0xf) + '0');
    *ch++ = (char)(((dw2 >> 4) & 0xf) + '0');
    *ch++ = (char)(((dw2 >> 0) & 0xf) + '0');
    *ch++ = (char)(((dw3 >> 28) & 0xf) + '0');
    *ch++ = (char)(((dw3 >> 24) & 0xf) + '0');
    *ch++ = (char)(((dw3 >> 20) & 0xf) + '0');
    *ch++ = (char)(((dw3 >> 16) & 0xf) + '0');
    *ch++ = (char)(((dw3 >> 12) & 0xf) + '0');
    *ch++ = (char)(((dw3 >> 8) & 0xf) + '0');
    *ch++ = (char)(((dw3 >> 4) & 0xf) + '0');
    *ch++ = (char)(((dw3 >> 0) & 0xf) + '0');
    *ch++ = 'E';
    if (dw1 & 0x40000000) // exponent sign
    {
        *ch++ = '-';
    }
    *ch++ = (char)(((dw1 >> 24) & 0xf) + '0');
    *ch++ = (char)(((dw1 >> 20) & 0xf) + '0');
    *ch++ = (char)(((dw1 >> 16) & 0xf) + '0');
    *ch = '\0';

    sscanf(str, "%le", &tmp);

    result = double_to_fx80(tmp);

    return result;
}

static inline void store_pack_float80(uint32 ea, int k, floatx80 fpr)
{
    uint32 dw1, dw2, dw3;
    char str[128], *ch;
    int i, j, exp;

    dw1 = dw2 = dw3 = 0;
    ch = &str[0];

    sprintf(str, "%.16e", fx80_to_double(fpr));

    if (*ch == '-') {
        ch++;
        dw1 = 0x80000000;
    }

    if (*ch == '+') {
        ch++;
    }

    dw1 |= (*ch++ - '0');

    if (*ch == '.') {
        ch++;
    }

    // handle negative k-factor here
    if ((k <= 0) && (k >= -13)) {
        exp = 0;
        for (i = 0; i < 3; i++) {
            if (ch[18 + i] >= '0' && ch[18 + i] <= '9') {
                exp = (exp << 4) | (ch[18 + i] - '0');
            }
        }

        if (ch[17] == '-') {
            exp = -exp;
        }

        k = -k;
        // last digit is (k + exponent - 1)
        k += (exp - 1);

        // round up the last significant mantissa digit
        if (ch[k + 1] >= '5') {
            ch[k]++;
        }

        // zero out the rest of the mantissa digits
        for (j = (k + 1); j < 16; j++) {
            ch[j] = '0';
        }

        // now zero out K to avoid tripping the positive K detection below
        k = 0;
    }

    // crack 8 digits of the mantissa
    for (i = 0; i < 8; i++) {
        dw2 <<= 4;
        if (*ch >= '0' && *ch <= '9') {
            dw2 |= *ch++ - '0';
        }
    }

    // next 8 digits of the mantissa
    for (i = 0; i < 8; i++) {
        dw3 <<= 4;
        if (*ch >= '0' && *ch <= '9') {
            dw3 |= *ch++ - '0';
        }
    }

    // handle masking if k is positive
    if (k >= 1) {
        if (k <= 17) {
            dw2 &= pkmask2[k];
            dw3 &= pkmask3[k];
        } else {
            dw2 &= pkmask2[17];
            dw3 &= pkmask3[17];
            //			m68ki_cpu.fpcr |=  (need to set OPERR bit)
        }
    }

    // finally, crack the exponent
    if (*ch == 'e' || *ch == 'E') {
        ch++;
        if (*ch == '-') {
            ch++;
            dw1 |= 0x40000000;
        }

        if (*ch == '+') {
            ch++;
        }

        j = 0;
        for (i = 0; i < 3; i++) {
            if (*ch >= '0' && *ch <= '9') {
                j = (j << 4) | (*ch++ - '0');
            }
        }

        dw1 |= (j << 16);
    }

    m68ki_write_32(ea, dw1);
    m68ki_write_32(ea + 4, dw2);
    m68ki_write_32(ea + 8, dw3);
}

static inline void SET_CONDITION_CODES(floatx80 reg)
{
    REG_FPSR &= ~(FPCC_N | FPCC_Z | FPCC_I | FPCC_NAN);

    // sign flag
    if (reg.high & 0x8000) {
        REG_FPSR |= FPCC_N;
    }

    // zero flag
    if (((reg.high & 0x7fff) == 0) && ((reg.low << 1) == 0)) {
        REG_FPSR |= FPCC_Z;
    }

    // infinity flag
    if (((reg.high & 0x7fff) == 0x7fff) && ((reg.low << 1) == 0)) {
        REG_FPSR |= FPCC_I;
    }

    // NaN flag
    if (floatx80_is_nan(reg)) {
        REG_FPSR |= FPCC_NAN;
    }
}

static inline int TEST_CONDITION(int condition)
{
    int n = (REG_FPSR & FPCC_N) != 0;
    int z = (REG_FPSR & FPCC_Z) != 0;
    int nan = (REG_FPSR & FPCC_NAN) != 0;
    int r = 0;
    switch (condition) {
        case 0x10:
        case 0x00:
            return 0; // False

        case 0x11:
        case 0x01:
            return (z); // Equal

        case 0x12:
        case 0x02:
            return (!(nan || z || n)); // Greater Than

        case 0x13:
        case 0x03:
            return (z || !(nan || n)); // Greater or Equal

        case 0x14:
        case 0x04:
            return (n && !(nan || z)); // Less Than

        case 0x15:
        case 0x05:
            return (z || (n && !nan)); // Less Than or Equal

        case 0x16:
        case 0x06:
            return !nan && !z;

        case 0x17:
        case 0x07:
            return !nan;

        case 0x18:
        case 0x08:
            return nan;

        case 0x19:
        case 0x09:
            return nan || z;

        case 0x1a:
        case 0x0a:
            return (nan || !(n || z)); // Not Less Than or Equal

        case 0x1b:
        case 0x0b:
            return (nan || z || !n); // Not Less Than

        case 0x1c:
        case 0x0c:
            return (nan || (n && !z)); // Not Greater or Equal Than

        case 0x1d:
        case 0x0d:
            return (nan || z || n); // Not Greater Than

        case 0x1e:
        case 0x0e:
            return (!z); // Not Equal

        case 0x1f:
        case 0x0f:
            return 1; // True

        default:
            fatalerror("M68kFPU: test_condition: unhandled condition %02X\n", condition);
    }

    return r;
}

static uint8 READ_EA_8(int ea)
{
    int mode = (ea >> 3) & 0x7;
    int reg = (ea & 0x7);

    switch (mode) {
        case 0: // Dn
        {
            return REG_D[reg];
        }
        case 2: // (An)
        {
            uint32 ea = REG_A[reg];
            return m68ki_read_8(ea);
        }
        case 3: // (An)+
        {
            uint32 ea = EA_AY_PI_8();
            return m68ki_read_8(ea);
        }
        case 4: // -(An)
        {
            uint32 ea = EA_AY_PD_8();
            return m68ki_read_8(ea);
        }
        case 5: // (d16, An)
        {
            uint32 ea = EA_AY_DI_8();
            return m68ki_read_8(ea);
        }
        case 6: // (An) + (Xn) + d8
        {
            uint32 ea = EA_AY_IX_8();
            return m68ki_read_8(ea);
        }
        case 7: {
            switch (reg) {
                case 0: // (xxx).W
                {
                    uint32 ea = (uint32)OPER_I_16();
                    return m68ki_read_8(ea);
                }
                case 1: // (xxx).L
                {
                    uint32 d1 = OPER_I_16();
                    uint32 d2 = OPER_I_16();
                    uint32 ea = (d1 << 16) | d2;
                    return m68ki_read_8(ea);
                }
                case 4: // #<data>
                {
                    return OPER_I_8();
                }
                default:
                    fatalerror("M68kFPU: READ_EA_8: unhandled mode %d, reg %d at %08X\n", mode, reg, REG_PC);
            }
            break;
        }
        default:
            fatalerror("M68kFPU: READ_EA_8: unhandled mode %d, reg %d at %08X\n", mode, reg, REG_PC);
    }

    return 0;
}

static uint16 READ_EA_16(int ea)
{
    int mode = (ea >> 3) & 0x7;
    int reg = (ea & 0x7);

    switch (mode) {
        case 0: // Dn
        {
            return (uint16)(REG_D[reg]);
        }
        case 2: // (An)
        {
            uint32 ea = REG_A[reg];
            return m68ki_read_16(ea);
        }
        case 3: // (An)+
        {
            uint32 ea = EA_AY_PI_16();
            return m68ki_read_16(ea);
        }
        case 4: // -(An)
        {
            uint32 ea = EA_AY_PD_16();
            return m68ki_read_16(ea);
        }
        case 5: // (d16, An)
        {
            uint32 ea = EA_AY_DI_16();
            return m68ki_read_16(ea);
        }
        case 6: // (An) + (Xn) + d8
        {
            uint32 ea = EA_AY_IX_16();
            return m68ki_read_16(ea);
        }
        case 7: {
            switch (reg) {
                case 0: // (xxx).W
                {
                    uint32 ea = (uint32)OPER_I_16();
                    return m68ki_read_16(ea);
                }
                case 1: // (xxx).L
                {
                    uint32 d1 = OPER_I_16();
                    uint32 d2 = OPER_I_16();
                    uint32 ea = (d1 << 16) | d2;
                    return m68ki_read_16(ea);
                }
                case 4: // #<data>
                {
                    return OPER_I_16();
                }

                default:
                    fatalerror("M68kFPU: READ_EA_16: unhandled mode %d, reg %d at %08X\n", mode, reg, REG_PC);
            }
            break;
        }
        default:
            fatalerror("M68kFPU: READ_EA_16: unhandled mode %d, reg %d at %08X\n", mode, reg, REG_PC);
    }

    return 0;
}

static uint32 READ_EA_32(int ea)
{
    int mode = (ea >> 3) & 0x7;
    int reg = (ea & 0x7);

    switch (mode) {
        case 0: // Dn
        {
            return REG_D[reg];
        }
        case 2: // (An)
        {
            uint32 ea = REG_A[reg];
            return m68ki_read_32(ea);
        }
        case 3: // (An)+
        {
            uint32 ea = EA_AY_PI_32();
            return m68ki_read_32(ea);
        }
        case 4: // -(An)
        {
            uint32 ea = EA_AY_PD_32();
            return m68ki_read_32(ea);
        }
        case 5: // (d16, An)
        {
            uint32 ea = EA_AY_DI_32();
            return m68ki_read_32(ea);
        }
        case 6: // (An) + (Xn) + d8
        {
            uint32 ea = EA_AY_IX_32();
            return m68ki_read_32(ea);
        }
        case 7: {
            switch (reg) {
                case 0: // (xxx).W
                {
                    uint32 ea = (uint32)OPER_I_16();
                    return m68ki_read_32(ea);
                }
                case 1: // (xxx).L
                {
                    uint32 d1 = OPER_I_16();
                    uint32 d2 = OPER_I_16();
                    uint32 ea = (d1 << 16) | d2;
                    return m68ki_read_32(ea);
                }
                case 2: // (d16, PC)
                {
                    uint32 ea = EA_PCDI_32();
                    return m68ki_read_32(ea);
                }
                case 4: // #<data>
                {
                    return OPER_I_32();
                }
                default:
                    fatalerror("M68kFPU: READ_EA_32: unhandled mode %d, reg %d at %08X\n", mode, reg, REG_PC);
            }
            break;
        }
        default:
            fatalerror("M68kFPU: READ_EA_32: unhandled mode %d, reg %d at %08X\n", mode, reg, REG_PC);
    }
    return 0;
}

static uint64 READ_EA_64(int ea)
{
    int mode = (ea >> 3) & 0x7;
    int reg = (ea & 0x7);
    uint32 h1, h2;

    switch (mode) {
        case 2: // (An)
        {
            uint32 ea = REG_A[reg];
            h1 = m68ki_read_32(ea + 0);
            h2 = m68ki_read_32(ea + 4);
            return (uint64)(h1) << 32 | (uint64)(h2);
        }
        case 3: // (An)+
        {
            uint32 ea = REG_A[reg];
            REG_A[reg] += 8;
            h1 = m68ki_read_32(ea + 0);
            h2 = m68ki_read_32(ea + 4);
            return (uint64)(h1) << 32 | (uint64)(h2);
        }
        case 4: // -(An)
        {
            REG_A[reg] -= 8;
            uint32 ea = REG_A[reg];
            h1 = m68ki_read_32(ea + 0);
            h2 = m68ki_read_32(ea + 4);
            return (uint64)(h1) << 32 | (uint64)(h2);
        }
        case 5: // (d16, An)
        {
            uint32 ea = EA_AY_DI_32();
            h1 = m68ki_read_32(ea + 0);
            h2 = m68ki_read_32(ea + 4);
            return (uint64)(h1) << 32 | (uint64)(h2);
        }
        case 6: // (An) + (Xn) + d8
        {
            uint32 ea = EA_AY_IX_16();
            h1 = m68ki_read_32(ea + 0);
            h2 = m68ki_read_32(ea + 4);
            return (uint64)(h1) << 32 | (uint64)(h2);
        }
        case 7: {
            switch (reg) {
                case 1: // (xxx).L
                {
                    uint32 d1 = OPER_I_16();
                    uint32 d2 = OPER_I_16();
                    uint32 ea = (d1 << 16) | d2;
                    h1 = m68ki_read_32(ea + 0);
                    h2 = m68ki_read_32(ea + 4);
                    return (uint64)(h1) << 32 | (uint64)(h2);
                }
                case 4: // #<data>
                {
                    h1 = OPER_I_32();
                    h2 = OPER_I_32();
                    return (uint64)(h1) << 32 | (uint64)(h2);
                }
                case 2: // (d16, PC)
                {
                    uint32 ea = EA_PCDI_32();
                    h1 = m68ki_read_32(ea + 0);
                    h2 = m68ki_read_32(ea + 4);
                    return (uint64)(h1) << 32 | (uint64)(h2);
                }
                default:
                    fatalerror("M68kFPU: READ_EA_64: unhandled mode %d, reg %d at %08X\n", mode, reg, REG_PC);
            }
            break;
        }
        default:
            fatalerror("M68kFPU: READ_EA_64: unhandled mode %d, reg %d at %08X\n", mode, reg, REG_PC);
    }

    return 0;
}

static floatx80 READ_EA_FPE(int mode, int reg, uint32 di_mode_ea)
{
    floatx80 fpr = {0};

    switch (mode) {
        case 2: // (An)
        {
            uint32 ea = REG_A[reg];
            fpr = load_extended_float80(ea);
            break;
        }
        case 3: // (An)+
        {
            uint32 ea = REG_A[reg];
            REG_A[reg] += 12;
            fpr = load_extended_float80(ea);
            break;
        }
        case 4: // -(An)
        {
            REG_A[reg] -= 12;
            uint32 ea = REG_A[reg];
            fpr = load_extended_float80(ea);
            break;
        }
        case 5: // (d16, An)  (added by JFF)
        {
            fpr = load_extended_float80(di_mode_ea);
            break;
        }
        case 6: // (An) + (Xn) + d8
        {
            uint32 ea = EA_AY_IX_16();
            fpr = load_extended_float80(ea);
            break;
        }
        case 7: // extended modes
        {
            switch (reg) {
                case 1: // (xxx).L
                {
                    uint32 d1 = OPER_I_16();
                    uint32 d2 = OPER_I_16();
                    fpr = load_extended_float80((d1 << 16) | d2);
                } break;
                case 2: // (d16, PC)
                {
                    uint32 ea = EA_PCDI_32();
                    fpr = load_extended_float80(ea);
                } break;

                case 3: // (d16,PC,Dx.w)
                {
                    uint32 ea = EA_PCIX_32();
                    fpr = load_extended_float80(ea);
                } break;
                case 4: // immediate (JFF)
                {
                    uint32 ea = REG_PC;
                    fpr = load_extended_float80(ea);
                    REG_PC += 12;
                } break;
                default:
                    fatalerror("M68kFPU: READ_EA_FPE: unhandled mode %d, reg %d, at %08X\n", mode, reg, REG_PC);
                    break;
            }
        } break;

        default:
            fatalerror("M68kFPU: READ_EA_FPE: unhandled mode %d, reg %d, at %08X\n", mode, reg, REG_PC);
            break;
    }

    return fpr;
}

static floatx80 READ_EA_PACK(int ea)
{
    floatx80 fpr = {0};
    int mode = (ea >> 3) & 0x7;
    int reg = (ea & 0x7);

    switch (mode) {
        case 2: // (An)
        {
            uint32 ea = REG_A[reg];
            fpr = load_pack_float80(ea);
            break;
        }

        case 3: // (An)+
        {
            uint32 ea = REG_A[reg];
            REG_A[reg] += 12;
            fpr = load_pack_float80(ea);
            break;
        }
        case 4: // -(An)
        {
            REG_A[reg] -= 12;
            uint32 ea = REG_A[reg];
            fpr = load_pack_float80(ea);
            break;
        }

        case 7: // extended modes
        {
            switch (reg) {
                case 3: // (d16,PC,Dx.w)
                {
                    uint32 ea = EA_PCIX_32();
                    fpr = load_pack_float80(ea);
                } break;

                default:
                    fatalerror("M68kFPU: READ_EA_PACK: unhandled mode %d, reg %d, at %08X\n", mode, reg, REG_PC);
                    break;
            }
        } break;

        default:
            fatalerror("M68kFPU: READ_EA_PACK: unhandled mode %d, reg %d, at %08X\n", mode, reg, REG_PC);
            break;
    }

    return fpr;
}

static void WRITE_EA_8(int ea, uint8 data)
{
    int mode = (ea >> 3) & 0x7;
    int reg = (ea & 0x7);

    switch (mode) {
        case 0: // Dn
        {
            REG_D[reg] = data;
            break;
        }
        case 2: // (An)
        {
            uint32 ea = REG_A[reg];
            m68ki_write_8(ea, data);
            break;
        }
        case 3: // (An)+
        {
            uint32 ea = EA_AY_PI_8();
            m68ki_write_8(ea, data);
            break;
        }
        case 4: // -(An)
        {
            uint32 ea = EA_AY_PD_8();
            m68ki_write_8(ea, data);
            break;
        }
        case 5: // (d16, An)
        {
            uint32 ea = EA_AY_DI_8();
            m68ki_write_8(ea, data);
            break;
        }
        case 6: // (An) + (Xn) + d8
        {
            uint32 ea = EA_AY_IX_8();
            m68ki_write_8(ea, data);
            break;
        }
        case 7: {
            switch (reg) {
                case 1: // (xxx).B
                {
                    uint32 d1 = OPER_I_16();
                    uint32 d2 = OPER_I_16();
                    uint32 ea = (d1 << 16) | d2;
                    m68ki_write_8(ea, data);
                    break;
                }
                case 2: // (d16, PC)
                {
                    uint32 ea = EA_PCDI_16();
                    m68ki_write_8(ea, data);
                    break;
                }
                default:
                    fatalerror("M68kFPU: WRITE_EA_8: unhandled mode %d, reg %d at %08X\n", mode, reg, REG_PC);
            }
            break;
        }
        default:
            fatalerror("M68kFPU: WRITE_EA_8: unhandled mode %d, reg %d, data %08X at %08X\n", mode, reg, data, REG_PC);
    }
}

static void WRITE_EA_16(int ea, uint16 data)
{
    int mode = (ea >> 3) & 0x7;
    int reg = (ea & 0x7);

    switch (mode) {
        case 0: // Dn
        {
            REG_D[reg] = data;
            break;
        }
        case 2: // (An)
        {
            uint32 ea = REG_A[reg];
            m68ki_write_16(ea, data);
            break;
        }
        case 3: // (An)+
        {
            uint32 ea = EA_AY_PI_16();
            m68ki_write_16(ea, data);
            break;
        }
        case 4: // -(An)
        {
            uint32 ea = EA_AY_PD_16();
            m68ki_write_16(ea, data);
            break;
        }
        case 5: // (d16, An)
        {
            uint32 ea = EA_AY_DI_16();
            m68ki_write_16(ea, data);
            break;
        }
        case 6: // (An) + (Xn) + d8
        {
            uint32 ea = EA_AY_IX_16();
            m68ki_write_16(ea, data);
            break;
        }
        case 7: {
            switch (reg) {
                case 1: // (xxx).W
                {
                    uint32 d1 = OPER_I_16();
                    uint32 d2 = OPER_I_16();
                    uint32 ea = (d1 << 16) | d2;
                    m68ki_write_16(ea, data);
                    break;
                }
                case 2: // (d16, PC)
                {
                    uint32 ea = EA_PCDI_16();
                    m68ki_write_16(ea, data);
                    break;
                }
                default:
                    fatalerror("M68kFPU: WRITE_EA_16: unhandled mode %d, reg %d at %08X\n", mode, reg, REG_PC);
            }
            break;
        }
        default:
            fatalerror("M68kFPU: WRITE_EA_16: unhandled mode %d, reg %d, data %08X at %08X\n", mode, reg, data, REG_PC);
    }
}

static void WRITE_EA_32(int ea, uint32 data)
{
    int mode = (ea >> 3) & 0x7;
    int reg = (ea & 0x7);

    switch (mode) {
        case 0: // Dn
        {
            REG_D[reg] = data;
            break;
        }
        case 1: // An
        {
            REG_A[reg] = data;
            break;
        }
        case 2: // (An)
        {
            uint32 ea = REG_A[reg];
            m68ki_write_32(ea, data);
            break;
        }
        case 3: // (An)+
        {
            uint32 ea = EA_AY_PI_32();
            m68ki_write_32(ea, data);
            break;
        }
        case 4: // -(An)
        {
            uint32 ea = EA_AY_PD_32();
            m68ki_write_32(ea, data);
            break;
        }
        case 5: // (d16, An)
        {
            uint32 ea = EA_AY_DI_32();
            m68ki_write_32(ea, data);
            break;
        }
        case 6: // (An) + (Xn) + d8
        {
            uint32 ea = EA_AY_IX_32();
            m68ki_write_32(ea, data);
            break;
        }
        case 7: {
            switch (reg) {
                case 1: // (xxx).L
                {
                    uint32 d1 = OPER_I_16();
                    uint32 d2 = OPER_I_16();
                    uint32 ea = (d1 << 16) | d2;
                    m68ki_write_32(ea, data);
                    break;
                }
                case 2: // (d16, PC)
                {
                    uint32 ea = EA_PCDI_32();
                    m68ki_write_32(ea, data);
                    break;
                }
                default:
                    fatalerror("M68kFPU: WRITE_EA_32: unhandled mode %d, reg %d at %08X\n", mode, reg, REG_PC);
            }
            break;
        }
        default:
            fatalerror("M68kFPU: WRITE_EA_32: unhandled mode %d, reg %d, data %08X at %08X\n", mode, reg, data, REG_PC);
    }
}

static void WRITE_EA_64(int ea, uint64 data)
{
    int mode = (ea >> 3) & 0x7;
    int reg = (ea & 0x7);

    switch (mode) {
        case 2: // (An)
        {
            uint32 ea = REG_A[reg];
            m68ki_write_32(ea, (uint32)(data >> 32));
            m68ki_write_32(ea + 4, (uint32)(data));
            break;
        }
        case 3: // (An)+
        {
            uint32 ea;
            ea = REG_A[reg];
            REG_A[reg] += 8;
            m68ki_write_32(ea + 0, (uint32)(data >> 32));
            m68ki_write_32(ea + 4, (uint32)(data));
            break;
        }
        case 4: // -(An)
        {
            uint32 ea;
            REG_A[reg] -= 8;
            ea = REG_A[reg];
            m68ki_write_32(ea + 0, (uint32)(data >> 32));
            m68ki_write_32(ea + 4, (uint32)(data));
            break;
        }
        case 5: // (d16, An)
        {
            uint32 ea = EA_AY_DI_32();
            m68ki_write_32(ea + 0, (uint32)(data >> 32));
            m68ki_write_32(ea + 4, (uint32)(data));
            break;
        }

        case 6: // (An) + (Xn) + d8
        {
            uint32 ea = EA_AY_IX_16();
            m68ki_write_32(ea + 0, (uint32)(data >> 32));
            m68ki_write_32(ea + 4, (uint32)(data));
            break;
        }
        case 7: {
            switch (reg) {
                case 1: // (xxx).L
                {
                    uint32 d1 = OPER_I_16();
                    uint32 d2 = OPER_I_16();
                    uint32 ea = (d1 << 16) | d2;
                    m68ki_write_32(ea + 0, (uint32)(data >> 32));
                    m68ki_write_32(ea + 4, (uint32)(data));
                    break;
                }
                case 2: // (d16, PC)
                {
                    uint32 ea = EA_PCDI_32();
                    m68ki_write_32(ea + 0, (uint32)(data >> 32));
                    m68ki_write_32(ea + 4, (uint32)(data));
                    break;
                }
                default:
                    fatalerror("M68kFPU: WRITE_EA_64: unhandled mode %d, data %08X%08X at %08X\n", mode, reg, (uint32)(data >> 32), (uint32)(data), REG_PC);
            }
            break;
        }
        default:
            fatalerror("M68kFPU: WRITE_EA_64: unhandled mode %d, reg %d, data %08X%08X at %08X\n", mode, reg, (uint32)(data >> 32), (uint32)(data), REG_PC);
    }
}

static void WRITE_EA_FPE(int mode, int reg, floatx80 fpr, uint32 di_mode_ea)
{

    switch (mode) {
        case 2: // (An)
        {
            uint32 ea;
            ea = REG_A[reg];
            store_extended_float80(ea, fpr);
            break;
        }

        case 3: // (An)+
        {
            uint32 ea;
            ea = REG_A[reg];
            store_extended_float80(ea, fpr);
            REG_A[reg] += 12;
            break;
        }

        case 4: // -(An)
        {
            uint32 ea;
            REG_A[reg] -= 12;
            ea = REG_A[reg];
            store_extended_float80(ea, fpr);
            break;
        }
        case 5: // (d16, An)  (added by JFF)
        {
            // EA_AY_DI_32() should not be done here because fmovem would increase
            // PC each time, reading incorrect displacement & advancing PC too much
            // uint32 ea = EA_AY_DI_32();
            store_extended_float80(di_mode_ea, fpr);
            break;
        }
        case 7: {
            switch (reg) {
                case 1: // (xxx).L
                {
                    uint32 d1 = OPER_I_16();
                    uint32 d2 = OPER_I_16();
                    uint32 ea = (d1 << 16) | d2;
                    store_extended_float80(ea, fpr);
                    break;
                }

                default:
                    fatalerror("M68kFPU: WRITE_EA_FPE: unhandled mode %d, reg %d, at %08X\n", mode, reg, REG_PC);
            }
            break;
        }
        default:
            fatalerror("M68kFPU: WRITE_EA_FPE: unhandled mode %d, reg %d, at %08X\n", mode, reg, REG_PC);
    }
}

static void WRITE_EA_PACK(int ea, int k, floatx80 fpr)
{
    int mode = (ea >> 3) & 0x7;
    int reg = (ea & 0x7);

    switch (mode) {
        case 2: // (An)
        {
            uint32 ea;
            ea = REG_A[reg];
            store_pack_float80(ea, k, fpr);
            break;
        }

        case 3: // (An)+
        {
            uint32 ea;
            ea = REG_A[reg];
            store_pack_float80(ea, k, fpr);
            REG_A[reg] += 12;
            break;
        }

        case 4: // -(An)
        {
            uint32 ea;
            REG_A[reg] -= 12;
            ea = REG_A[reg];
            store_pack_float80(ea, k, fpr);
            break;
        }

        case 7: {
            switch (reg) {
                default:
                    fatalerror("M68kFPU: WRITE_EA_PACK: unhandled mode %d, reg %d, at %08X\n", mode, reg, REG_PC);
            }
        } break;
        default:
            fatalerror("M68kFPU: WRITE_EA_PACK: unhandled mode %d, reg %d, at %08X\n", mode, reg, REG_PC);
    }
}

static inline int is_inf(floatx80 reg)
{
    if (((reg.high & 0x7fff) == 0x7fff) && ((reg.low << 1) == 0)) {
        return reg.high & 0x8000 ? -1 : 1;
    }
    return 0;
}

static void fpgen_rm_reg(uint16 w2)
{
    int ea = REG_IR & 0x3f;
    int rm = (w2 >> 14) & 0x1;
    int src = (w2 >> 10) & 0x7;
    int dst = (w2 >> 7) & 0x7;
    int opmode = w2 & 0x7f;
    floatx80 source;
    int round;

    // fmovecr #$f, fp0	f200 5c0f

    if (rm) {
        switch (src) {
            case 0: // Long-Word Integer
            {
                sint32 d = READ_EA_32(ea);
                source = int32_to_floatx80(d);
                break;
            }
            case 1: // Single-precision Real
            {
                uint32 d = READ_EA_32(ea);
                source = float32_to_floatx80(d);
                break;
            }
            case 2: // Extended-precision Real
            {
                int imode = (ea >> 3) & 0x7;
                int reg = (ea & 0x7);
                uint32 di_mode_ea = imode == 5 ? (REG_A[reg] + MAKE_INT_16(m68ki_read_imm_16())) : 0;
                source = READ_EA_FPE(imode, reg, di_mode_ea);
                break;
            }
            case 3: // Packed-decimal Real
            {
                source = READ_EA_PACK(ea);
                break;
            }
            case 4: // Word Integer
            {
                sint16 d = READ_EA_16(ea);
                source = int32_to_floatx80((sint32)d);
                break;
            }
            case 5: // Double-precision Real
            {
                uint64 d = READ_EA_64(ea);

                source = float64_to_floatx80(d);
                break;
            }
            case 6: // Byte Integer
            {
                sint8 d = READ_EA_8(ea);
                source = int32_to_floatx80((sint32)d);
                break;
            }
            case 7: // FMOVECR load from constant ROM
            {
                switch (w2 & 0x7f) {
                    case 0x0: // Pi
                        source.high = 0x4000;
                        source.low = U64(0xc90fdaa22168c235);
                        break;

                    case 0xb: // log10(2)
                        source.high = 0x3ffd;
                        source.low = U64(0x9a209a84fbcff798);
                        break;

                    case 0xc: // e
                        source.high = 0x4000;
                        source.low = U64(0xadf85458a2bb4a9b);
                        break;

                    case 0xd: // log2(e)
                        source.high = 0x3fff;
                        source.low = U64(0xb8aa3b295c17f0bc);
                        break;

                    case 0xe: // log10(e)
                        source.high = 0x3ffd;
                        source.low = U64(0xde5bd8a937287195);
                        break;

                    case 0xf: // 0.0
                        source = int32_to_floatx80((sint32)0);
                        break;

                    case 0x30: // ln(2)
                        source.high = 0x3ffe;
                        source.low = U64(0xb17217f7d1cf79ac);
                        break;

                    case 0x31: // ln(10)
                        source.high = 0x4000;
                        source.low = U64(0x935d8dddaaa8ac17);
                        break;

                    case 0x32: // 1 (or 100?  manuals are unclear, but 1 would make more sense)
                        source = int32_to_floatx80((sint32)1);
                        break;

                    case 0x33: // 10^1
                        source = int32_to_floatx80((sint32)10);
                        break;

                    case 0x34: // 10^2
                        source = int32_to_floatx80((sint32)10 * 10);
                        break;

                    case 0x35: // 10^4
                        source = int32_to_floatx80((sint32)10000);
                        break;

                    case 0x36: // 10^8
                        source = double_to_fx80(1e8);
                        break;

                    case 0x37: // 10^16
                        source = double_to_fx80(1e16);
                        break;

                    case 0x38: // 10^32
                        source = double_to_fx80(1e32);
                        break;

                    case 0x39: // 10^64
                        source = double_to_fx80(1e64);
                        break;

                    case 0x3a: // 10^128
                        source = double_to_fx80(1e128);
                        break;

                    case 0x3b: // 10^256
                        source = double_to_fx80(1e256);
                        break;

                    case 0x3c: // 10^512
                        source = double_to_fx80(1e256);
                        source = floatx80_mul(source, source);
                        break;

                    case 0x3d: // 10^1024
                        source = double_to_fx80(1e256);
                        source = floatx80_mul(source, source);
                        source = floatx80_mul(source, source);
                        break;

                    case 0x3e: // 10^2048
                        source = double_to_fx80(1e256);
                        source = floatx80_mul(source, source);
                        source = floatx80_mul(source, source);
                        source = floatx80_mul(source, source);
                        break;

                    case 0x3f: // 10^4096
                        source = double_to_fx80(1e256);
                        source = floatx80_mul(source, source);
                        source = floatx80_mul(source, source);
                        source = floatx80_mul(source, source);
                        source = floatx80_mul(source, source);
                        break;

                    default:
                        source = int32_to_floatx80((sint32)0);
                        break;
                }

                // handle it right here, the usual opmode bits aren't valid in the FMOVECR case
                REG_FP[dst] = source;
                SET_CONDITION_CODES(REG_FP[dst]); // JFF when destination is a register, we HAVE to update FPCR
                USE_CYCLES(4);
                return;
            }
            default:
                fatalerror("fmove_rm_reg: invalid source specifier %x at %08X\n", src, REG_PC - 4);
        }
    } else {
        source = REG_FP[src];
    }

    if ((opmode & 0x44) == 0x44) {
        round = 2;
        opmode &= ~0x44;
    } else if (opmode & 0x40) {
        round = 1;
        opmode &= ~0x40;
    } else {
        round = 0;
    }

    switch (opmode) {
        case 0x00: // FMOVE
        {
            REG_FP[dst] = source;
            SET_CONDITION_CODES(REG_FP[dst]); // JFF needs update condition codes
            USE_CYCLES(4);
            break;
        }
        case 0x01: // Fsint
        {
            sint32 temp;
            temp = floatx80_to_int32(source);
            REG_FP[dst] = int32_to_floatx80(temp);
            SET_CONDITION_CODES(REG_FP[dst]); // JFF needs update condition codes
            break;
        }
        case 0x03: // FsintRZ
        {
            sint32 temp;
            temp = floatx80_to_int32_round_to_zero(source);
            REG_FP[dst] = int32_to_floatx80(temp);
            SET_CONDITION_CODES(REG_FP[dst]); // JFF needs update condition codes
            break;
        }
        case 0x04: // FSQRT
        {
            REG_FP[dst] = floatx80_sqrt(source);
            SET_CONDITION_CODES(REG_FP[dst]);
            USE_CYCLES(109);
            break;
        }
        case 0x18: // FABS
        {
            REG_FP[dst] = source;
            REG_FP[dst].high &= 0x7fff;
            SET_CONDITION_CODES(REG_FP[dst]);
            USE_CYCLES(3);
            break;
        }
        case 0x1a: // FNEG
        {
            REG_FP[dst] = source;
            REG_FP[dst].high ^= 0x8000;
            SET_CONDITION_CODES(REG_FP[dst]);
            USE_CYCLES(3);
            break;
        }
        case 0xe: // SIN
            REG_FP[dst] = double_to_fx80(sin(fx80_to_double(source)));
            SET_CONDITION_CODES(REG_FP[dst]); // JFF
            USE_CYCLES(400);
            break;
        case 0x1d: // COS
            REG_FP[dst] = double_to_fx80(cos(fx80_to_double(source)));
            SET_CONDITION_CODES(REG_FP[dst]); // JFF
            USE_CYCLES(400);
            break;
        case 0x30: // SINCOS
        case 0x31: // SINCOS
        case 0x32: // SINCOS
        case 0x33: // SINCOS
        case 0x34: // SINCOS
        case 0x35: // SINCOS
        case 0x36: // SINCOS
        case 0x37: // SINCOS
        {
            double ds = fx80_to_double(source);
            REG_FP[dst] = double_to_fx80(sin(ds));
            REG_FP[opmode & 7] = double_to_fx80(cos(ds));
            SET_CONDITION_CODES(REG_FP[dst]); // JFF
            USE_CYCLES(400);
            break;
        }
        case 0x1e: // FGETEXP
        {
            sint16 temp;
            temp = source.high; // get the exponent
            temp -= 0x3fff;     // take off the bias
            REG_FP[dst] = double_to_fx80((double)temp);
            SET_CONDITION_CODES(REG_FP[dst]);
            USE_CYCLES(6);
            break;
        }
        case 0x20: // FDIV
        {
            REG_FP[dst] = floatx80_div(REG_FP[dst], source);
            SET_CONDITION_CODES(REG_FP[dst]); // JFF
            USE_CYCLES(43);
            break;
        }
        case 0x21: // FMOD
        {
            REG_FP[dst] = floatx80_rem(REG_FP[dst], source);
            SET_CONDITION_CODES(REG_FP[dst]);
            USE_CYCLES(43);
            break;
        }
        case 0x24: // FSGLDIV
        {
            REG_FP[dst] = double_to_fx80((float)fx80_to_double(floatx80_div(REG_FP[dst], source)));
            SET_CONDITION_CODES(REG_FP[dst]); // JFF
            USE_CYCLES(43);
            break;
        }
        case 0x22: // FADD
        {
            REG_FP[dst] = floatx80_add(REG_FP[dst], source);
            SET_CONDITION_CODES(REG_FP[dst]);
            USE_CYCLES(9);
            break;
        }
        case 0x23: // FMUL
        {
            REG_FP[dst] = floatx80_mul(REG_FP[dst], source);
            SET_CONDITION_CODES(REG_FP[dst]);
            USE_CYCLES(11);
            break;
        }
        case 0x27: // FSGLMUL
        {
            REG_FP[dst] = double_to_fx80((float)fx80_to_double(floatx80_mul(REG_FP[dst], source)));
            SET_CONDITION_CODES(REG_FP[dst]);
            USE_CYCLES(11);
            break;
        }
        case 0x25: // FREM
        {
            REG_FP[dst] = floatx80_rem(REG_FP[dst], source);
            SET_CONDITION_CODES(REG_FP[dst]);
            USE_CYCLES(43); // guess
            break;
        }
        case 0x28: // FSUB
        {
            REG_FP[dst] = floatx80_sub(REG_FP[dst], source);
            SET_CONDITION_CODES(REG_FP[dst]);
            USE_CYCLES(9);
            break;
        }
        case 0x38: // FCMP
        {
            floatx80 res;
            // handle inf in comparison if there is no nan.
            int d = is_inf(REG_FP[dst]);
            int s = is_inf(source);
            if (!floatx80_is_nan(REG_FP[dst]) && !floatx80_is_nan(source) && (d || s)) {
                REG_FPSR &= ~(FPCC_N | FPCC_Z | FPCC_I | FPCC_NAN);

                if (s < 0) {
                    if (d < 0) {
                        REG_FPSR |= FPCC_N | FPCC_Z;
                    }
                } else if (s > 0) {
                    if (d > 0) {
                        REG_FPSR |= FPCC_Z;
                    } else {
                        REG_FPSR |= FPCC_N;
                    }
                } else if (d < 0) {
                    REG_FPSR |= FPCC_N;
                }
            } else {
                res = floatx80_sub(REG_FP[dst], source);
                SET_CONDITION_CODES(res);
            }
            USE_CYCLES(7);
            break;
        }
        case 0x3a: // FTST
        {
            floatx80 res;
            res = source;
            SET_CONDITION_CODES(res);
            USE_CYCLES(7);
            break;
        }

        default:
            fatalerror("fpgen_rm_reg: unimplemented opmode %02X at %08X\n", opmode, REG_PC - 4);
    }
    if (round == 1) {
        // round to single
        REG_FP[dst] = double_to_fx80((float)fx80_to_double(REG_FP[dst]));
    } else if (round == 2) {
        // round to double
        REG_FP[dst] = double_to_fx80(fx80_to_double(REG_FP[dst]));
    }
}

static void fmove_reg_mem(uint16 w2)
{
    int ea = REG_IR & 0x3f;
    int src = (w2 >> 7) & 0x7;
    int dst = (w2 >> 10) & 0x7;
    int k = (w2 & 0x7f);

    switch (dst) {
        case 0: // Long-Word Integer
        {
            sint32 d = (sint32)floatx80_to_int32(REG_FP[src]);
            WRITE_EA_32(ea, d);
            break;
        }
        case 1: // Single-precision Real
        {
            uint32 d = floatx80_to_float32(REG_FP[src]);
            WRITE_EA_32(ea, d);
            break;
        }
        case 2: // Extended-precision Real
        {
            int mode = (ea >> 3) & 0x7;
            int reg = (ea & 0x7);
            uint32 di_mode_ea = mode == 5 ? (REG_A[reg] + MAKE_INT_16(m68ki_read_imm_16())) : 0;
            WRITE_EA_FPE(mode, reg, REG_FP[src], di_mode_ea);
            break;
        }
        case 3: // Packed-decimal Real with Static K-factor
        {
            // sign-extend k
            k = (k & 0x40) ? (k | 0xffffff80) : (k & 0x7f);
            WRITE_EA_PACK(ea, k, REG_FP[src]);
            break;
        }
        case 4: // Word Integer
        {
            WRITE_EA_16(ea, (sint16)floatx80_to_int32(REG_FP[src]));
            break;
        }
        case 5: // Double-precision Real
        {
            uint64 d;

            d = floatx80_to_float64(REG_FP[src]);

            WRITE_EA_64(ea, d);
            break;
        }
        case 6: // Byte Integer
        {
            WRITE_EA_8(ea, (sint8)floatx80_to_int32(REG_FP[src]));
            break;
        }
        case 7: // Packed-decimal Real with Dynamic K-factor
        {
            WRITE_EA_PACK(ea, REG_D[k >> 4], REG_FP[src]);
            break;
        }
    }

    USE_CYCLES(12);
}

static void fmove_fpcr(uint16 w2)
{
    int ea = REG_IR & 0x3f;
    int dir = (w2 >> 13) & 0x1;
    int reg = (w2 >> 10) & 0x7;

    if (dir) // From system control reg to <ea>
    {
        if (reg & 4) {
            WRITE_EA_32(ea, REG_FPCR);
        }
        if (reg & 2) {
            WRITE_EA_32(ea, REG_FPSR);
        }
        if (reg & 1) {
            WRITE_EA_32(ea, REG_FPIAR);
        }
    } else // From <ea> to system control reg
    {
        if (reg & 4) {
            REG_FPCR = READ_EA_32(ea);
            // JFF: need to update rounding mode from softfloat module
            float_rounding_mode = (REG_FPCR >> 4) & 0x3;
        }
        if (reg & 2) {
            REG_FPSR = READ_EA_32(ea);
        }
        if (reg & 1) {
            REG_FPIAR = READ_EA_32(ea);
        }
    }

    USE_CYCLES(10);
}

static void fmovem(uint16 w2)
{
    int i;
    int ea = REG_IR & 0x3f;
    int dir = (w2 >> 13) & 0x1;
    int mode = (w2 >> 11) & 0x3;
    int reglist = w2 & 0xff;

    if (dir) // From FP regs to mem
    {
        switch (mode) {
            case 2: // (JFF): Static register list, postincrement or control addressing mode.
            {
                int imode = (ea >> 3) & 0x7;
                int reg = (ea & 0x7);
                int di_mode = imode == 5;
                uint32 di_mode_ea = di_mode ? (REG_A[reg] + MAKE_INT_16(m68ki_read_imm_16())) : 0;
                for (i = 0; i < 8; i++) {
                    if (reglist & (1 << i)) {
                        WRITE_EA_FPE(imode, reg, REG_FP[7 - i], di_mode_ea);
                        USE_CYCLES(2);
                        if (di_mode) {
                            di_mode_ea += 12;
                        }
                    }
                }
                break;
            }
            case 0: // Static register list, predecrement addressing mode
            {
                int imode = (ea >> 3) & 0x7;
                int reg = (ea & 0x7);
                // the "di_mode_ea" parameter kludge is required here else WRITE_EA_FPE would have
                // to call EA_AY_DI_32() (that advances PC & reads displacement) each time
                // when the proper behaviour is 1) read once, 2) increment ea for each matching register
                // this forces to pre-read the mode (named "imode") so we can decide to read displacement, only once
                int di_mode = imode == 5;
                uint32 di_mode_ea = di_mode ? (REG_A[reg] + MAKE_INT_16(m68ki_read_imm_16())) : 0;
                for (i = 0; i < 8; i++) {
                    if (reglist & (1 << i)) {
                        WRITE_EA_FPE(imode, reg, REG_FP[i], di_mode_ea);
                        USE_CYCLES(2);
                        if (di_mode) {
                            di_mode_ea += 12;
                        }
                    }
                }
                break;
            }

            default:
                fatalerror("040fpu0: FMOVEM: mode %d unimplemented at %08X\n", mode, REG_PC - 4);
        }
    } else // From mem to FP regs
    {
        switch (mode) {
            case 2: // Static register list, postincrement addressing mode
            {
                int imode = (ea >> 3) & 0x7;
                int reg = (ea & 0x7);
                int di_mode = imode == 5;
                uint32 di_mode_ea = di_mode ? (REG_A[reg] + MAKE_INT_16(m68ki_read_imm_16())) : 0;
                for (i = 0; i < 8; i++) {
                    if (reglist & (1 << i)) {
                        REG_FP[7 - i] = READ_EA_FPE(imode, reg, di_mode_ea);
                        USE_CYCLES(2);
                        if (di_mode) {
                            di_mode_ea += 12;
                        }
                    }
                }
                break;
            }

            default:
                fatalerror("040fpu0: FMOVEM: mode %d unimplemented at %08X\n", mode, REG_PC - 4);
        }
    }
}

static void fscc(void)
{
    // added by JFF, this seems to work properly now
    int condition = OPER_I_16() & 0x3f;

    int cc = TEST_CONDITION(condition);
    int mode = (REG_IR & 0x38) >> 3;
    int v = (cc ? 0xff : 0x00);

    switch (mode) {
        case 0: // fscc Dx
        {
            // If the specified floating-point condition is true, sets the byte integer operand at
            // the destination to TRUE (all ones); otherwise, sets the byte to FALSE (all zeros).

            REG_D[REG_IR & 7] = (REG_D[REG_IR & 7] & 0xFFFFFF00) | v;
            break;
        }
        case 5: // (disp,Ax)
        {
            int reg = REG_IR & 7;
            uint32 ea = REG_A[reg] + MAKE_INT_16(m68ki_read_imm_16());
            m68ki_write_8(ea, v);
            break;
        }

        default: {
            // unimplemented see fpu_uae.cpp around line 1300
            fatalerror("040fpu0: fscc: mode %d not implemented at %08X\n", mode, REG_PC - 4);
        }
    }
    USE_CYCLES(7); // JFF unsure of the number of cycles!!
}
static void fbcc16(void)
{
    sint32 offset;
    int condition = REG_IR & 0x3f;

    offset = (sint16)(OPER_I_16());

    // TODO: condition and jump!!!
    if (TEST_CONDITION(condition)) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset - 2);
    }

    USE_CYCLES(7);
}

static void fbcc32(void)
{
    sint32 offset;
    int condition = REG_IR & 0x3f;

    offset = OPER_I_32();

    // TODO: condition and jump!!!
    if (TEST_CONDITION(condition)) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_32(offset - 4);
    }

    USE_CYCLES(7);
}

void m68040_fpu_op0(void)
{
    m68ki_cpu.fpu_just_reset = 0;

    switch ((REG_IR >> 6) & 0x3) {
        case 0: {
            uint16 w2 = OPER_I_16();
            switch ((w2 >> 13) & 0x7) {
                case 0x0: // FPU ALU FP, FP
                case 0x2: // FPU ALU ea, FP
                {
                    fpgen_rm_reg(w2);
                    break;
                }

                case 0x3: // FMOVE FP, ea
                {
                    fmove_reg_mem(w2);
                    break;
                }

                case 0x4: // FMOVEM ea, FPCR
                case 0x5: // FMOVEM FPCR, ea
                {
                    fmove_fpcr(w2);
                    break;
                }

                case 0x6: // FMOVEM ea, list
                case 0x7: // FMOVEM list, ea
                {
                    fmovem(w2);
                    break;
                }

                default:
                    fatalerror("M68kFPU: unimplemented subop %d at %08X\n", (w2 >> 13) & 0x7, REG_PC - 4);
            }
            break;
        }

        case 1: // FScc (JFF)
        {
            fscc();
            break;
        }
        case 2: // FBcc disp16
        {
            fbcc16();
            break;
        }
        case 3: // FBcc disp32
        {
            fbcc32();
            break;
        }

        default:
            fatalerror("M68kFPU: unimplemented main op %d at %08X\n", (m68ki_cpu.ir >> 6) & 0x3, REG_PC - 4);
    }
}

static void perform_fsave(uint32 addr, int inc)
{
    if (inc) {
        // 68881 IDLE, version 0x1f
        m68ki_write_32(addr, 0x1f180000);
        m68ki_write_32(addr + 4, 0);
        m68ki_write_32(addr + 8, 0);
        m68ki_write_32(addr + 12, 0);
        m68ki_write_32(addr + 16, 0);
        m68ki_write_32(addr + 20, 0);
        m68ki_write_32(addr + 24, 0x70000000);
    } else {
        m68ki_write_32(addr, 0x70000000);
        m68ki_write_32(addr - 4, 0);
        m68ki_write_32(addr - 8, 0);
        m68ki_write_32(addr - 12, 0);
        m68ki_write_32(addr - 16, 0);
        m68ki_write_32(addr - 20, 0);
        m68ki_write_32(addr - 24, 0x1f180000);
    }
}

// FRESTORE on a NULL frame reboots the FPU - all registers to NaN, the 3 status regs to 0
static void do_frestore_null(void)
{
    int i;

    REG_FPCR = 0;
    REG_FPSR = 0;
    REG_FPIAR = 0;
    for (i = 0; i < 8; i++) {
        REG_FP[i].high = 0x7fff;
        REG_FP[i].low = U64(0xffffffffffffffff);
    }

    // Mac IIci at 408458e6 wants an FSAVE of a just-restored NULL frame to also be NULL
    // The PRM says it's possible to generate a NULL frame, but not how/when/why.  (need the 68881/68882 manual!)
    m68ki_cpu.fpu_just_reset = 1;
}

void m68040_fpu_op1(void)
{
    int ea = REG_IR & 0x3f;
    int mode = (ea >> 3) & 0x7;
    int reg = (ea & 0x7);
    uint32 addr, temp;

    switch ((REG_IR >> 6) & 0x3) {
        case 0: // FSAVE <ea>
        {
            switch (mode) {
                case 3: // (An)+
                    addr = EA_AY_PI_32();

                    if (m68ki_cpu.fpu_just_reset) {
                        m68ki_write_32(addr, 0);
                    } else {
                        // we normally generate an IDLE frame
                        REG_A[reg] += 6 * 4;
                        perform_fsave(addr, 1);
                    }
                    break;

                case 4: // -(An)
                    addr = EA_AY_PD_32();

                    if (m68ki_cpu.fpu_just_reset) {
                        m68ki_write_32(addr, 0);
                    } else {
                        // we normally generate an IDLE frame
                        REG_A[reg] -= 6 * 4;
                        perform_fsave(addr, 0);
                    }
                    break;

                default:
                    fatalerror("M68kFPU: FSAVE unhandled mode %d reg %d at %x\n", mode, reg, REG_PC);
            }
            break;
        } break;

        case 1: // FRESTORE <ea>
        {
            switch (mode) {
                case 2: // (An)
                    addr = REG_A[reg];
                    temp = m68ki_read_32(addr);

                    // check for NULL frame
                    if (temp & 0xff000000) {
                        // we don't handle non-NULL frames and there's no pre/post inc/dec to do here
                        m68ki_cpu.fpu_just_reset = 0;
                    } else {
                        do_frestore_null();
                    }
                    break;

                case 3: // (An)+
                    addr = EA_AY_PI_32();
                    temp = m68ki_read_32(addr);

                    // check for NULL frame
                    if (temp & 0xff000000) {
                        m68ki_cpu.fpu_just_reset = 0;

                        // how about an IDLE frame?
                        if ((temp & 0x00ff0000) == 0x00180000) {
                            REG_A[reg] += 6 * 4;
                        } // check UNIMP
                        else if ((temp & 0x00ff0000) == 0x00380000) {
                            REG_A[reg] += 14 * 4;
                        } // check BUSY
                        else if ((temp & 0x00ff0000) == 0x00b40000) {
                            REG_A[reg] += 45 * 4;
                        }
                    } else {
                        do_frestore_null();
                    }
                    break;

                default:
                    fatalerror("M68kFPU: FRESTORE unhandled mode %d reg %d at %x\n", mode, reg, REG_PC);
            }
            break;
        } break;

        default:
            fatalerror("m68040_fpu_op1: unimplemented op %d at %08X\n", (REG_IR >> 6) & 0x3, REG_PC - 2);
    }
}

/* -- End embedded musashi/m68kfpu.c -- */

/* -- Begin embedded musashi/m68kmmu.h -- */
/*
    m68kmmu.h - PMMU implementation for 68851/68030/68040

    By R. Belmont

    Copyright Nicola Salmoria and the MAME Team.
    Visit http://mamedev.org for licensing and usage restrictions.
*/

/*
    pmmu_translate_addr: perform 68851/68030-style PMMU address translation
*/
uint pmmu_translate_addr(uint addr_in)
{
    uint32 addr_out, tbl_entry = 0, tbl_entry2, tamode = 0, tbmode = 0, tcmode = 0;
    uint root_aptr, root_limit, tofs, is, abits, bbits, cbits;
    uint resolved, tptr, shift;

    resolved = 0;
    addr_out = addr_in;

    // if SRP is enabled and we're in supervisor mode, use it
    if ((m68ki_cpu.mmu_tc & 0x02000000) && (m68ki_get_sr() & 0x2000)) {
        root_aptr = m68ki_cpu.mmu_srp_aptr;
        root_limit = m68ki_cpu.mmu_srp_limit;
    } else // else use the CRP
    {
        root_aptr = m68ki_cpu.mmu_crp_aptr;
        root_limit = m68ki_cpu.mmu_crp_limit;
    }

    // get initial shift (# of top bits to ignore)
    is = (m68ki_cpu.mmu_tc >> 16) & 0xf;
    abits = (m68ki_cpu.mmu_tc >> 12) & 0xf;
    bbits = (m68ki_cpu.mmu_tc >> 8) & 0xf;
    cbits = (m68ki_cpu.mmu_tc >> 4) & 0xf;

    //	fprintf(stderr,"PMMU: tcr %08x limit %08x aptr %08x is %x abits %d bbits %d cbits %d\n", m68ki_cpu.mmu_tc, root_limit, root_aptr, is, abits, bbits, cbits);

    // get table A offset
    tofs = (addr_in << is) >> (32 - abits);

    // find out what format table A is
    switch (root_limit & 3) {
        case 0: // invalid, should cause MMU exception
        case 1: // page descriptor, should cause direct mapping
            fatalerror("680x0 PMMU: Unhandled root mode\n");
            break;

        case 2: // valid 4 byte descriptors
            tofs *= 4;
            //			fprintf(stderr,"PMMU: reading table A entry at %08x\n", tofs + (root_aptr & 0xfffffffc));
            tbl_entry = m68k_read_memory_32(tofs + (root_aptr & 0xfffffffc));
            tamode = tbl_entry & 3;
            //			fprintf(stderr,"PMMU: addr %08x entry %08x mode %x tofs %x\n", addr_in, tbl_entry, tamode, tofs);
            break;

        case 3: // valid 8 byte descriptors
            tofs *= 8;
            //			fprintf(stderr,"PMMU: reading table A entries at %08x\n", tofs + (root_aptr & 0xfffffffc));
            tbl_entry2 = m68k_read_memory_32(tofs + (root_aptr & 0xfffffffc));
            tbl_entry = m68k_read_memory_32(tofs + (root_aptr & 0xfffffffc) + 4);
            tamode = tbl_entry2 & 3;
            //			fprintf(stderr,"PMMU: addr %08x entry %08x entry2 %08x mode %x tofs %x\n", addr_in, tbl_entry, tbl_entry2, tamode, tofs);
            break;
    }

    // get table B offset and pointer
    tofs = (addr_in << (is + abits)) >> (32 - bbits);
    tptr = tbl_entry & 0xfffffff0;

    // find out what format table B is, if any
    switch (tamode) {
        case 0: // invalid, should cause MMU exception
            fatalerror("680x0 PMMU: Unhandled Table A mode %d (addr_in %08x)\n", tamode, addr_in);
            break;

        case 2: // 4-byte table B descriptor
            tofs *= 4;
            //			fprintf(stderr,"PMMU: reading table B entry at %08x\n", tofs + tptr);
            tbl_entry = m68k_read_memory_32(tofs + tptr);
            tbmode = tbl_entry & 3;
            //			fprintf(stderr,"PMMU: addr %08x entry %08x mode %x tofs %x\n", addr_in, tbl_entry, tbmode, tofs);
            break;

        case 3: // 8-byte table B descriptor
            tofs *= 8;
            //			fprintf(stderr,"PMMU: reading table B entries at %08x\n", tofs + tptr);
            tbl_entry2 = m68k_read_memory_32(tofs + tptr);
            tbl_entry = m68k_read_memory_32(tofs + tptr + 4);
            tbmode = tbl_entry2 & 3;
            //			fprintf(stderr,"PMMU: addr %08x entry %08x entry2 %08x mode %x tofs %x\n", addr_in, tbl_entry, tbl_entry2, tbmode, tofs);
            break;

        case 1: // early termination descriptor
            tbl_entry &= 0xffffff00;

            shift = is + abits;
            addr_out = ((addr_in << shift) >> shift) + tbl_entry;
            resolved = 1;
            break;
    }

    // if table A wasn't early-out, continue to process table B
    if (!resolved) {
        // get table C offset and pointer
        tofs = (addr_in << (is + abits + bbits)) >> (32 - cbits);
        tptr = tbl_entry & 0xfffffff0;

        switch (tbmode) {
            case 0: // invalid, should cause MMU exception
                fatalerror("680x0 PMMU: Unhandled Table B mode %d (addr_in %08x PC %x)\n", tbmode, addr_in, REG_PC);
                break;

            case 2: // 4-byte table C descriptor
                tofs *= 4;
                //				fprintf(stderr,"PMMU: reading table C entry at %08x\n", tofs + tptr);
                tbl_entry = m68k_read_memory_32(tofs + tptr);
                tcmode = tbl_entry & 3;
                //				fprintf(stderr,"PMMU: addr %08x entry %08x mode %x tofs %x\n", addr_in, tbl_entry, tbmode, tofs);
                break;

            case 3: // 8-byte table C descriptor
                tofs *= 8;
                //				fprintf(stderr,"PMMU: reading table C entries at %08x\n", tofs + tptr);
                tbl_entry2 = m68k_read_memory_32(tofs + tptr);
                tbl_entry = m68k_read_memory_32(tofs + tptr + 4);
                tcmode = tbl_entry2 & 3;
                //				fprintf(stderr,"PMMU: addr %08x entry %08x entry2 %08x mode %x tofs %x\n", addr_in, tbl_entry, tbl_entry2, tbmode, tofs);
                break;

            case 1: // termination descriptor
                tbl_entry &= 0xffffff00;

                shift = is + abits + bbits;
                addr_out = ((addr_in << shift) >> shift) + tbl_entry;
                resolved = 1;
                break;
        }
    }

    if (!resolved) {
        switch (tcmode) {
            case 0: // invalid, should cause MMU exception
            case 2: // 4-byte ??? descriptor
            case 3: // 8-byte ??? descriptor
                fatalerror("680x0 PMMU: Unhandled Table B mode %d (addr_in %08x PC %x)\n", tbmode, addr_in, REG_PC);
                break;

            case 1: // termination descriptor
                tbl_entry &= 0xffffff00;

                shift = is + abits + bbits + cbits;
                addr_out = ((addr_in << shift) >> shift) + tbl_entry;
                resolved = 1;
                break;
        }
    }

    //	fprintf(stderr,"PMMU: [%08x] => [%08x]\n", addr_in, addr_out);

    return addr_out;
}

/*

    m68881_mmu_ops: COP 0 MMU opcode handling

*/

void m68881_mmu_ops(void)
{
    uint16 modes;
    uint32 ea = m68ki_cpu.ir & 0x3f;
    uint64 temp64;

    // catch the 2 "weird" encodings up front (PBcc)
    if ((m68ki_cpu.ir & 0xffc0) == 0xf0c0) {
        fprintf(stderr, "680x0: unhandled PBcc\n");
        return;
    } else if ((m68ki_cpu.ir & 0xffc0) == 0xf080) {
        fprintf(stderr, "680x0: unhandled PBcc\n");
        return;
    } else // the rest are 1111000xxxXXXXXX where xxx is the instruction family
    {
        switch ((m68ki_cpu.ir >> 9) & 0x7) {
            case 0:
                modes = OPER_I_16();

                if ((modes & 0xfde0) == 0x2000) // PLOAD
                {
                    fprintf(stderr, "680x0: unhandled PLOAD\n");
                    return;
                } else if ((modes & 0xe200) == 0x2000) // PFLUSH
                {
                    fprintf(stderr, "680x0: unhandled PFLUSH PC=%x\n", REG_PC);
                    return;
                } else if (modes == 0xa000) // PFLUSHR
                {
                    fprintf(stderr, "680x0: unhandled PFLUSHR\n");
                    return;
                } else if (modes == 0x2800) // PVALID (FORMAT 1)
                {
                    fprintf(stderr, "680x0: unhandled PVALID1\n");
                    return;
                } else if ((modes & 0xfff8) == 0x2c00) // PVALID (FORMAT 2)
                {
                    fprintf(stderr, "680x0: unhandled PVALID2\n");
                    return;
                } else if ((modes & 0xe000) == 0x8000) // PTEST
                {
                    fprintf(stderr, "680x0: unhandled PTEST\n");
                    return;
                } else {
                    switch ((modes >> 13) & 0x7) {
                        case 0: // MC68030/040 form with FD bit
                        case 2: // MC68881 form, FD never set
                            if (modes & 0x200) {
                                switch ((modes >> 10) & 7) {
                                    case 0: // translation control register
                                        WRITE_EA_32(ea, m68ki_cpu.mmu_tc);
                                        break;

                                    case 2: // supervisor root pointer
                                        WRITE_EA_64(ea, (uint64)m68ki_cpu.mmu_srp_limit << 32 | (uint64)m68ki_cpu.mmu_srp_aptr);
                                        break;

                                    case 3: // CPU root pointer
                                        WRITE_EA_64(ea, (uint64)m68ki_cpu.mmu_crp_limit << 32 | (uint64)m68ki_cpu.mmu_crp_aptr);
                                        break;

                                    default:
                                        fprintf(stderr, "680x0: PMOVE from unknown MMU register %x, PC %x\n", (modes >> 10) & 7, REG_PC);
                                        break;
                                }
                            } else {
                                switch ((modes >> 10) & 7) {
                                    case 0: // translation control register
                                        m68ki_cpu.mmu_tc = READ_EA_32(ea);

                                        if (m68ki_cpu.mmu_tc & 0x80000000) {
                                            m68ki_cpu.pmmu_enabled = 1;
                                        } else {
                                            m68ki_cpu.pmmu_enabled = 0;
                                        }
                                        break;

                                    case 2: // supervisor root pointer
                                        temp64 = READ_EA_64(ea);
                                        m68ki_cpu.mmu_srp_limit = (temp64 >> 32) & 0xffffffff;
                                        m68ki_cpu.mmu_srp_aptr = temp64 & 0xffffffff;
                                        break;

                                    case 3: // CPU root pointer
                                        temp64 = READ_EA_64(ea);
                                        m68ki_cpu.mmu_crp_limit = (temp64 >> 32) & 0xffffffff;
                                        m68ki_cpu.mmu_crp_aptr = temp64 & 0xffffffff;
                                        break;

                                    default:
                                        fprintf(stderr, "680x0: PMOVE to unknown MMU register %x, PC %x\n", (modes >> 10) & 7, REG_PC);
                                        break;
                                }
                            }
                            break;

                        case 3: // MC68030 to/from status reg
                            if (modes & 0x200) {
                                WRITE_EA_32(ea, m68ki_cpu.mmu_sr);
                            } else {
                                m68ki_cpu.mmu_sr = READ_EA_32(ea);
                            }
                            break;

                        default:
                            fprintf(stderr, "680x0: unknown PMOVE mode %x (modes %04x) (PC %x)\n", (modes >> 13) & 0x7, modes, REG_PC);
                            break;
                    }
                }
                break;

            default:
                fprintf(stderr, "680x0: unknown PMMU instruction group %d\n", (m68ki_cpu.ir >> 9) & 0x7);
                break;
        }
    }
}

/* -- End embedded musashi/m68kmmu.h -- */

/* -- Begin embedded musashi/m68kcpu.c -- */
/* ======================================================================== */
/* ========================= LICENSING & COPYRIGHT ======================== */
/* ======================================================================== */
/*
 *                                  MUSASHI
 *                                Version 4.60
 *
 * A portable Motorola M680x0 processor emulation engine.
 * Copyright Karl Stenerud.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* ======================================================================== */
/* ================================= NOTES ================================ */
/* ======================================================================== */

/* ======================================================================== */
/* ================================ INCLUDES ============================== */
/* ======================================================================== */

extern void m68040_fpu_op0(void);
extern void m68040_fpu_op1(void);
extern void m68881_mmu_ops(void);
extern unsigned char m68ki_cycles[][0x10000];
extern void (*m68ki_instruction_jump_table[0x10000])(void); /* opcode handler jump table */
extern void m68ki_build_opcode_table(void);

/* ======================================================================== */
/* ================================= DATA ================================= */
/* ======================================================================== */

int m68ki_initial_cycles;
int m68ki_remaining_cycles = 0; /* Number of clocks remaining */
uint m68ki_tracing = 0;
uint m68ki_address_space;

#ifdef M68K_LOG_ENABLE
const char* const m68ki_cpu_names[] =
    {
        "Invalid CPU",
        "M68000",
        "M68010",
        "M68EC020",
        "M68020",
        "M68EC030",
        "M68030",
        "M68EC040",
        "M68LC040",
        "M68040",
        "SCC68070",
};
#endif /* M68K_LOG_ENABLE */

/* The CPU core */
m68ki_cpu_core m68ki_cpu = {0};

#if M68K_EMULATE_ADDRESS_ERROR
#ifdef _BSD_SETJMP_H
sigjmp_buf m68ki_aerr_trap;
#else
jmp_buf m68ki_aerr_trap;
#endif
#endif /* M68K_EMULATE_ADDRESS_ERROR */

uint m68ki_aerr_address;
uint m68ki_aerr_write_mode;
uint m68ki_aerr_fc;

jmp_buf m68ki_bus_error_jmp_buf;

/* Used by shift & rotate instructions */
const uint8 m68ki_shift_8_table[65] =
    {
        0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff};
const uint16 m68ki_shift_16_table[65] =
    {
        0x0000, 0x8000, 0xc000, 0xe000, 0xf000, 0xf800, 0xfc00, 0xfe00, 0xff00,
        0xff80, 0xffc0, 0xffe0, 0xfff0, 0xfff8, 0xfffc, 0xfffe, 0xffff, 0xffff,
        0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
        0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
        0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
        0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
        0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
        0xffff, 0xffff};
const uint m68ki_shift_32_table[65] =
    {
        0x00000000, 0x80000000, 0xc0000000, 0xe0000000, 0xf0000000, 0xf8000000,
        0xfc000000, 0xfe000000, 0xff000000, 0xff800000, 0xffc00000, 0xffe00000,
        0xfff00000, 0xfff80000, 0xfffc0000, 0xfffe0000, 0xffff0000, 0xffff8000,
        0xffffc000, 0xffffe000, 0xfffff000, 0xfffff800, 0xfffffc00, 0xfffffe00,
        0xffffff00, 0xffffff80, 0xffffffc0, 0xffffffe0, 0xfffffff0, 0xfffffff8,
        0xfffffffc, 0xfffffffe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
        0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
        0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
        0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
        0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
        0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};

/* Number of clock cycles to use for exception processing.
 * I used 4 for any vectors that are undocumented for processing times.
 */
const uint8 m68ki_exception_cycle_table[5][256] =
    {
        {    /* 000 */
         40, /*  0: Reset - Initial Stack Pointer                      */
         4,  /*  1: Reset - Initial Program Counter                    */
         50, /*  2: Bus Error                             (unemulated) */
         50, /*  3: Address Error                         (unemulated) */
         34, /*  4: Illegal Instruction                                */
         38, /*  5: Divide by Zero                                     */
         40, /*  6: CHK                                                */
         34, /*  7: TRAPV                                              */
         34, /*  8: Privilege Violation                                */
         34, /*  9: Trace                                              */
         34, /* 10: 1010                                               */
         34, /* 11: 1111                                               */
         4,  /* 12: RESERVED                                           */
         4,  /* 13: Coprocessor Protocol Violation        (unemulated) */
         4,  /* 14: Format Error                                       */
         44, /* 15: Uninitialized Interrupt                            */
         4,  /* 16: RESERVED                                           */
         4,  /* 17: RESERVED                                           */
         4,  /* 18: RESERVED                                           */
         4,  /* 19: RESERVED                                           */
         4,  /* 20: RESERVED                                           */
         4,  /* 21: RESERVED                                           */
         4,  /* 22: RESERVED                                           */
         4,  /* 23: RESERVED                                           */
         44, /* 24: Spurious Interrupt                                 */
         44, /* 25: Level 1 Interrupt Autovector                       */
         44, /* 26: Level 2 Interrupt Autovector                       */
         44, /* 27: Level 3 Interrupt Autovector                       */
         44, /* 28: Level 4 Interrupt Autovector                       */
         44, /* 29: Level 5 Interrupt Autovector                       */
         44, /* 30: Level 6 Interrupt Autovector                       */
         44, /* 31: Level 7 Interrupt Autovector                       */
         34, /* 32: TRAP #0                                            */
         34, /* 33: TRAP #1                                            */
         34, /* 34: TRAP #2                                            */
         34, /* 35: TRAP #3                                            */
         34, /* 36: TRAP #4                                            */
         34, /* 37: TRAP #5                                            */
         34, /* 38: TRAP #6                                            */
         34, /* 39: TRAP #7                                            */
         34, /* 40: TRAP #8                                            */
         34, /* 41: TRAP #9                                            */
         34, /* 42: TRAP #10                                           */
         34, /* 43: TRAP #11                                           */
         34, /* 44: TRAP #12                                           */
         34, /* 45: TRAP #13                                           */
         34, /* 46: TRAP #14                                           */
         34, /* 47: TRAP #15                                           */
         4,  /* 48: FP Branch or Set on Unknown Condition (unemulated) */
         4,  /* 49: FP Inexact Result                     (unemulated) */
         4,  /* 50: FP Divide by Zero                     (unemulated) */
         4,  /* 51: FP Underflow                          (unemulated) */
         4,  /* 52: FP Operand Error                      (unemulated) */
         4,  /* 53: FP Overflow                           (unemulated) */
         4,  /* 54: FP Signaling NAN                      (unemulated) */
         4,  /* 55: FP Unimplemented Data Type            (unemulated) */
         4,  /* 56: MMU Configuration Error               (unemulated) */
         4,  /* 57: MMU Illegal Operation Error           (unemulated) */
         4,  /* 58: MMU Access Level Violation Error      (unemulated) */
         4,  /* 59: RESERVED                                           */
         4,  /* 60: RESERVED                                           */
         4,  /* 61: RESERVED                                           */
         4,  /* 62: RESERVED                                           */
         4,  /* 63: RESERVED                                           */
         /* 64-255: User Defined                                   */
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
        {     /* 010 */
         40,  /*  0: Reset - Initial Stack Pointer                      */
         4,   /*  1: Reset - Initial Program Counter                    */
         126, /*  2: Bus Error                             (unemulated) */
         126, /*  3: Address Error                         (unemulated) */
         38,  /*  4: Illegal Instruction                                */
         44,  /*  5: Divide by Zero                                     */
         44,  /*  6: CHK                                                */
         34,  /*  7: TRAPV                                              */
         38,  /*  8: Privilege Violation                                */
         38,  /*  9: Trace                                              */
         4,   /* 10: 1010                                               */
         4,   /* 11: 1111                                               */
         4,   /* 12: RESERVED                                           */
         4,   /* 13: Coprocessor Protocol Violation        (unemulated) */
         4,   /* 14: Format Error                                       */
         44,  /* 15: Uninitialized Interrupt                            */
         4,   /* 16: RESERVED                                           */
         4,   /* 17: RESERVED                                           */
         4,   /* 18: RESERVED                                           */
         4,   /* 19: RESERVED                                           */
         4,   /* 20: RESERVED                                           */
         4,   /* 21: RESERVED                                           */
         4,   /* 22: RESERVED                                           */
         4,   /* 23: RESERVED                                           */
         46,  /* 24: Spurious Interrupt                                 */
         46,  /* 25: Level 1 Interrupt Autovector                       */
         46,  /* 26: Level 2 Interrupt Autovector                       */
         46,  /* 27: Level 3 Interrupt Autovector                       */
         46,  /* 28: Level 4 Interrupt Autovector                       */
         46,  /* 29: Level 5 Interrupt Autovector                       */
         46,  /* 30: Level 6 Interrupt Autovector                       */
         46,  /* 31: Level 7 Interrupt Autovector                       */
         38,  /* 32: TRAP #0                                            */
         38,  /* 33: TRAP #1                                            */
         38,  /* 34: TRAP #2                                            */
         38,  /* 35: TRAP #3                                            */
         38,  /* 36: TRAP #4                                            */
         38,  /* 37: TRAP #5                                            */
         38,  /* 38: TRAP #6                                            */
         38,  /* 39: TRAP #7                                            */
         38,  /* 40: TRAP #8                                            */
         38,  /* 41: TRAP #9                                            */
         38,  /* 42: TRAP #10                                           */
         38,  /* 43: TRAP #11                                           */
         38,  /* 44: TRAP #12                                           */
         38,  /* 45: TRAP #13                                           */
         38,  /* 46: TRAP #14                                           */
         38,  /* 47: TRAP #15                                           */
         4,   /* 48: FP Branch or Set on Unknown Condition (unemulated) */
         4,   /* 49: FP Inexact Result                     (unemulated) */
         4,   /* 50: FP Divide by Zero                     (unemulated) */
         4,   /* 51: FP Underflow                          (unemulated) */
         4,   /* 52: FP Operand Error                      (unemulated) */
         4,   /* 53: FP Overflow                           (unemulated) */
         4,   /* 54: FP Signaling NAN                      (unemulated) */
         4,   /* 55: FP Unimplemented Data Type            (unemulated) */
         4,   /* 56: MMU Configuration Error               (unemulated) */
         4,   /* 57: MMU Illegal Operation Error           (unemulated) */
         4,   /* 58: MMU Access Level Violation Error      (unemulated) */
         4,   /* 59: RESERVED                                           */
         4,   /* 60: RESERVED                                           */
         4,   /* 61: RESERVED                                           */
         4,   /* 62: RESERVED                                           */
         4,   /* 63: RESERVED                                           */
              /* 64-255: User Defined                                   */
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
        {    /* 020 */
         4,  /*  0: Reset - Initial Stack Pointer                      */
         4,  /*  1: Reset - Initial Program Counter                    */
         50, /*  2: Bus Error                             (unemulated) */
         50, /*  3: Address Error                         (unemulated) */
         20, /*  4: Illegal Instruction                                */
         38, /*  5: Divide by Zero                                     */
         40, /*  6: CHK                                                */
         20, /*  7: TRAPV                                              */
         34, /*  8: Privilege Violation                                */
         25, /*  9: Trace                                              */
         20, /* 10: 1010                                               */
         20, /* 11: 1111                                               */
         4,  /* 12: RESERVED                                           */
         4,  /* 13: Coprocessor Protocol Violation        (unemulated) */
         4,  /* 14: Format Error                                       */
         30, /* 15: Uninitialized Interrupt                            */
         4,  /* 16: RESERVED                                           */
         4,  /* 17: RESERVED                                           */
         4,  /* 18: RESERVED                                           */
         4,  /* 19: RESERVED                                           */
         4,  /* 20: RESERVED                                           */
         4,  /* 21: RESERVED                                           */
         4,  /* 22: RESERVED                                           */
         4,  /* 23: RESERVED                                           */
         30, /* 24: Spurious Interrupt                                 */
         30, /* 25: Level 1 Interrupt Autovector                       */
         30, /* 26: Level 2 Interrupt Autovector                       */
         30, /* 27: Level 3 Interrupt Autovector                       */
         30, /* 28: Level 4 Interrupt Autovector                       */
         30, /* 29: Level 5 Interrupt Autovector                       */
         30, /* 30: Level 6 Interrupt Autovector                       */
         30, /* 31: Level 7 Interrupt Autovector                       */
         20, /* 32: TRAP #0                                            */
         20, /* 33: TRAP #1                                            */
         20, /* 34: TRAP #2                                            */
         20, /* 35: TRAP #3                                            */
         20, /* 36: TRAP #4                                            */
         20, /* 37: TRAP #5                                            */
         20, /* 38: TRAP #6                                            */
         20, /* 39: TRAP #7                                            */
         20, /* 40: TRAP #8                                            */
         20, /* 41: TRAP #9                                            */
         20, /* 42: TRAP #10                                           */
         20, /* 43: TRAP #11                                           */
         20, /* 44: TRAP #12                                           */
         20, /* 45: TRAP #13                                           */
         20, /* 46: TRAP #14                                           */
         20, /* 47: TRAP #15                                           */
         4,  /* 48: FP Branch or Set on Unknown Condition (unemulated) */
         4,  /* 49: FP Inexact Result                     (unemulated) */
         4,  /* 50: FP Divide by Zero                     (unemulated) */
         4,  /* 51: FP Underflow                          (unemulated) */
         4,  /* 52: FP Operand Error                      (unemulated) */
         4,  /* 53: FP Overflow                           (unemulated) */
         4,  /* 54: FP Signaling NAN                      (unemulated) */
         4,  /* 55: FP Unimplemented Data Type            (unemulated) */
         4,  /* 56: MMU Configuration Error               (unemulated) */
         4,  /* 57: MMU Illegal Operation Error           (unemulated) */
         4,  /* 58: MMU Access Level Violation Error      (unemulated) */
         4,  /* 59: RESERVED                                           */
         4,  /* 60: RESERVED                                           */
         4,  /* 61: RESERVED                                           */
         4,  /* 62: RESERVED                                           */
         4,  /* 63: RESERVED                                           */
         /* 64-255: User Defined                                   */
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
        {    /* 030 - not correct */
         4,  /*  0: Reset - Initial Stack Pointer                      */
         4,  /*  1: Reset - Initial Program Counter                    */
         50, /*  2: Bus Error                             (unemulated) */
         50, /*  3: Address Error                         (unemulated) */
         20, /*  4: Illegal Instruction                                */
         38, /*  5: Divide by Zero                                     */
         40, /*  6: CHK                                                */
         20, /*  7: TRAPV                                              */
         34, /*  8: Privilege Violation                                */
         25, /*  9: Trace                                              */
         20, /* 10: 1010                                               */
         20, /* 11: 1111                                               */
         4,  /* 12: RESERVED                                           */
         4,  /* 13: Coprocessor Protocol Violation        (unemulated) */
         4,  /* 14: Format Error                                       */
         30, /* 15: Uninitialized Interrupt                            */
         4,  /* 16: RESERVED                                           */
         4,  /* 17: RESERVED                                           */
         4,  /* 18: RESERVED                                           */
         4,  /* 19: RESERVED                                           */
         4,  /* 20: RESERVED                                           */
         4,  /* 21: RESERVED                                           */
         4,  /* 22: RESERVED                                           */
         4,  /* 23: RESERVED                                           */
         30, /* 24: Spurious Interrupt                                 */
         30, /* 25: Level 1 Interrupt Autovector                       */
         30, /* 26: Level 2 Interrupt Autovector                       */
         30, /* 27: Level 3 Interrupt Autovector                       */
         30, /* 28: Level 4 Interrupt Autovector                       */
         30, /* 29: Level 5 Interrupt Autovector                       */
         30, /* 30: Level 6 Interrupt Autovector                       */
         30, /* 31: Level 7 Interrupt Autovector                       */
         20, /* 32: TRAP #0                                            */
         20, /* 33: TRAP #1                                            */
         20, /* 34: TRAP #2                                            */
         20, /* 35: TRAP #3                                            */
         20, /* 36: TRAP #4                                            */
         20, /* 37: TRAP #5                                            */
         20, /* 38: TRAP #6                                            */
         20, /* 39: TRAP #7                                            */
         20, /* 40: TRAP #8                                            */
         20, /* 41: TRAP #9                                            */
         20, /* 42: TRAP #10                                           */
         20, /* 43: TRAP #11                                           */
         20, /* 44: TRAP #12                                           */
         20, /* 45: TRAP #13                                           */
         20, /* 46: TRAP #14                                           */
         20, /* 47: TRAP #15                                           */
         4,  /* 48: FP Branch or Set on Unknown Condition (unemulated) */
         4,  /* 49: FP Inexact Result                     (unemulated) */
         4,  /* 50: FP Divide by Zero                     (unemulated) */
         4,  /* 51: FP Underflow                          (unemulated) */
         4,  /* 52: FP Operand Error                      (unemulated) */
         4,  /* 53: FP Overflow                           (unemulated) */
         4,  /* 54: FP Signaling NAN                      (unemulated) */
         4,  /* 55: FP Unimplemented Data Type            (unemulated) */
         4,  /* 56: MMU Configuration Error               (unemulated) */
         4,  /* 57: MMU Illegal Operation Error           (unemulated) */
         4,  /* 58: MMU Access Level Violation Error      (unemulated) */
         4,  /* 59: RESERVED                                           */
         4,  /* 60: RESERVED                                           */
         4,  /* 61: RESERVED                                           */
         4,  /* 62: RESERVED                                           */
         4,  /* 63: RESERVED                                           */
         /* 64-255: User Defined                                   */
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
        {/* 040 */ // TODO: these values are not correct
         4,        /*  0: Reset - Initial Stack Pointer                      */
         4,        /*  1: Reset - Initial Program Counter                    */
         50,       /*  2: Bus Error                             (unemulated) */
         50,       /*  3: Address Error                         (unemulated) */
         20,       /*  4: Illegal Instruction                                */
         38,       /*  5: Divide by Zero                                     */
         40,       /*  6: CHK                                                */
         20,       /*  7: TRAPV                                              */
         34,       /*  8: Privilege Violation                                */
         25,       /*  9: Trace                                              */
         20,       /* 10: 1010                                               */
         20,       /* 11: 1111                                               */
         4,        /* 12: RESERVED                                           */
         4,        /* 13: Coprocessor Protocol Violation        (unemulated) */
         4,        /* 14: Format Error                                       */
         30,       /* 15: Uninitialized Interrupt                            */
         4,        /* 16: RESERVED                                           */
         4,        /* 17: RESERVED                                           */
         4,        /* 18: RESERVED                                           */
         4,        /* 19: RESERVED                                           */
         4,        /* 20: RESERVED                                           */
         4,        /* 21: RESERVED                                           */
         4,        /* 22: RESERVED                                           */
         4,        /* 23: RESERVED                                           */
         30,       /* 24: Spurious Interrupt                                 */
         30,       /* 25: Level 1 Interrupt Autovector                       */
         30,       /* 26: Level 2 Interrupt Autovector                       */
         30,       /* 27: Level 3 Interrupt Autovector                       */
         30,       /* 28: Level 4 Interrupt Autovector                       */
         30,       /* 29: Level 5 Interrupt Autovector                       */
         30,       /* 30: Level 6 Interrupt Autovector                       */
         30,       /* 31: Level 7 Interrupt Autovector                       */
         20,       /* 32: TRAP #0                                            */
         20,       /* 33: TRAP #1                                            */
         20,       /* 34: TRAP #2                                            */
         20,       /* 35: TRAP #3                                            */
         20,       /* 36: TRAP #4                                            */
         20,       /* 37: TRAP #5                                            */
         20,       /* 38: TRAP #6                                            */
         20,       /* 39: TRAP #7                                            */
         20,       /* 40: TRAP #8                                            */
         20,       /* 41: TRAP #9                                            */
         20,       /* 42: TRAP #10                                           */
         20,       /* 43: TRAP #11                                           */
         20,       /* 44: TRAP #12                                           */
         20,       /* 45: TRAP #13                                           */
         20,       /* 46: TRAP #14                                           */
         20,       /* 47: TRAP #15                                           */
         4,        /* 48: FP Branch or Set on Unknown Condition (unemulated) */
         4,        /* 49: FP Inexact Result                     (unemulated) */
         4,        /* 50: FP Divide by Zero                     (unemulated) */
         4,        /* 51: FP Underflow                          (unemulated) */
         4,        /* 52: FP Operand Error                      (unemulated) */
         4,        /* 53: FP Overflow                           (unemulated) */
         4,        /* 54: FP Signaling NAN                      (unemulated) */
         4,        /* 55: FP Unimplemented Data Type            (unemulated) */
         4,        /* 56: MMU Configuration Error               (unemulated) */
         4,        /* 57: MMU Illegal Operation Error           (unemulated) */
         4,        /* 58: MMU Access Level Violation Error      (unemulated) */
         4,        /* 59: RESERVED                                           */
         4,        /* 60: RESERVED                                           */
         4,        /* 61: RESERVED                                           */
         4,        /* 62: RESERVED                                           */
         4,        /* 63: RESERVED                                           */
                   /* 64-255: User Defined                                   */
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4}};

const uint8 m68ki_ea_idx_cycle_table[64] =
    {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, /* ..01.000 no memory indirect, base NULL             */
        5, /* ..01..01 memory indirect,    base NULL, outer NULL */
        7, /* ..01..10 memory indirect,    base NULL, outer 16   */
        7, /* ..01..11 memory indirect,    base NULL, outer 32   */
        0, 5, 7, 7, 0, 5, 7, 7, 0, 5, 7, 7,
        2, /* ..10.000 no memory indirect, base 16               */
        7, /* ..10..01 memory indirect,    base 16,   outer NULL */
        9, /* ..10..10 memory indirect,    base 16,   outer 16   */
        9, /* ..10..11 memory indirect,    base 16,   outer 32   */
        0, 7, 9, 9, 0, 7, 9, 9, 0, 7, 9, 9,
        6,  /* ..11.000 no memory indirect, base 32               */
        11, /* ..11..01 memory indirect,    base 32,   outer NULL */
        13, /* ..11..10 memory indirect,    base 32,   outer 16   */
        13, /* ..11..11 memory indirect,    base 32,   outer 32   */
        0, 11, 13, 13, 0, 11, 13, 13, 0, 11, 13, 13};

/* ======================================================================== */
/* =============================== CALLBACKS ============================== */
/* ======================================================================== */

/* Default callbacks used if the callback hasn't been set yet, or if the
 * callback is set to NULL
 */

/* Interrupt acknowledge */
static int default_int_ack_callback_data;
static int default_int_ack_callback(int int_level)
{
    default_int_ack_callback_data = int_level;
    CPU_INT_LEVEL = 0;
    return M68K_INT_ACK_AUTOVECTOR;
}

/* Breakpoint acknowledge */
static unsigned int default_bkpt_ack_callback_data;
static void default_bkpt_ack_callback(unsigned int data)
{
    default_bkpt_ack_callback_data = data;
}

/* Called when a reset instruction is executed */
static void default_reset_instr_callback(void)
{
}

/* Called when a cmpi.l #v, dn instruction is executed */
static void default_cmpild_instr_callback(unsigned int val, int reg)
{
    (void)val;
    (void)reg;
}

/* Called when a rte instruction is executed */
static void default_rte_instr_callback(void)
{
}

/* Called when a tas instruction is executed */
static int default_tas_instr_callback(void)
{
    return 1; // allow writeback
}

/* Called when an illegal instruction is encountered */
static int default_illg_instr_callback(int opcode)
{
    (void)opcode;
    return 0; // not handled : exception will occur
}

/* Called when the program counter changed by a large value */
static unsigned int default_pc_changed_callback_data;
static void default_pc_changed_callback(unsigned int new_pc)
{
    default_pc_changed_callback_data = new_pc;
}

/* Called every time there's bus activity (read/write to/from memory */
static unsigned int default_set_fc_callback_data;
static void default_set_fc_callback(unsigned int new_fc)
{
    default_set_fc_callback_data = new_fc;
}

/* Called every instruction cycle prior to execution */
static void default_instr_hook_callback(unsigned int pc)
{
    (void)pc;
}

#if M68K_EMULATE_ADDRESS_ERROR
#include <setjmp.h>
#ifdef _BSD_SETJMP_H
sigjmp_buf m68ki_aerr_trap;
#else
jmp_buf m68ki_aerr_trap;
#endif
#endif /* M68K_EMULATE_ADDRESS_ERROR */

/* ======================================================================== */
/* ================================= API ================================== */
/* ======================================================================== */

/* Access the internals of the CPU */
unsigned int m68k_get_reg(void* context, m68k_register_t regnum)
{
    m68ki_cpu_core* cpu = context != NULL ? (m68ki_cpu_core*)context : &m68ki_cpu;

    switch (regnum) {
        case M68K_REG_D0:
            return cpu->dar[0];
        case M68K_REG_D1:
            return cpu->dar[1];
        case M68K_REG_D2:
            return cpu->dar[2];
        case M68K_REG_D3:
            return cpu->dar[3];
        case M68K_REG_D4:
            return cpu->dar[4];
        case M68K_REG_D5:
            return cpu->dar[5];
        case M68K_REG_D6:
            return cpu->dar[6];
        case M68K_REG_D7:
            return cpu->dar[7];
        case M68K_REG_A0:
            return cpu->dar[8];
        case M68K_REG_A1:
            return cpu->dar[9];
        case M68K_REG_A2:
            return cpu->dar[10];
        case M68K_REG_A3:
            return cpu->dar[11];
        case M68K_REG_A4:
            return cpu->dar[12];
        case M68K_REG_A5:
            return cpu->dar[13];
        case M68K_REG_A6:
            return cpu->dar[14];
        case M68K_REG_A7:
            return cpu->dar[15];
        case M68K_REG_PC:
            return MASK_OUT_ABOVE_32(cpu->pc);
        case M68K_REG_SR:
            return cpu->t1_flag |
                   cpu->t0_flag |
                   (cpu->s_flag << 11) |
                   (cpu->m_flag << 11) |
                   cpu->int_mask |
                   ((cpu->x_flag & XFLAG_SET) >> 4) |
                   ((cpu->n_flag & NFLAG_SET) >> 4) |
                   ((!cpu->not_z_flag) << 2) |
                   ((cpu->v_flag & VFLAG_SET) >> 6) |
                   ((cpu->c_flag & CFLAG_SET) >> 8);
        case M68K_REG_SP:
            return cpu->dar[15];
        case M68K_REG_USP:
            return cpu->s_flag ? cpu->sp[0] : cpu->dar[15];
        case M68K_REG_ISP:
            return cpu->s_flag && !cpu->m_flag ? cpu->dar[15] : cpu->sp[4];
        case M68K_REG_MSP:
            return cpu->s_flag && cpu->m_flag ? cpu->dar[15] : cpu->sp[6];
        case M68K_REG_SFC:
            return cpu->sfc;
        case M68K_REG_DFC:
            return cpu->dfc;
        case M68K_REG_VBR:
            return cpu->vbr;
        case M68K_REG_CACR:
            return cpu->cacr;
        case M68K_REG_CAAR:
            return cpu->caar;
        case M68K_REG_PREF_ADDR:
            return cpu->pref_addr;
        case M68K_REG_PREF_DATA:
            return cpu->pref_data;
        case M68K_REG_PPC:
            return MASK_OUT_ABOVE_32(cpu->ppc);
        case M68K_REG_IR:
            return cpu->ir;
        case M68K_REG_CPU_TYPE:
            switch (cpu->cpu_type) {
                case CPU_TYPE_000:
                    return (unsigned int)M68K_CPU_TYPE_68000;
                case CPU_TYPE_010:
                    return (unsigned int)M68K_CPU_TYPE_68010;
                case CPU_TYPE_EC020:
                    return (unsigned int)M68K_CPU_TYPE_68EC020;
                case CPU_TYPE_020:
                    return (unsigned int)M68K_CPU_TYPE_68020;
                case CPU_TYPE_040:
                    return (unsigned int)M68K_CPU_TYPE_68040;
            }
            return M68K_CPU_TYPE_INVALID;
        default:
            return 0;
    }
    return 0;
}

void m68k_set_reg(m68k_register_t regnum, unsigned int value)
{
    switch (regnum) {
        case M68K_REG_D0:
            REG_D[0] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_D1:
            REG_D[1] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_D2:
            REG_D[2] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_D3:
            REG_D[3] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_D4:
            REG_D[4] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_D5:
            REG_D[5] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_D6:
            REG_D[6] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_D7:
            REG_D[7] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_A0:
            REG_A[0] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_A1:
            REG_A[1] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_A2:
            REG_A[2] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_A3:
            REG_A[3] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_A4:
            REG_A[4] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_A5:
            REG_A[5] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_A6:
            REG_A[6] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_A7:
            REG_A[7] = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_PC:
            m68ki_jump(MASK_OUT_ABOVE_32(value));
            return;
        case M68K_REG_SR:
            m68ki_set_sr_noint_nosp(value);
            return;
        case M68K_REG_SP:
            REG_SP = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_USP:
            if (FLAG_S) {
                REG_USP = MASK_OUT_ABOVE_32(value);
            } else {
                REG_SP = MASK_OUT_ABOVE_32(value);
            }
            return;
        case M68K_REG_ISP:
            if (FLAG_S && !FLAG_M) {
                REG_SP = MASK_OUT_ABOVE_32(value);
            } else {
                REG_ISP = MASK_OUT_ABOVE_32(value);
            }
            return;
        case M68K_REG_MSP:
            if (FLAG_S && FLAG_M) {
                REG_SP = MASK_OUT_ABOVE_32(value);
            } else {
                REG_MSP = MASK_OUT_ABOVE_32(value);
            }
            return;
        case M68K_REG_VBR:
            REG_VBR = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_SFC:
            REG_SFC = value & 7;
            return;
        case M68K_REG_DFC:
            REG_DFC = value & 7;
            return;
        case M68K_REG_CACR:
            REG_CACR = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_CAAR:
            REG_CAAR = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_PPC:
            REG_PPC = MASK_OUT_ABOVE_32(value);
            return;
        case M68K_REG_IR:
            REG_IR = MASK_OUT_ABOVE_16(value);
            return;
        case M68K_REG_CPU_TYPE:
            m68k_set_cpu_type(value);
            return;
        default:
            return;
    }
}

/* Set the callbacks */
void m68k_set_int_ack_callback(int (*callback)(int int_level))
{
    CALLBACK_INT_ACK = callback ? callback : default_int_ack_callback;
}

void m68k_set_bkpt_ack_callback(void (*callback)(unsigned int data))
{
    CALLBACK_BKPT_ACK = callback ? callback : default_bkpt_ack_callback;
}

void m68k_set_reset_instr_callback(void (*callback)(void))
{
    CALLBACK_RESET_INSTR = callback ? callback : default_reset_instr_callback;
}

void m68k_set_cmpild_instr_callback(void (*callback)(unsigned int, int))
{
    CALLBACK_CMPILD_INSTR = callback ? callback : default_cmpild_instr_callback;
}

void m68k_set_rte_instr_callback(void (*callback)(void))
{
    CALLBACK_RTE_INSTR = callback ? callback : default_rte_instr_callback;
}

void m68k_set_tas_instr_callback(int (*callback)(void))
{
    CALLBACK_TAS_INSTR = callback ? callback : default_tas_instr_callback;
}

void m68k_set_illg_instr_callback(int (*callback)(int))
{
    CALLBACK_ILLG_INSTR = callback ? callback : default_illg_instr_callback;
}

void m68k_set_pc_changed_callback(void (*callback)(unsigned int new_pc))
{
    CALLBACK_PC_CHANGED = callback ? callback : default_pc_changed_callback;
}

void m68k_set_fc_callback(void (*callback)(unsigned int new_fc))
{
    CALLBACK_SET_FC = callback ? callback : default_set_fc_callback;
}

void m68k_set_instr_hook_callback(void (*callback)(unsigned int pc))
{
    CALLBACK_INSTR_HOOK = callback ? callback : default_instr_hook_callback;
}

/* Set the CPU type. */
void m68k_set_cpu_type(unsigned int cpu_type)
{
    switch (cpu_type) {
        case M68K_CPU_TYPE_68000:
            CPU_TYPE = CPU_TYPE_000;
            CPU_ADDRESS_MASK = 0x00ffffff;
            CPU_SR_MASK = 0xa71f; /* T1 -- S  -- -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
            CYC_INSTRUCTION = m68ki_cycles[0];
            CYC_EXCEPTION = m68ki_exception_cycle_table[0];
            CYC_BCC_NOTAKE_B = -2;
            CYC_BCC_NOTAKE_W = 2;
            CYC_DBCC_F_NOEXP = -2;
            CYC_DBCC_F_EXP = 2;
            CYC_SCC_R_TRUE = 2;
            CYC_MOVEM_W = 2;
            CYC_MOVEM_L = 3;
            CYC_SHIFT = 1;
            CYC_RESET = 132;
            HAS_PMMU = 0;
            return;
        case M68K_CPU_TYPE_SCC68070:
            m68k_set_cpu_type(M68K_CPU_TYPE_68010);
            CPU_ADDRESS_MASK = 0xffffffff;
            CPU_TYPE = CPU_TYPE_SCC070;
            return;
        case M68K_CPU_TYPE_68010:
            CPU_TYPE = CPU_TYPE_010;
            CPU_ADDRESS_MASK = 0x00ffffff;
            CPU_SR_MASK = 0xa71f; /* T1 -- S  -- -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
            CYC_INSTRUCTION = m68ki_cycles[1];
            CYC_EXCEPTION = m68ki_exception_cycle_table[1];
            CYC_BCC_NOTAKE_B = -4;
            CYC_BCC_NOTAKE_W = 0;
            CYC_DBCC_F_NOEXP = 0;
            CYC_DBCC_F_EXP = 6;
            CYC_SCC_R_TRUE = 0;
            CYC_MOVEM_W = 2;
            CYC_MOVEM_L = 3;
            CYC_SHIFT = 1;
            CYC_RESET = 130;
            HAS_PMMU = 0;
            return;
        case M68K_CPU_TYPE_68EC020:
            CPU_TYPE = CPU_TYPE_EC020;
            CPU_ADDRESS_MASK = 0x00ffffff;
            CPU_SR_MASK = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
            CYC_INSTRUCTION = m68ki_cycles[2];
            CYC_EXCEPTION = m68ki_exception_cycle_table[2];
            CYC_BCC_NOTAKE_B = -2;
            CYC_BCC_NOTAKE_W = 0;
            CYC_DBCC_F_NOEXP = 0;
            CYC_DBCC_F_EXP = 4;
            CYC_SCC_R_TRUE = 0;
            CYC_MOVEM_W = 2;
            CYC_MOVEM_L = 2;
            CYC_SHIFT = 0;
            CYC_RESET = 518;
            HAS_PMMU = 0;
            return;
        case M68K_CPU_TYPE_68020:
            CPU_TYPE = CPU_TYPE_020;
            CPU_ADDRESS_MASK = 0xffffffff;
            CPU_SR_MASK = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
            CYC_INSTRUCTION = m68ki_cycles[2];
            CYC_EXCEPTION = m68ki_exception_cycle_table[2];
            CYC_BCC_NOTAKE_B = -2;
            CYC_BCC_NOTAKE_W = 0;
            CYC_DBCC_F_NOEXP = 0;
            CYC_DBCC_F_EXP = 4;
            CYC_SCC_R_TRUE = 0;
            CYC_MOVEM_W = 2;
            CYC_MOVEM_L = 2;
            CYC_SHIFT = 0;
            CYC_RESET = 518;
            HAS_PMMU = 0;
            return;
        case M68K_CPU_TYPE_68030:
            CPU_TYPE = CPU_TYPE_030;
            CPU_ADDRESS_MASK = 0xffffffff;
            CPU_SR_MASK = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
            CYC_INSTRUCTION = m68ki_cycles[3];
            CYC_EXCEPTION = m68ki_exception_cycle_table[3];
            CYC_BCC_NOTAKE_B = -2;
            CYC_BCC_NOTAKE_W = 0;
            CYC_DBCC_F_NOEXP = 0;
            CYC_DBCC_F_EXP = 4;
            CYC_SCC_R_TRUE = 0;
            CYC_MOVEM_W = 2;
            CYC_MOVEM_L = 2;
            CYC_SHIFT = 0;
            CYC_RESET = 518;
            HAS_PMMU = 1;
            return;
        case M68K_CPU_TYPE_68EC030:
            CPU_TYPE = CPU_TYPE_EC030;
            CPU_ADDRESS_MASK = 0xffffffff;
            CPU_SR_MASK = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
            CYC_INSTRUCTION = m68ki_cycles[3];
            CYC_EXCEPTION = m68ki_exception_cycle_table[3];
            CYC_BCC_NOTAKE_B = -2;
            CYC_BCC_NOTAKE_W = 0;
            CYC_DBCC_F_NOEXP = 0;
            CYC_DBCC_F_EXP = 4;
            CYC_SCC_R_TRUE = 0;
            CYC_MOVEM_W = 2;
            CYC_MOVEM_L = 2;
            CYC_SHIFT = 0;
            CYC_RESET = 518;
            HAS_PMMU = 0; /* EC030 lacks the PMMU and is effectively a die-shrink 68020 */
            return;
        case M68K_CPU_TYPE_68040: // TODO: these values are not correct
            CPU_TYPE = CPU_TYPE_040;
            CPU_ADDRESS_MASK = 0xffffffff;
            CPU_SR_MASK = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
            CYC_INSTRUCTION = m68ki_cycles[4];
            CYC_EXCEPTION = m68ki_exception_cycle_table[4];
            CYC_BCC_NOTAKE_B = -2;
            CYC_BCC_NOTAKE_W = 0;
            CYC_DBCC_F_NOEXP = 0;
            CYC_DBCC_F_EXP = 4;
            CYC_SCC_R_TRUE = 0;
            CYC_MOVEM_W = 2;
            CYC_MOVEM_L = 2;
            CYC_SHIFT = 0;
            CYC_RESET = 518;
            HAS_PMMU = 1;
            return;
        case M68K_CPU_TYPE_68EC040: // Just a 68040 without pmmu apparently...
            CPU_TYPE = CPU_TYPE_EC040;
            CPU_ADDRESS_MASK = 0xffffffff;
            CPU_SR_MASK = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
            CYC_INSTRUCTION = m68ki_cycles[4];
            CYC_EXCEPTION = m68ki_exception_cycle_table[4];
            CYC_BCC_NOTAKE_B = -2;
            CYC_BCC_NOTAKE_W = 0;
            CYC_DBCC_F_NOEXP = 0;
            CYC_DBCC_F_EXP = 4;
            CYC_SCC_R_TRUE = 0;
            CYC_MOVEM_W = 2;
            CYC_MOVEM_L = 2;
            CYC_SHIFT = 0;
            CYC_RESET = 518;
            HAS_PMMU = 0;
            return;
        case M68K_CPU_TYPE_68LC040:
            CPU_TYPE = CPU_TYPE_LC040;
            m68ki_cpu.sr_mask = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
            m68ki_cpu.cyc_instruction = m68ki_cycles[4];
            m68ki_cpu.cyc_exception = m68ki_exception_cycle_table[4];
            m68ki_cpu.cyc_bcc_notake_b = -2;
            m68ki_cpu.cyc_bcc_notake_w = 0;
            m68ki_cpu.cyc_dbcc_f_noexp = 0;
            m68ki_cpu.cyc_dbcc_f_exp = 4;
            m68ki_cpu.cyc_scc_r_true = 0;
            m68ki_cpu.cyc_movem_w = 2;
            m68ki_cpu.cyc_movem_l = 2;
            m68ki_cpu.cyc_shift = 0;
            m68ki_cpu.cyc_reset = 518;
            HAS_PMMU = 1;
            return;
    }
}

/* Execute some instructions until we use up num_cycles clock cycles */
/* ASG: removed per-instruction interrupt checks */
M68K_HOT int m68k_execute(int num_cycles)
{
    /* eat up any reset cycles */
    if (M68K_UNLIKELY(RESET_CYCLES)) {
        const int rc = RESET_CYCLES;
        RESET_CYCLES = 0;
        num_cycles -= rc;
        if (M68K_UNLIKELY(num_cycles <= 0)) {
            return rc;
        }
    }

    /* Set our pool of clock cycles available */
    SET_CYCLES(num_cycles);
    m68ki_initial_cycles = num_cycles;

    /* See if interrupts came in */
    m68ki_check_interrupts();

    /* Make sure we're not stopped */
    if (M68K_LIKELY(!CPU_STOPPED)) {
        /* Return point if we had an address error */
        m68ki_set_address_error_trap(); /* auto-disable (see m68kcpu.h) */

        m68ki_check_bus_error_trap();

        void (** const jump_table)(void) = m68ki_instruction_jump_table;
        const uint8* const cyc_instr = CYC_INSTRUCTION;

        /* Main loop.  Keep going until we run out of clock cycles */
        do {
            /* Set tracing accodring to T1. (T0 is done inside instruction) */
            m68ki_trace_t1(); /* auto-disable (see m68kcpu.h) */

            /* Set the address space for reads */
            m68ki_use_data_space(); /* auto-disable (see m68kcpu.h) */

            /* Call external hook to peek at CPU */
            m68ki_instr_hook(REG_PC); /* auto-disable (see m68kcpu.h) */

            /* Record previous program counter */
            REG_PPC = REG_PC;

            /* Record previous D/A register state (in case of bus error) */
            memcpy(m68ki_cpu.dar_save, m68ki_cpu.dar, sizeof m68ki_cpu.dar);

            /* Read an instruction and call its handler */
            REG_IR = m68ki_read_imm_16();
            void (*const handler)(void) = jump_table[REG_IR];
            handler();
            USE_CYCLES(cyc_instr[REG_IR]);

            /* Trace m68k_exception, if necessary */
            m68ki_exception_if_trace(); /* auto-disable (see m68kcpu.h) */
        } while (M68K_LIKELY(GET_CYCLES() > 0));

        /* set previous PC to current PC for the next entry into the loop */
        REG_PPC = REG_PC;
    } else {
        SET_CYCLES(0);
    }

    /* return how many clocks we used */
    return m68ki_initial_cycles - GET_CYCLES();
}

M68K_HOT int m68k_cycles_run(void)
{
    return m68ki_initial_cycles - GET_CYCLES();
}

M68K_HOT int m68k_cycles_remaining(void)
{
    return GET_CYCLES();
}

/* Change the timeslice */
M68K_HOT void m68k_modify_timeslice(int cycles)
{
    m68ki_initial_cycles += cycles;
    ADD_CYCLES(cycles);
}

M68K_HOT void m68k_end_timeslice(void)
{
    m68ki_initial_cycles -= GET_CYCLES();
    SET_CYCLES(0);
}

/* ASG: rewrote so that the int_level is a mask of the IPL0/IPL1/IPL2 bits */
/* KS: Modified so that IPL* bits match with mask positions in the SR
 *     and cleaned out remenants of the interrupt controller.
 */
void m68k_set_irq(unsigned int int_level)
{
    uint old_level = CPU_INT_LEVEL;
    CPU_INT_LEVEL = int_level << 8;

    /* A transition from < 7 to 7 always interrupts (NMI) */
    /* Note: Level 7 can also level trigger like a normal IRQ */
    if (old_level != 0x0700 && CPU_INT_LEVEL == 0x0700) {
        m68ki_cpu.nmi_pending = TRUE;
    }
}

void m68k_set_virq(unsigned int level, unsigned int active)
{
    uint state = m68ki_cpu.virq_state;
    uint blevel;

    if (active) {
        state |= 1 << level;
    } else {
        state &= ~(1 << level);
    }
    m68ki_cpu.virq_state = state;

    for (blevel = 7; blevel > 0; blevel--) {
        if (state & (1 << blevel)) {
            break;
        }
    }
    m68k_set_irq(blevel);
}

unsigned int m68k_get_virq(unsigned int level)
{
    return (m68ki_cpu.virq_state & (1 << level)) ? 1 : 0;
}

void m68k_init(void)
{
    static uint emulation_initialized = 0;

    /* The first call to this function initializes the opcode handler jump table */
    if (!emulation_initialized) {
        m68ki_build_opcode_table();
        emulation_initialized = 1;
    }

    m68k_set_int_ack_callback(NULL);
    m68k_set_bkpt_ack_callback(NULL);
    m68k_set_reset_instr_callback(NULL);
    m68k_set_cmpild_instr_callback(NULL);
    m68k_set_rte_instr_callback(NULL);
    m68k_set_tas_instr_callback(NULL);
    m68k_set_illg_instr_callback(NULL);
    m68k_set_pc_changed_callback(NULL);
    m68k_set_fc_callback(NULL);
    m68k_set_instr_hook_callback(NULL);
}

/* Trigger a Bus Error exception */
void m68k_pulse_bus_error(void)
{
    m68ki_exception_bus_error();
}

/* Pulse the RESET line on the CPU */
void m68k_pulse_reset(void)
{
    /* Disable the PMMU on reset */
    m68ki_cpu.pmmu_enabled = 0;

    /* Clear all stop levels and eat up all remaining cycles */
    CPU_STOPPED = 0;
    SET_CYCLES(0);

    CPU_RUN_MODE = RUN_MODE_BERR_AERR_RESET;
    CPU_INSTR_MODE = INSTRUCTION_YES;

    /* Turn off tracing */
    FLAG_T1 = FLAG_T0 = 0;
    m68ki_clear_trace();
    /* Interrupt mask to level 7 */
    FLAG_INT_MASK = 0x0700;
    CPU_INT_LEVEL = 0;
    m68ki_cpu.virq_state = 0;
    /* Reset VBR */
    REG_VBR = 0;
    /* Go to supervisor mode */
    m68ki_set_sm_flag(SFLAG_SET | MFLAG_CLEAR);

    /* Invalidate the prefetch queue */
#if M68K_EMULATE_PREFETCH
    /* Set to arbitrary number since our first fetch is from 0 */
    CPU_PREF_ADDR = 0x1000;
#endif /* M68K_EMULATE_PREFETCH */

    /* Read the initial stack pointer and program counter */
    m68ki_jump(0);
    REG_SP = m68ki_read_imm_32();
    REG_PC = m68ki_read_imm_32();
    m68ki_jump(REG_PC);

    CPU_RUN_MODE = RUN_MODE_NORMAL;

    RESET_CYCLES = CYC_EXCEPTION[EXCEPTION_RESET];
}

/* Pulse the HALT line on the CPU */
void m68k_pulse_halt(void)
{
    CPU_STOPPED |= STOP_LEVEL_HALT;
}

/* Get and set the current CPU context */
/* This is to allow for multiple CPUs */
unsigned int m68k_context_size(void)
{
    return sizeof(m68ki_cpu_core);
}

unsigned int m68k_get_context(void* dst)
{
    if (dst) {
        *(m68ki_cpu_core*)dst = m68ki_cpu;
    }
    return sizeof(m68ki_cpu_core);
}

void m68k_set_context(void* src)
{
    if (src) {
        m68ki_cpu = *(m68ki_cpu_core*)src;
    }
}

/* ======================================================================== */
/* ============================== MAME STUFF ============================== */
/* ======================================================================== */

#if M68K_COMPILE_FOR_MAME == OPT_ON

static struct
{
    UINT16 sr;
    UINT8 stopped;
    UINT8 halted;
} m68k_substate;

static void m68k_prepare_substate(void)
{
    m68k_substate.sr = m68ki_get_sr();
    m68k_substate.stopped = (CPU_STOPPED & STOP_LEVEL_STOP) != 0;
    m68k_substate.halted = (CPU_STOPPED & STOP_LEVEL_HALT) != 0;
}

static void m68k_post_load(void)
{
    m68ki_set_sr_noint_nosp(m68k_substate.sr);
    CPU_STOPPED = m68k_substate.stopped ? STOP_LEVEL_STOP : 0 | m68k_substate.halted ? STOP_LEVEL_HALT
                                                                                     : 0;
    m68ki_jump(REG_PC);
}

void m68k_state_register(const char* type, int index)
{
    /* Note, D covers A because the dar array is common, REG_A=REG_D+8 */
    state_save_register_item_array(type, index, REG_D);
    state_save_register_item(type, index, REG_PPC);
    state_save_register_item(type, index, REG_PC);
    state_save_register_item(type, index, REG_USP);
    state_save_register_item(type, index, REG_ISP);
    state_save_register_item(type, index, REG_MSP);
    state_save_register_item(type, index, REG_VBR);
    state_save_register_item(type, index, REG_SFC);
    state_save_register_item(type, index, REG_DFC);
    state_save_register_item(type, index, REG_CACR);
    state_save_register_item(type, index, REG_CAAR);
    state_save_register_item(type, index, m68k_substate.sr);
    state_save_register_item(type, index, CPU_INT_LEVEL);
    state_save_register_item(type, index, m68k_substate.stopped);
    state_save_register_item(type, index, m68k_substate.halted);
    state_save_register_item(type, index, CPU_PREF_ADDR);
    state_save_register_item(type, index, CPU_PREF_DATA);
    state_save_register_func_presave(m68k_prepare_substate);
    state_save_register_func_postload(m68k_post_load);
}

#endif /* M68K_COMPILE_FOR_MAME */

/* ======================================================================== */
/* ============================== END OF FILE ============================= */
/* ======================================================================== */
/* -- End embedded musashi/m68kcpu.c -- */

/* -- Begin embedded musashi/m68kops.c -- */
#include <stdio.h>
extern void m68040_fpu_op0(void);
extern void m68040_fpu_op1(void);
extern void m68881_mmu_ops(void);

/* ======================================================================== */
/* ========================= INSTRUCTION HANDLERS ========================= */
/* ======================================================================== */

static void m68k_op_1010(void)
{
    m68ki_exception_1010();
}

static void m68k_op_1111(void)
{
    m68ki_exception_1111();
}

static void m68k_op_040fpu0_32(void)
{
    if (CPU_TYPE_IS_030_PLUS(CPU_TYPE)) {
        m68040_fpu_op0();
        return;
    }
    m68ki_exception_1111();
}

static void m68k_op_040fpu1_32(void)
{
    if (CPU_TYPE_IS_030_PLUS(CPU_TYPE)) {
        m68040_fpu_op1();
        return;
    }
    m68ki_exception_1111();
}

static void m68k_op_abcd_8_rr(void)
{
    uint* r_dst = &DX;
    uint src = DY;
    uint dst = *r_dst;
    uint res = LOW_NIBBLE(src) + LOW_NIBBLE(dst) + XFLAG_AS_1();

    FLAG_V = ~res; /* Undefined V behavior */

    if (res > 9) {
        res += 6;
    }
    res += HIGH_NIBBLE(src) + HIGH_NIBBLE(dst);
    FLAG_X = FLAG_C = (res > 0x99) << 8;
    if (FLAG_C) {
        res -= 0xa0;
    }

    FLAG_V &= res;         /* Undefined V behavior part II */
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;
}

static void m68k_op_abcd_8_mm_ax7(void)
{
    uint src = OPER_AY_PD_8();
    uint ea = EA_A7_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = LOW_NIBBLE(src) + LOW_NIBBLE(dst) + XFLAG_AS_1();

    FLAG_V = ~res; /* Undefined V behavior */

    if (res > 9) {
        res += 6;
    }
    res += HIGH_NIBBLE(src) + HIGH_NIBBLE(dst);
    FLAG_X = FLAG_C = (res > 0x99) << 8;
    if (FLAG_C) {
        res -= 0xa0;
    }

    FLAG_V &= res;         /* Undefined V behavior part II */
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_abcd_8_mm_ay7(void)
{
    uint src = OPER_A7_PD_8();
    uint ea = EA_AX_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = LOW_NIBBLE(src) + LOW_NIBBLE(dst) + XFLAG_AS_1();

    FLAG_V = ~res; /* Undefined V behavior */

    if (res > 9) {
        res += 6;
    }
    res += HIGH_NIBBLE(src) + HIGH_NIBBLE(dst);
    FLAG_X = FLAG_C = (res > 0x99) << 8;
    if (FLAG_C) {
        res -= 0xa0;
    }

    FLAG_V &= res;         /* Undefined V behavior part II */
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_abcd_8_mm_axy7(void)
{
    uint src = OPER_A7_PD_8();
    uint ea = EA_A7_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = LOW_NIBBLE(src) + LOW_NIBBLE(dst) + XFLAG_AS_1();

    FLAG_V = ~res; /* Undefined V behavior */

    if (res > 9) {
        res += 6;
    }
    res += HIGH_NIBBLE(src) + HIGH_NIBBLE(dst);
    FLAG_X = FLAG_C = (res > 0x99) << 8;
    if (FLAG_C) {
        res -= 0xa0;
    }

    FLAG_V &= res;         /* Undefined V behavior part II */
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_abcd_8_mm(void)
{
    uint src = OPER_AY_PD_8();
    uint ea = EA_AX_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = LOW_NIBBLE(src) + LOW_NIBBLE(dst) + XFLAG_AS_1();

    FLAG_V = ~res; /* Undefined V behavior */

    if (res > 9) {
        res += 6;
    }
    res += HIGH_NIBBLE(src) + HIGH_NIBBLE(dst);
    FLAG_X = FLAG_C = (res > 0x99) << 8;
    if (FLAG_C) {
        res -= 0xa0;
    }

    FLAG_V &= res;         /* Undefined V behavior part II */
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_add_8_er_d(void)
{
    uint* r_dst = &DX;
    uint src = MASK_OUT_ABOVE_8(DY);
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_add_8_er_ai(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_AI_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_add_8_er_pi(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_PI_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_add_8_er_pi7(void)
{
    uint* r_dst = &DX;
    uint src = OPER_A7_PI_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_add_8_er_pd(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_PD_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_add_8_er_pd7(void)
{
    uint* r_dst = &DX;
    uint src = OPER_A7_PD_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_add_8_er_di(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_DI_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_add_8_er_ix(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_IX_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_add_8_er_aw(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AW_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_add_8_er_al(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AL_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_add_8_er_pcdi(void)
{
    uint* r_dst = &DX;
    uint src = OPER_PCDI_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_add_8_er_pcix(void)
{
    uint* r_dst = &DX;
    uint src = OPER_PCIX_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_add_8_er_i(void)
{
    uint* r_dst = &DX;
    uint src = OPER_I_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_add_16_er_d(void)
{
    uint* r_dst = &DX;
    uint src = MASK_OUT_ABOVE_16(DY);
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_add_16_er_a(void)
{
    uint* r_dst = &DX;
    uint src = MASK_OUT_ABOVE_16(AY);
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_add_16_er_ai(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_AI_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_add_16_er_pi(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_PI_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_add_16_er_pd(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_PD_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_add_16_er_di(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_DI_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_add_16_er_ix(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_IX_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_add_16_er_aw(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AW_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_add_16_er_al(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AL_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_add_16_er_pcdi(void)
{
    uint* r_dst = &DX;
    uint src = OPER_PCDI_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_add_16_er_pcix(void)
{
    uint* r_dst = &DX;
    uint src = OPER_PCIX_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_add_16_er_i(void)
{
    uint* r_dst = &DX;
    uint src = OPER_I_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_add_32_er_d(void)
{
    uint* r_dst = &DX;
    uint src = DY;
    uint dst = *r_dst;
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_add_32_er_a(void)
{
    uint* r_dst = &DX;
    uint src = AY;
    uint dst = *r_dst;
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_add_32_er_ai(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_AI_32();
    uint dst = *r_dst;
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_add_32_er_pi(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_PI_32();
    uint dst = *r_dst;
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_add_32_er_pd(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_PD_32();
    uint dst = *r_dst;
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_add_32_er_di(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_DI_32();
    uint dst = *r_dst;
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_add_32_er_ix(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_IX_32();
    uint dst = *r_dst;
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_add_32_er_aw(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AW_32();
    uint dst = *r_dst;
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_add_32_er_al(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AL_32();
    uint dst = *r_dst;
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_add_32_er_pcdi(void)
{
    uint* r_dst = &DX;
    uint src = OPER_PCDI_32();
    uint dst = *r_dst;
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_add_32_er_pcix(void)
{
    uint* r_dst = &DX;
    uint src = OPER_PCIX_32();
    uint dst = *r_dst;
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_add_32_er_i(void)
{
    uint* r_dst = &DX;
    uint src = OPER_I_32();
    uint dst = *r_dst;
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_add_8_re_ai(void)
{
    uint ea = EA_AY_AI_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_add_8_re_pi(void)
{
    uint ea = EA_AY_PI_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_add_8_re_pi7(void)
{
    uint ea = EA_A7_PI_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_add_8_re_pd(void)
{
    uint ea = EA_AY_PD_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_add_8_re_pd7(void)
{
    uint ea = EA_A7_PD_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_add_8_re_di(void)
{
    uint ea = EA_AY_DI_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_add_8_re_ix(void)
{
    uint ea = EA_AY_IX_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_add_8_re_aw(void)
{
    uint ea = EA_AW_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_add_8_re_al(void)
{
    uint ea = EA_AL_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_add_16_re_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint src = MASK_OUT_ABOVE_16(DX);
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_add_16_re_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint src = MASK_OUT_ABOVE_16(DX);
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_add_16_re_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint src = MASK_OUT_ABOVE_16(DX);
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_add_16_re_di(void)
{
    uint ea = EA_AY_DI_16();
    uint src = MASK_OUT_ABOVE_16(DX);
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_add_16_re_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint src = MASK_OUT_ABOVE_16(DX);
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_add_16_re_aw(void)
{
    uint ea = EA_AW_16();
    uint src = MASK_OUT_ABOVE_16(DX);
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_add_16_re_al(void)
{
    uint ea = EA_AL_16();
    uint src = MASK_OUT_ABOVE_16(DX);
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_add_32_re_ai(void)
{
    uint ea = EA_AY_AI_32();
    uint src = DX;
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_add_32_re_pi(void)
{
    uint ea = EA_AY_PI_32();
    uint src = DX;
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_add_32_re_pd(void)
{
    uint ea = EA_AY_PD_32();
    uint src = DX;
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_add_32_re_di(void)
{
    uint ea = EA_AY_DI_32();
    uint src = DX;
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_add_32_re_ix(void)
{
    uint ea = EA_AY_IX_32();
    uint src = DX;
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_add_32_re_aw(void)
{
    uint ea = EA_AW_32();
    uint src = DX;
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_add_32_re_al(void)
{
    uint ea = EA_AL_32();
    uint src = DX;
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_adda_16_d(void)
{
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + MAKE_INT_16(DY));
}

static void m68k_op_adda_16_a(void)
{
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + MAKE_INT_16(AY));
}

static void m68k_op_adda_16_ai(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_AY_AI_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_16_pi(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_AY_PI_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_16_pd(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_AY_PD_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_16_di(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_AY_DI_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_16_ix(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_AY_IX_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_16_aw(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_AW_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_16_al(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_AL_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_16_pcdi(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_PCDI_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_16_pcix(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_PCIX_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_16_i(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_I_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_32_d(void)
{
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + DY);
}

static void m68k_op_adda_32_a(void)
{
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + AY);
}

static void m68k_op_adda_32_ai(void)
{
    uint src = OPER_AY_AI_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_32_pi(void)
{
    uint src = OPER_AY_PI_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_32_pd(void)
{
    uint src = OPER_AY_PD_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_32_di(void)
{
    uint src = OPER_AY_DI_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_32_ix(void)
{
    uint src = OPER_AY_IX_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_32_aw(void)
{
    uint src = OPER_AW_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_32_al(void)
{
    uint src = OPER_AL_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_32_pcdi(void)
{
    uint src = OPER_PCDI_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_32_pcix(void)
{
    uint src = OPER_PCIX_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_adda_32_i(void)
{
    uint src = OPER_I_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + src);
}

static void m68k_op_addi_8_d(void)
{
    uint* r_dst = &DY;
    uint src = OPER_I_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_addi_8_ai(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_AI_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addi_8_pi(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_PI_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addi_8_pi7(void)
{
    uint src = OPER_I_8();
    uint ea = EA_A7_PI_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addi_8_pd(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addi_8_pd7(void)
{
    uint src = OPER_I_8();
    uint ea = EA_A7_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addi_8_di(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_DI_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addi_8_ix(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_IX_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addi_8_aw(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AW_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addi_8_al(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AL_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addi_16_d(void)
{
    uint* r_dst = &DY;
    uint src = OPER_I_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_addi_16_ai(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_AI_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_addi_16_pi(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_PI_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_addi_16_pd(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_PD_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_addi_16_di(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_DI_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_addi_16_ix(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_IX_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_addi_16_aw(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AW_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_addi_16_al(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AL_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_addi_32_d(void)
{
    uint* r_dst = &DY;
    uint src = OPER_I_32();
    uint dst = *r_dst;
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_addi_32_ai(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_AI_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_addi_32_pi(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_PI_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_addi_32_pd(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_PD_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_addi_32_di(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_DI_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_addi_32_ix(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_IX_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_addi_32_aw(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AW_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_addi_32_al(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AL_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_addq_8_d(void)
{
    uint* r_dst = &DY;
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_addq_8_ai(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_AI_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addq_8_pi(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_PI_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addq_8_pi7(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_A7_PI_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addq_8_pd(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addq_8_pd7(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_A7_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addq_8_di(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_DI_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addq_8_ix(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_IX_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addq_8_aw(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AW_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addq_8_al(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AL_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_addq_16_d(void)
{
    uint* r_dst = &DY;
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_addq_16_a(void)
{
    uint* r_dst = &AY;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + (((REG_IR >> 9) - 1) & 7) + 1);
}

static void m68k_op_addq_16_ai(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_AI_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_addq_16_pi(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_PI_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_addq_16_pd(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_PD_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_addq_16_di(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_DI_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_addq_16_ix(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_IX_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_addq_16_aw(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AW_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_addq_16_al(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AL_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_addq_32_d(void)
{
    uint* r_dst = &DY;
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint dst = *r_dst;
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_addq_32_a(void)
{
    uint* r_dst = &AY;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst + (((REG_IR >> 9) - 1) & 7) + 1);
}

static void m68k_op_addq_32_ai(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_AI_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_addq_32_pi(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_PI_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_addq_32_pd(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_PD_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_addq_32_di(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_DI_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_addq_32_ix(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_IX_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_addq_32_aw(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AW_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_addq_32_al(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AL_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst;

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_addx_8_rr(void)
{
    uint* r_dst = &DX;
    uint src = MASK_OUT_ABOVE_8(DY);
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src + dst + XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;
}

static void m68k_op_addx_16_rr(void)
{
    uint* r_dst = &DX;
    uint src = MASK_OUT_ABOVE_16(DY);
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src + dst + XFLAG_AS_1();

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);

    res = MASK_OUT_ABOVE_16(res);
    FLAG_Z |= res;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
}

static void m68k_op_addx_32_rr(void)
{
    uint* r_dst = &DX;
    uint src = DY;
    uint dst = *r_dst;
    uint res = src + dst + XFLAG_AS_1();

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);

    res = MASK_OUT_ABOVE_32(res);
    FLAG_Z |= res;

    *r_dst = res;
}

static void m68k_op_addx_8_mm_ax7(void)
{
    uint src = OPER_AY_PD_8();
    uint ea = EA_A7_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst + XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_addx_8_mm_ay7(void)
{
    uint src = OPER_A7_PD_8();
    uint ea = EA_AX_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst + XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_addx_8_mm_axy7(void)
{
    uint src = OPER_A7_PD_8();
    uint ea = EA_A7_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst + XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_addx_8_mm(void)
{
    uint src = OPER_AY_PD_8();
    uint ea = EA_AX_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = src + dst + XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_V = VFLAG_ADD_8(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_8(res);

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_addx_16_mm(void)
{
    uint src = OPER_AY_PD_16();
    uint ea = EA_AX_PD_16();
    uint dst = m68ki_read_16(ea);
    uint res = src + dst + XFLAG_AS_1();

    FLAG_N = NFLAG_16(res);
    FLAG_V = VFLAG_ADD_16(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_16(res);

    res = MASK_OUT_ABOVE_16(res);
    FLAG_Z |= res;

    m68ki_write_16(ea, res);
}

static void m68k_op_addx_32_mm(void)
{
    uint src = OPER_AY_PD_32();
    uint ea = EA_AX_PD_32();
    uint dst = m68ki_read_32(ea);
    uint res = src + dst + XFLAG_AS_1();

    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_ADD_32(src, dst, res);
    FLAG_X = FLAG_C = CFLAG_ADD_32(src, dst, res);

    res = MASK_OUT_ABOVE_32(res);
    FLAG_Z |= res;

    m68ki_write_32(ea, res);
}

static void m68k_op_and_8_er_d(void)
{
    FLAG_Z = MASK_OUT_ABOVE_8(DX &= (DY | 0xffffff00));

    FLAG_N = NFLAG_8(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_8_er_ai(void)
{
    FLAG_Z = MASK_OUT_ABOVE_8(DX &= (OPER_AY_AI_8() | 0xffffff00));

    FLAG_N = NFLAG_8(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_8_er_pi(void)
{
    FLAG_Z = MASK_OUT_ABOVE_8(DX &= (OPER_AY_PI_8() | 0xffffff00));

    FLAG_N = NFLAG_8(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_8_er_pi7(void)
{
    FLAG_Z = MASK_OUT_ABOVE_8(DX &= (OPER_A7_PI_8() | 0xffffff00));

    FLAG_N = NFLAG_8(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_8_er_pd(void)
{
    FLAG_Z = MASK_OUT_ABOVE_8(DX &= (OPER_AY_PD_8() | 0xffffff00));

    FLAG_N = NFLAG_8(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_8_er_pd7(void)
{
    FLAG_Z = MASK_OUT_ABOVE_8(DX &= (OPER_A7_PD_8() | 0xffffff00));

    FLAG_N = NFLAG_8(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_8_er_di(void)
{
    FLAG_Z = MASK_OUT_ABOVE_8(DX &= (OPER_AY_DI_8() | 0xffffff00));

    FLAG_N = NFLAG_8(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_8_er_ix(void)
{
    FLAG_Z = MASK_OUT_ABOVE_8(DX &= (OPER_AY_IX_8() | 0xffffff00));

    FLAG_N = NFLAG_8(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_8_er_aw(void)
{
    FLAG_Z = MASK_OUT_ABOVE_8(DX &= (OPER_AW_8() | 0xffffff00));

    FLAG_N = NFLAG_8(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_8_er_al(void)
{
    FLAG_Z = MASK_OUT_ABOVE_8(DX &= (OPER_AL_8() | 0xffffff00));

    FLAG_N = NFLAG_8(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_8_er_pcdi(void)
{
    FLAG_Z = MASK_OUT_ABOVE_8(DX &= (OPER_PCDI_8() | 0xffffff00));

    FLAG_N = NFLAG_8(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_8_er_pcix(void)
{
    FLAG_Z = MASK_OUT_ABOVE_8(DX &= (OPER_PCIX_8() | 0xffffff00));

    FLAG_N = NFLAG_8(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_8_er_i(void)
{
    FLAG_Z = MASK_OUT_ABOVE_8(DX &= (OPER_I_8() | 0xffffff00));

    FLAG_N = NFLAG_8(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_16_er_d(void)
{
    FLAG_Z = MASK_OUT_ABOVE_16(DX &= (DY | 0xffff0000));

    FLAG_N = NFLAG_16(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_16_er_ai(void)
{
    FLAG_Z = MASK_OUT_ABOVE_16(DX &= (OPER_AY_AI_16() | 0xffff0000));

    FLAG_N = NFLAG_16(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_16_er_pi(void)
{
    FLAG_Z = MASK_OUT_ABOVE_16(DX &= (OPER_AY_PI_16() | 0xffff0000));

    FLAG_N = NFLAG_16(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_16_er_pd(void)
{
    FLAG_Z = MASK_OUT_ABOVE_16(DX &= (OPER_AY_PD_16() | 0xffff0000));

    FLAG_N = NFLAG_16(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_16_er_di(void)
{
    FLAG_Z = MASK_OUT_ABOVE_16(DX &= (OPER_AY_DI_16() | 0xffff0000));

    FLAG_N = NFLAG_16(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_16_er_ix(void)
{
    FLAG_Z = MASK_OUT_ABOVE_16(DX &= (OPER_AY_IX_16() | 0xffff0000));

    FLAG_N = NFLAG_16(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_16_er_aw(void)
{
    FLAG_Z = MASK_OUT_ABOVE_16(DX &= (OPER_AW_16() | 0xffff0000));

    FLAG_N = NFLAG_16(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_16_er_al(void)
{
    FLAG_Z = MASK_OUT_ABOVE_16(DX &= (OPER_AL_16() | 0xffff0000));

    FLAG_N = NFLAG_16(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_16_er_pcdi(void)
{
    FLAG_Z = MASK_OUT_ABOVE_16(DX &= (OPER_PCDI_16() | 0xffff0000));

    FLAG_N = NFLAG_16(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_16_er_pcix(void)
{
    FLAG_Z = MASK_OUT_ABOVE_16(DX &= (OPER_PCIX_16() | 0xffff0000));

    FLAG_N = NFLAG_16(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_16_er_i(void)
{
    FLAG_Z = MASK_OUT_ABOVE_16(DX &= (OPER_I_16() | 0xffff0000));

    FLAG_N = NFLAG_16(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_32_er_d(void)
{
    FLAG_Z = DX &= DY;

    FLAG_N = NFLAG_32(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_32_er_ai(void)
{
    FLAG_Z = DX &= OPER_AY_AI_32();

    FLAG_N = NFLAG_32(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_32_er_pi(void)
{
    FLAG_Z = DX &= OPER_AY_PI_32();

    FLAG_N = NFLAG_32(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_32_er_pd(void)
{
    FLAG_Z = DX &= OPER_AY_PD_32();

    FLAG_N = NFLAG_32(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_32_er_di(void)
{
    FLAG_Z = DX &= OPER_AY_DI_32();

    FLAG_N = NFLAG_32(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_32_er_ix(void)
{
    FLAG_Z = DX &= OPER_AY_IX_32();

    FLAG_N = NFLAG_32(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_32_er_aw(void)
{
    FLAG_Z = DX &= OPER_AW_32();

    FLAG_N = NFLAG_32(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_32_er_al(void)
{
    FLAG_Z = DX &= OPER_AL_32();

    FLAG_N = NFLAG_32(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_32_er_pcdi(void)
{
    FLAG_Z = DX &= OPER_PCDI_32();

    FLAG_N = NFLAG_32(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_32_er_pcix(void)
{
    FLAG_Z = DX &= OPER_PCIX_32();

    FLAG_N = NFLAG_32(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_32_er_i(void)
{
    FLAG_Z = DX &= OPER_I_32();

    FLAG_N = NFLAG_32(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_and_8_re_ai(void)
{
    uint ea = EA_AY_AI_8();
    uint res = DX & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_and_8_re_pi(void)
{
    uint ea = EA_AY_PI_8();
    uint res = DX & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_and_8_re_pi7(void)
{
    uint ea = EA_A7_PI_8();
    uint res = DX & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_and_8_re_pd(void)
{
    uint ea = EA_AY_PD_8();
    uint res = DX & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_and_8_re_pd7(void)
{
    uint ea = EA_A7_PD_8();
    uint res = DX & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_and_8_re_di(void)
{
    uint ea = EA_AY_DI_8();
    uint res = DX & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_and_8_re_ix(void)
{
    uint ea = EA_AY_IX_8();
    uint res = DX & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_and_8_re_aw(void)
{
    uint ea = EA_AW_8();
    uint res = DX & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_and_8_re_al(void)
{
    uint ea = EA_AL_8();
    uint res = DX & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_and_16_re_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint res = DX & m68ki_read_16(ea);

    FLAG_N = NFLAG_16(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_and_16_re_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint res = DX & m68ki_read_16(ea);

    FLAG_N = NFLAG_16(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_and_16_re_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint res = DX & m68ki_read_16(ea);

    FLAG_N = NFLAG_16(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_and_16_re_di(void)
{
    uint ea = EA_AY_DI_16();
    uint res = DX & m68ki_read_16(ea);

    FLAG_N = NFLAG_16(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_and_16_re_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint res = DX & m68ki_read_16(ea);

    FLAG_N = NFLAG_16(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_and_16_re_aw(void)
{
    uint ea = EA_AW_16();
    uint res = DX & m68ki_read_16(ea);

    FLAG_N = NFLAG_16(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_and_16_re_al(void)
{
    uint ea = EA_AL_16();
    uint res = DX & m68ki_read_16(ea);

    FLAG_N = NFLAG_16(res);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_and_32_re_ai(void)
{
    uint ea = EA_AY_AI_32();
    uint res = DX & m68ki_read_32(ea);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_32(ea, res);
}

static void m68k_op_and_32_re_pi(void)
{
    uint ea = EA_AY_PI_32();
    uint res = DX & m68ki_read_32(ea);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_32(ea, res);
}

static void m68k_op_and_32_re_pd(void)
{
    uint ea = EA_AY_PD_32();
    uint res = DX & m68ki_read_32(ea);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_32(ea, res);
}

static void m68k_op_and_32_re_di(void)
{
    uint ea = EA_AY_DI_32();
    uint res = DX & m68ki_read_32(ea);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_32(ea, res);
}

static void m68k_op_and_32_re_ix(void)
{
    uint ea = EA_AY_IX_32();
    uint res = DX & m68ki_read_32(ea);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_32(ea, res);
}

static void m68k_op_and_32_re_aw(void)
{
    uint ea = EA_AW_32();
    uint res = DX & m68ki_read_32(ea);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_32(ea, res);
}

static void m68k_op_and_32_re_al(void)
{
    uint ea = EA_AL_32();
    uint res = DX & m68ki_read_32(ea);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_32(ea, res);
}

static void m68k_op_andi_8_d(void)
{
    FLAG_Z = MASK_OUT_ABOVE_8(DY &= (OPER_I_8() | 0xffffff00));

    FLAG_N = NFLAG_8(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_andi_8_ai(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_AI_8();
    uint res = src & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_8(ea, res);
}

static void m68k_op_andi_8_pi(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_PI_8();
    uint res = src & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_8(ea, res);
}

static void m68k_op_andi_8_pi7(void)
{
    uint src = OPER_I_8();
    uint ea = EA_A7_PI_8();
    uint res = src & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_8(ea, res);
}

static void m68k_op_andi_8_pd(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_PD_8();
    uint res = src & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_8(ea, res);
}

static void m68k_op_andi_8_pd7(void)
{
    uint src = OPER_I_8();
    uint ea = EA_A7_PD_8();
    uint res = src & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_8(ea, res);
}

static void m68k_op_andi_8_di(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_DI_8();
    uint res = src & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_8(ea, res);
}

static void m68k_op_andi_8_ix(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_IX_8();
    uint res = src & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_8(ea, res);
}

static void m68k_op_andi_8_aw(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AW_8();
    uint res = src & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_8(ea, res);
}

static void m68k_op_andi_8_al(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AL_8();
    uint res = src & m68ki_read_8(ea);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_8(ea, res);
}

static void m68k_op_andi_16_d(void)
{
    FLAG_Z = MASK_OUT_ABOVE_16(DY &= (OPER_I_16() | 0xffff0000));

    FLAG_N = NFLAG_16(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_andi_16_ai(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_AI_16();
    uint res = src & m68ki_read_16(ea);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_16(ea, res);
}

static void m68k_op_andi_16_pi(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_PI_16();
    uint res = src & m68ki_read_16(ea);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_16(ea, res);
}

static void m68k_op_andi_16_pd(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_PD_16();
    uint res = src & m68ki_read_16(ea);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_16(ea, res);
}

static void m68k_op_andi_16_di(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_DI_16();
    uint res = src & m68ki_read_16(ea);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_16(ea, res);
}

static void m68k_op_andi_16_ix(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_IX_16();
    uint res = src & m68ki_read_16(ea);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_16(ea, res);
}

static void m68k_op_andi_16_aw(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AW_16();
    uint res = src & m68ki_read_16(ea);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_16(ea, res);
}

static void m68k_op_andi_16_al(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AL_16();
    uint res = src & m68ki_read_16(ea);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_16(ea, res);
}

static void m68k_op_andi_32_d(void)
{
    FLAG_Z = DY &= (OPER_I_32());

    FLAG_N = NFLAG_32(FLAG_Z);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_andi_32_ai(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_AI_32();
    uint res = src & m68ki_read_32(ea);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_32(ea, res);
}

static void m68k_op_andi_32_pi(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_PI_32();
    uint res = src & m68ki_read_32(ea);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_32(ea, res);
}

static void m68k_op_andi_32_pd(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_PD_32();
    uint res = src & m68ki_read_32(ea);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_32(ea, res);
}

static void m68k_op_andi_32_di(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_DI_32();
    uint res = src & m68ki_read_32(ea);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_32(ea, res);
}

static void m68k_op_andi_32_ix(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_IX_32();
    uint res = src & m68ki_read_32(ea);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_32(ea, res);
}

static void m68k_op_andi_32_aw(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AW_32();
    uint res = src & m68ki_read_32(ea);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_32(ea, res);
}

static void m68k_op_andi_32_al(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AL_32();
    uint res = src & m68ki_read_32(ea);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;

    m68ki_write_32(ea, res);
}

static void m68k_op_andi_16_toc(void)
{
    m68ki_set_ccr(m68ki_get_ccr() & OPER_I_8());
}

static void m68k_op_andi_16_tos(void)
{
    if (FLAG_S) {
        uint src = OPER_I_16();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_set_sr(m68ki_get_sr() & src);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_asr_8_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src >> shift;

    if (shift != 0 && CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    if (GET_MSB_8(src)) {
        res |= m68ki_shift_8_table[shift];
    }

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_X = FLAG_C = src << (9 - shift);
}

static void m68k_op_asr_16_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src >> shift;

    if (shift != 0 && CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    if (GET_MSB_16(src)) {
        res |= m68ki_shift_16_table[shift];
    }

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_X = FLAG_C = src << (9 - shift);
}

static void m68k_op_asr_32_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = *r_dst;
    uint res = src >> shift;

    if (shift != 0 && CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    if (GET_MSB_32(src)) {
        res |= m68ki_shift_32_table[shift];
    }

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_X = FLAG_C = src << (9 - shift);
}

static void m68k_op_asr_8_r(void)
{
    uint* r_dst = &DY;
    uint shift = DX & 0x3f;
    uint src = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src >> shift;

    if (shift != 0) {
        if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
            USE_CYCLES(shift << CYC_SHIFT);
        }

        if (shift < 8) {
            if (GET_MSB_8(src)) {
                res |= m68ki_shift_8_table[shift];
            }

            *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

            FLAG_X = FLAG_C = src << (9 - shift);
            FLAG_N = NFLAG_8(res);
            FLAG_Z = res;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        if (GET_MSB_8(src)) {
            *r_dst |= 0xff;
            FLAG_C = CFLAG_SET;
            FLAG_X = XFLAG_SET;
            FLAG_N = NFLAG_SET;
            FLAG_Z = ZFLAG_CLEAR;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        *r_dst &= 0xffffff00;
        FLAG_C = CFLAG_CLEAR;
        FLAG_X = XFLAG_CLEAR;
        FLAG_N = NFLAG_CLEAR;
        FLAG_Z = ZFLAG_SET;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_8(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_asr_16_r(void)
{
    uint* r_dst = &DY;
    uint shift = DX & 0x3f;
    uint src = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src >> shift;

    if (shift != 0) {
        if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
            USE_CYCLES(shift << CYC_SHIFT);
        }

        if (shift < 16) {
            if (GET_MSB_16(src)) {
                res |= m68ki_shift_16_table[shift];
            }

            *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

            FLAG_C = FLAG_X = (src >> (shift - 1)) << 8;
            FLAG_N = NFLAG_16(res);
            FLAG_Z = res;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        if (GET_MSB_16(src)) {
            *r_dst |= 0xffff;
            FLAG_C = CFLAG_SET;
            FLAG_X = XFLAG_SET;
            FLAG_N = NFLAG_SET;
            FLAG_Z = ZFLAG_CLEAR;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        *r_dst &= 0xffff0000;
        FLAG_C = CFLAG_CLEAR;
        FLAG_X = XFLAG_CLEAR;
        FLAG_N = NFLAG_CLEAR;
        FLAG_Z = ZFLAG_SET;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_16(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_asr_32_r(void)
{
    uint* r_dst = &DY;
    uint shift = DX & 0x3f;
    uint src = *r_dst;
    uint res = src >> shift;

    if (shift != 0) {
        if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
            USE_CYCLES(shift << CYC_SHIFT);
        }

        if (shift < 32) {
            if (GET_MSB_32(src)) {
                res |= m68ki_shift_32_table[shift];
            }

            *r_dst = res;

            FLAG_C = FLAG_X = (src >> (shift - 1)) << 8;
            FLAG_N = NFLAG_32(res);
            FLAG_Z = res;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        if (GET_MSB_32(src)) {
            *r_dst = 0xffffffff;
            FLAG_C = CFLAG_SET;
            FLAG_X = XFLAG_SET;
            FLAG_N = NFLAG_SET;
            FLAG_Z = ZFLAG_CLEAR;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        *r_dst = 0;
        FLAG_C = CFLAG_CLEAR;
        FLAG_X = XFLAG_CLEAR;
        FLAG_N = NFLAG_CLEAR;
        FLAG_Z = ZFLAG_SET;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_32(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_asr_16_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint src = m68ki_read_16(ea);
    uint res = src >> 1;

    if (GET_MSB_16(src)) {
        res |= 0x8000;
    }

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = FLAG_X = src << 8;
}

static void m68k_op_asr_16_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint src = m68ki_read_16(ea);
    uint res = src >> 1;

    if (GET_MSB_16(src)) {
        res |= 0x8000;
    }

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = FLAG_X = src << 8;
}

static void m68k_op_asr_16_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint src = m68ki_read_16(ea);
    uint res = src >> 1;

    if (GET_MSB_16(src)) {
        res |= 0x8000;
    }

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = FLAG_X = src << 8;
}

static void m68k_op_asr_16_di(void)
{
    uint ea = EA_AY_DI_16();
    uint src = m68ki_read_16(ea);
    uint res = src >> 1;

    if (GET_MSB_16(src)) {
        res |= 0x8000;
    }

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = FLAG_X = src << 8;
}

static void m68k_op_asr_16_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint src = m68ki_read_16(ea);
    uint res = src >> 1;

    if (GET_MSB_16(src)) {
        res |= 0x8000;
    }

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = FLAG_X = src << 8;
}

static void m68k_op_asr_16_aw(void)
{
    uint ea = EA_AW_16();
    uint src = m68ki_read_16(ea);
    uint res = src >> 1;

    if (GET_MSB_16(src)) {
        res |= 0x8000;
    }

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = FLAG_X = src << 8;
}

static void m68k_op_asr_16_al(void)
{
    uint ea = EA_AL_16();
    uint src = m68ki_read_16(ea);
    uint res = src >> 1;

    if (GET_MSB_16(src)) {
        res |= 0x8000;
    }

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = FLAG_X = src << 8;
}

static void m68k_op_asl_8_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = MASK_OUT_ABOVE_8(*r_dst);
    uint res = MASK_OUT_ABOVE_8(src << shift);

    if (shift != 0 && CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_X = FLAG_C = src << shift;
    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    src &= m68ki_shift_8_table[shift + 1];
    FLAG_V = (!(src == 0 || (src == m68ki_shift_8_table[shift + 1] && shift < 8))) << 7;
}

static void m68k_op_asl_16_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = MASK_OUT_ABOVE_16(*r_dst);
    uint res = MASK_OUT_ABOVE_16(src << shift);

    if (shift != 0 && CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> (8 - shift);
    src &= m68ki_shift_16_table[shift + 1];
    FLAG_V = (!(src == 0 || src == m68ki_shift_16_table[shift + 1])) << 7;
}

static void m68k_op_asl_32_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = *r_dst;
    uint res = MASK_OUT_ABOVE_32(src << shift);

    if (shift != 0 && CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> (24 - shift);
    src &= m68ki_shift_32_table[shift + 1];
    FLAG_V = (!(src == 0 || src == m68ki_shift_32_table[shift + 1])) << 7;
}

static void m68k_op_asl_8_r(void)
{
    uint* r_dst = &DY;
    uint shift = DX & 0x3f;
    uint src = MASK_OUT_ABOVE_8(*r_dst);
    uint res = MASK_OUT_ABOVE_8(src << shift);

    if (shift != 0) {
        if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
            USE_CYCLES(shift << CYC_SHIFT);
        }

        if (shift < 8) {
            *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;
            FLAG_X = FLAG_C = src << shift;
            FLAG_N = NFLAG_8(res);
            FLAG_Z = res;
            src &= m68ki_shift_8_table[shift + 1];
            FLAG_V = (!(src == 0 || src == m68ki_shift_8_table[shift + 1])) << 7;
            return;
        }

        *r_dst &= 0xffffff00;
        FLAG_X = FLAG_C = ((shift == 8 ? src & 1 : 0)) << 8;
        FLAG_N = NFLAG_CLEAR;
        FLAG_Z = ZFLAG_SET;
        FLAG_V = (!(src == 0)) << 7;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_8(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_asl_16_r(void)
{
    uint* r_dst = &DY;
    uint shift = DX & 0x3f;
    uint src = MASK_OUT_ABOVE_16(*r_dst);
    uint res = MASK_OUT_ABOVE_16(src << shift);

    if (shift != 0) {
        if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
            USE_CYCLES(shift << CYC_SHIFT);
        }

        if (shift < 16) {
            *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
            FLAG_X = FLAG_C = (src << shift) >> 8;
            FLAG_N = NFLAG_16(res);
            FLAG_Z = res;
            src &= m68ki_shift_16_table[shift + 1];
            FLAG_V = (!(src == 0 || src == m68ki_shift_16_table[shift + 1])) << 7;
            return;
        }

        *r_dst &= 0xffff0000;
        FLAG_X = FLAG_C = ((shift == 16 ? src & 1 : 0)) << 8;
        FLAG_N = NFLAG_CLEAR;
        FLAG_Z = ZFLAG_SET;
        FLAG_V = (!(src == 0)) << 7;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_16(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_asl_32_r(void)
{
    uint* r_dst = &DY;
    uint shift = DX & 0x3f;
    uint src = *r_dst;
    uint res = MASK_OUT_ABOVE_32(src << shift);

    if (shift != 0) {
        if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
            USE_CYCLES(shift << CYC_SHIFT);
        }

        if (shift < 32) {
            *r_dst = res;
            FLAG_X = FLAG_C = (src >> (32 - shift)) << 8;
            FLAG_N = NFLAG_32(res);
            FLAG_Z = res;
            src &= m68ki_shift_32_table[shift + 1];
            FLAG_V = (!(src == 0 || src == m68ki_shift_32_table[shift + 1])) << 7;
            return;
        }

        *r_dst = 0;
        FLAG_X = FLAG_C = ((shift == 32 ? src & 1 : 0)) << 8;
        FLAG_N = NFLAG_CLEAR;
        FLAG_Z = ZFLAG_SET;
        FLAG_V = (!(src == 0)) << 7;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_32(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_asl_16_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(src << 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> 7;
    src &= 0xc000;
    FLAG_V = (!(src == 0 || src == 0xc000)) << 7;
}

static void m68k_op_asl_16_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(src << 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> 7;
    src &= 0xc000;
    FLAG_V = (!(src == 0 || src == 0xc000)) << 7;
}

static void m68k_op_asl_16_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(src << 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> 7;
    src &= 0xc000;
    FLAG_V = (!(src == 0 || src == 0xc000)) << 7;
}

static void m68k_op_asl_16_di(void)
{
    uint ea = EA_AY_DI_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(src << 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> 7;
    src &= 0xc000;
    FLAG_V = (!(src == 0 || src == 0xc000)) << 7;
}

static void m68k_op_asl_16_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(src << 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> 7;
    src &= 0xc000;
    FLAG_V = (!(src == 0 || src == 0xc000)) << 7;
}

static void m68k_op_asl_16_aw(void)
{
    uint ea = EA_AW_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(src << 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> 7;
    src &= 0xc000;
    FLAG_V = (!(src == 0 || src == 0xc000)) << 7;
}

static void m68k_op_asl_16_al(void)
{
    uint ea = EA_AL_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(src << 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> 7;
    src &= 0xc000;
    FLAG_V = (!(src == 0 || src == 0xc000)) << 7;
}

static void m68k_op_bhi_8(void)
{
    if (COND_HI()) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        return;
    }
    USE_CYCLES(CYC_BCC_NOTAKE_B);
}

static void m68k_op_bls_8(void)
{
    if (COND_LS()) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        return;
    }
    USE_CYCLES(CYC_BCC_NOTAKE_B);
}

static void m68k_op_bcc_8(void)
{
    if (COND_CC()) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        return;
    }
    USE_CYCLES(CYC_BCC_NOTAKE_B);
}

static void m68k_op_bcs_8(void)
{
    if (COND_CS()) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        return;
    }
    USE_CYCLES(CYC_BCC_NOTAKE_B);
}

static void m68k_op_bne_8(void)
{
    if (COND_NE()) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        return;
    }
    USE_CYCLES(CYC_BCC_NOTAKE_B);
}

static void m68k_op_beq_8(void)
{
    if (COND_EQ()) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        return;
    }
    USE_CYCLES(CYC_BCC_NOTAKE_B);
}

static void m68k_op_bvc_8(void)
{
    if (COND_VC()) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        return;
    }
    USE_CYCLES(CYC_BCC_NOTAKE_B);
}

static void m68k_op_bvs_8(void)
{
    if (COND_VS()) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        return;
    }
    USE_CYCLES(CYC_BCC_NOTAKE_B);
}

static void m68k_op_bpl_8(void)
{
    if (COND_PL()) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        return;
    }
    USE_CYCLES(CYC_BCC_NOTAKE_B);
}

static void m68k_op_bmi_8(void)
{
    if (COND_MI()) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        return;
    }
    USE_CYCLES(CYC_BCC_NOTAKE_B);
}

static void m68k_op_bge_8(void)
{
    if (COND_GE()) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        return;
    }
    USE_CYCLES(CYC_BCC_NOTAKE_B);
}

static void m68k_op_blt_8(void)
{
    if (COND_LT()) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        return;
    }
    USE_CYCLES(CYC_BCC_NOTAKE_B);
}

static void m68k_op_bgt_8(void)
{
    if (COND_GT()) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        return;
    }
    USE_CYCLES(CYC_BCC_NOTAKE_B);
}

static void m68k_op_ble_8(void)
{
    if (COND_LE()) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        return;
    }
    USE_CYCLES(CYC_BCC_NOTAKE_B);
}

static void m68k_op_bhi_16(void)
{
    if (COND_HI()) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_BCC_NOTAKE_W);
}

static void m68k_op_bls_16(void)
{
    if (COND_LS()) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_BCC_NOTAKE_W);
}

static void m68k_op_bcc_16(void)
{
    if (COND_CC()) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_BCC_NOTAKE_W);
}

static void m68k_op_bcs_16(void)
{
    if (COND_CS()) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_BCC_NOTAKE_W);
}

static void m68k_op_bne_16(void)
{
    if (COND_NE()) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_BCC_NOTAKE_W);
}

static void m68k_op_beq_16(void)
{
    if (COND_EQ()) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_BCC_NOTAKE_W);
}

static void m68k_op_bvc_16(void)
{
    if (COND_VC()) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_BCC_NOTAKE_W);
}

static void m68k_op_bvs_16(void)
{
    if (COND_VS()) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_BCC_NOTAKE_W);
}

static void m68k_op_bpl_16(void)
{
    if (COND_PL()) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_BCC_NOTAKE_W);
}

static void m68k_op_bmi_16(void)
{
    if (COND_MI()) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_BCC_NOTAKE_W);
}

static void m68k_op_bge_16(void)
{
    if (COND_GE()) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_BCC_NOTAKE_W);
}

static void m68k_op_blt_16(void)
{
    if (COND_LT()) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_BCC_NOTAKE_W);
}

static void m68k_op_bgt_16(void)
{
    if (COND_GT()) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_BCC_NOTAKE_W);
}

static void m68k_op_ble_16(void)
{
    if (COND_LE()) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_BCC_NOTAKE_W);
}

static void m68k_op_bhi_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_HI()) {
            uint offset = OPER_I_32();
            REG_PC -= 4;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_32(offset);
            return;
        }
        REG_PC += 4;
        return;
    } else {
        if (COND_HI()) {
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
            return;
        }
        USE_CYCLES(CYC_BCC_NOTAKE_B);
    }
}

static void m68k_op_bls_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_LS()) {
            uint offset = OPER_I_32();
            REG_PC -= 4;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_32(offset);
            return;
        }
        REG_PC += 4;
        return;
    } else {
        if (COND_LS()) {
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
            return;
        }
        USE_CYCLES(CYC_BCC_NOTAKE_B);
    }
}

static void m68k_op_bcc_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_CC()) {
            uint offset = OPER_I_32();
            REG_PC -= 4;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_32(offset);
            return;
        }
        REG_PC += 4;
        return;
    } else {
        if (COND_CC()) {
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
            return;
        }
        USE_CYCLES(CYC_BCC_NOTAKE_B);
    }
}

static void m68k_op_bcs_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_CS()) {
            uint offset = OPER_I_32();
            REG_PC -= 4;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_32(offset);
            return;
        }
        REG_PC += 4;
        return;
    } else {
        if (COND_CS()) {
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
            return;
        }
        USE_CYCLES(CYC_BCC_NOTAKE_B);
    }
}

static void m68k_op_bne_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_NE()) {
            uint offset = OPER_I_32();
            REG_PC -= 4;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_32(offset);
            return;
        }
        REG_PC += 4;
        return;
    } else {
        if (COND_NE()) {
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
            return;
        }
        USE_CYCLES(CYC_BCC_NOTAKE_B);
    }
}

static void m68k_op_beq_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_EQ()) {
            uint offset = OPER_I_32();
            REG_PC -= 4;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_32(offset);
            return;
        }
        REG_PC += 4;
        return;
    } else {
        if (COND_EQ()) {
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
            return;
        }
        USE_CYCLES(CYC_BCC_NOTAKE_B);
    }
}

static void m68k_op_bvc_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_VC()) {
            uint offset = OPER_I_32();
            REG_PC -= 4;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_32(offset);
            return;
        }
        REG_PC += 4;
        return;
    } else {
        if (COND_VC()) {
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
            return;
        }
        USE_CYCLES(CYC_BCC_NOTAKE_B);
    }
}

static void m68k_op_bvs_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_VS()) {
            uint offset = OPER_I_32();
            REG_PC -= 4;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_32(offset);
            return;
        }
        REG_PC += 4;
        return;
    } else {
        if (COND_VS()) {
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
            return;
        }
        USE_CYCLES(CYC_BCC_NOTAKE_B);
    }
}

static void m68k_op_bpl_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_PL()) {
            uint offset = OPER_I_32();
            REG_PC -= 4;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_32(offset);
            return;
        }
        REG_PC += 4;
        return;
    } else {
        if (COND_PL()) {
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
            return;
        }
        USE_CYCLES(CYC_BCC_NOTAKE_B);
    }
}

static void m68k_op_bmi_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_MI()) {
            uint offset = OPER_I_32();
            REG_PC -= 4;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_32(offset);
            return;
        }
        REG_PC += 4;
        return;
    } else {
        if (COND_MI()) {
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
            return;
        }
        USE_CYCLES(CYC_BCC_NOTAKE_B);
    }
}

static void m68k_op_bge_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_GE()) {
            uint offset = OPER_I_32();
            REG_PC -= 4;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_32(offset);
            return;
        }
        REG_PC += 4;
        return;
    } else {
        if (COND_GE()) {
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
            return;
        }
        USE_CYCLES(CYC_BCC_NOTAKE_B);
    }
}

static void m68k_op_blt_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_LT()) {
            uint offset = OPER_I_32();
            REG_PC -= 4;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_32(offset);
            return;
        }
        REG_PC += 4;
        return;
    } else {
        if (COND_LT()) {
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
            return;
        }
        USE_CYCLES(CYC_BCC_NOTAKE_B);
    }
}

static void m68k_op_bgt_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_GT()) {
            uint offset = OPER_I_32();
            REG_PC -= 4;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_32(offset);
            return;
        }
        REG_PC += 4;
        return;
    } else {
        if (COND_GT()) {
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
            return;
        }
        USE_CYCLES(CYC_BCC_NOTAKE_B);
    }
}

static void m68k_op_ble_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_LE()) {
            uint offset = OPER_I_32();
            REG_PC -= 4;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_32(offset);
            return;
        }
        REG_PC += 4;
        return;
    } else {
        if (COND_LE()) {
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
            return;
        }
        USE_CYCLES(CYC_BCC_NOTAKE_B);
    }
}

static void m68k_op_bchg_32_r_d(void)
{
    uint* r_dst = &DY;
    uint mask = 1 << (DX & 0x1f);

    FLAG_Z = *r_dst & mask;
    *r_dst ^= mask;
}

static void m68k_op_bchg_8_r_ai(void)
{
    uint ea = EA_AY_AI_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_r_pi(void)
{
    uint ea = EA_AY_PI_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_r_pi7(void)
{
    uint ea = EA_A7_PI_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_r_pd(void)
{
    uint ea = EA_AY_PD_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_r_pd7(void)
{
    uint ea = EA_A7_PD_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_r_di(void)
{
    uint ea = EA_AY_DI_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_r_ix(void)
{
    uint ea = EA_AY_IX_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_r_aw(void)
{
    uint ea = EA_AW_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_r_al(void)
{
    uint ea = EA_AL_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_32_s_d(void)
{
    uint* r_dst = &DY;
    uint mask = 1 << (OPER_I_8() & 0x1f);

    FLAG_Z = *r_dst & mask;
    *r_dst ^= mask;
}

static void m68k_op_bchg_8_s_ai(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_AI_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_s_pi(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_PI_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_s_pi7(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_A7_PI_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_s_pd(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_PD_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_s_pd7(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_A7_PD_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_s_di(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_DI_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_s_ix(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_IX_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_s_aw(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AW_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bchg_8_s_al(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AL_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src ^ mask);
}

static void m68k_op_bclr_32_r_d(void)
{
    uint* r_dst = &DY;
    uint mask = 1 << (DX & 0x1f);

    FLAG_Z = *r_dst & mask;
    *r_dst &= ~mask;
}

static void m68k_op_bclr_8_r_ai(void)
{
    uint ea = EA_AY_AI_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_r_pi(void)
{
    uint ea = EA_AY_PI_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_r_pi7(void)
{
    uint ea = EA_A7_PI_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_r_pd(void)
{
    uint ea = EA_AY_PD_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_r_pd7(void)
{
    uint ea = EA_A7_PD_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_r_di(void)
{
    uint ea = EA_AY_DI_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_r_ix(void)
{
    uint ea = EA_AY_IX_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_r_aw(void)
{
    uint ea = EA_AW_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_r_al(void)
{
    uint ea = EA_AL_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_32_s_d(void)
{
    uint* r_dst = &DY;
    uint mask = 1 << (OPER_I_8() & 0x1f);

    FLAG_Z = *r_dst & mask;
    *r_dst &= ~mask;
}

static void m68k_op_bclr_8_s_ai(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_AI_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_s_pi(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_PI_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_s_pi7(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_A7_PI_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_s_pd(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_PD_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_s_pd7(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_A7_PD_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_s_di(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_DI_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_s_ix(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_IX_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_s_aw(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AW_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bclr_8_s_al(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AL_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src & ~mask);
}

static void m68k_op_bfchg_32_d(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint* data = &DY;
        uint64 mask;

        if (BIT_B(word2)) {
            offset = REG_D[offset & 7];
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        offset &= 31;
        width = ((width - 1) & 31) + 1;

        mask = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask = ROR_32(mask, offset);

        FLAG_N = NFLAG_32(*data << offset);
        FLAG_Z = *data & mask;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        *data ^= mask;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfchg_32_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_AI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long ^ mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte ^ mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfchg_32_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_DI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long ^ mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte ^ mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfchg_32_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_IX_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long ^ mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte ^ mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfchg_32_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AW_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long ^ mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte ^ mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfchg_32_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AL_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long ^ mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte ^ mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfclr_32_d(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint* data = &DY;
        uint64 mask;

        if (BIT_B(word2)) {
            offset = REG_D[offset & 7];
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        offset &= 31;
        width = ((width - 1) & 31) + 1;

        mask = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask = ROR_32(mask, offset);

        FLAG_N = NFLAG_32(*data << offset);
        FLAG_Z = *data & mask;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        *data &= ~mask;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfclr_32_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_AI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long & ~mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte & ~mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfclr_32_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_DI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long & ~mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte & ~mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfclr_32_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_IX_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long & ~mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte & ~mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfclr_32_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AW_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long & ~mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte & ~mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfclr_32_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AL_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long & ~mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte & ~mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfexts_32_d(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint64 data = DY;

        if (BIT_B(word2)) {
            offset = REG_D[offset & 7];
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        offset &= 31;
        width = ((width - 1) & 31) + 1;

        data = ROL_32(data, offset);
        FLAG_N = NFLAG_32(data);
        data = MAKE_INT_32(data) >> (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfexts_32_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint data;
        uint ea = EA_AY_AI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);

        data = MASK_OUT_ABOVE_32(data << offset);

        if ((offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data = MAKE_INT_32(data) >> (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfexts_32_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint data;
        uint ea = EA_AY_DI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);

        data = MASK_OUT_ABOVE_32(data << offset);

        if ((offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data = MAKE_INT_32(data) >> (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfexts_32_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint data;
        uint ea = EA_AY_IX_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);

        data = MASK_OUT_ABOVE_32(data << offset);

        if ((offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data = MAKE_INT_32(data) >> (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfexts_32_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint data;
        uint ea = EA_AW_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);

        data = MASK_OUT_ABOVE_32(data << offset);

        if ((offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data = MAKE_INT_32(data) >> (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfexts_32_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint data;
        uint ea = EA_AL_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);

        data = MASK_OUT_ABOVE_32(data << offset);

        if ((offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data = MAKE_INT_32(data) >> (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfexts_32_pcdi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint data;
        uint ea = EA_PCDI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);

        data = MASK_OUT_ABOVE_32(data << offset);

        if ((offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data = MAKE_INT_32(data) >> (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfexts_32_pcix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint data;
        uint ea = EA_PCIX_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);

        data = MASK_OUT_ABOVE_32(data << offset);

        if ((offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data = MAKE_INT_32(data) >> (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfextu_32_d(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint64 data = DY;

        if (BIT_B(word2)) {
            offset = REG_D[offset & 7];
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        offset &= 31;
        width = ((width - 1) & 31) + 1;

        data = ROL_32(data, offset);
        FLAG_N = NFLAG_32(data);
        data >>= 32 - width;

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfextu_32_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint data;
        uint ea = EA_AY_AI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);
        data = MASK_OUT_ABOVE_32(data << offset);

        if ((offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data >>= (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfextu_32_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint data;
        uint ea = EA_AY_DI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);
        data = MASK_OUT_ABOVE_32(data << offset);

        if ((offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data >>= (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfextu_32_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint data;
        uint ea = EA_AY_IX_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);
        data = MASK_OUT_ABOVE_32(data << offset);

        if ((offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data >>= (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfextu_32_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint data;
        uint ea = EA_AW_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);
        data = MASK_OUT_ABOVE_32(data << offset);

        if ((offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data >>= (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfextu_32_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint data;
        uint ea = EA_AL_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);
        data = MASK_OUT_ABOVE_32(data << offset);

        if ((offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data >>= (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfextu_32_pcdi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint data;
        uint ea = EA_PCDI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);
        data = MASK_OUT_ABOVE_32(data << offset);

        if ((offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data >>= (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfextu_32_pcix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint data;
        uint ea = EA_PCIX_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);
        data = MASK_OUT_ABOVE_32(data << offset);

        if ((offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data >>= (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        REG_D[(word2 >> 12) & 7] = data;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfffo_32_d(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint64 data = DY;
        uint bit;

        if (BIT_B(word2)) {
            offset = REG_D[offset & 7];
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        offset &= 31;
        width = ((width - 1) & 31) + 1;

        data = ROL_32(data, offset);
        FLAG_N = NFLAG_32(data);
        data >>= 32 - width;

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        for (bit = 1 << (width - 1); bit && !(data & bit); bit >>= 1) {
            offset++;
        }

        REG_D[(word2 >> 12) & 7] = offset;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfffo_32_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        sint local_offset;
        uint width = word2;
        uint data;
        uint bit;
        uint ea = EA_AY_AI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        local_offset = offset % 8;
        if (local_offset < 0) {
            local_offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);
        data = MASK_OUT_ABOVE_32(data << local_offset);

        if ((local_offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << local_offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data >>= (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        for (bit = 1 << (width - 1); bit && !(data & bit); bit >>= 1) {
            offset++;
        }

        REG_D[(word2 >> 12) & 7] = offset;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfffo_32_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        sint local_offset;
        uint width = word2;
        uint data;
        uint bit;
        uint ea = EA_AY_DI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        local_offset = offset % 8;
        if (local_offset < 0) {
            local_offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);
        data = MASK_OUT_ABOVE_32(data << local_offset);

        if ((local_offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << local_offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data >>= (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        for (bit = 1 << (width - 1); bit && !(data & bit); bit >>= 1) {
            offset++;
        }

        REG_D[(word2 >> 12) & 7] = offset;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfffo_32_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        sint local_offset;
        uint width = word2;
        uint data;
        uint bit;
        uint ea = EA_AY_IX_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        local_offset = offset % 8;
        if (local_offset < 0) {
            local_offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);
        data = MASK_OUT_ABOVE_32(data << local_offset);

        if ((local_offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << local_offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data >>= (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        for (bit = 1 << (width - 1); bit && !(data & bit); bit >>= 1) {
            offset++;
        }

        REG_D[(word2 >> 12) & 7] = offset;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfffo_32_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        sint local_offset;
        uint width = word2;
        uint data;
        uint bit;
        uint ea = EA_AW_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        local_offset = offset % 8;
        if (local_offset < 0) {
            local_offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);
        data = MASK_OUT_ABOVE_32(data << local_offset);

        if ((local_offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << local_offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data >>= (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        for (bit = 1 << (width - 1); bit && !(data & bit); bit >>= 1) {
            offset++;
        }

        REG_D[(word2 >> 12) & 7] = offset;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfffo_32_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        sint local_offset;
        uint width = word2;
        uint data;
        uint bit;
        uint ea = EA_AL_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        local_offset = offset % 8;
        if (local_offset < 0) {
            local_offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);
        data = MASK_OUT_ABOVE_32(data << local_offset);

        if ((local_offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << local_offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data >>= (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        for (bit = 1 << (width - 1); bit && !(data & bit); bit >>= 1) {
            offset++;
        }

        REG_D[(word2 >> 12) & 7] = offset;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfffo_32_pcdi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        sint local_offset;
        uint width = word2;
        uint data;
        uint bit;
        uint ea = EA_PCDI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        local_offset = offset % 8;
        if (local_offset < 0) {
            local_offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);
        data = MASK_OUT_ABOVE_32(data << local_offset);

        if ((local_offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << local_offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data >>= (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        for (bit = 1 << (width - 1); bit && !(data & bit); bit >>= 1) {
            offset++;
        }

        REG_D[(word2 >> 12) & 7] = offset;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfffo_32_pcix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        sint local_offset;
        uint width = word2;
        uint data;
        uint bit;
        uint ea = EA_PCIX_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        local_offset = offset % 8;
        if (local_offset < 0) {
            local_offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        data = m68ki_read_32(ea);
        data = MASK_OUT_ABOVE_32(data << local_offset);

        if ((local_offset + width) > 32) {
            data |= (m68ki_read_8(ea + 4) << local_offset) >> 8;
        }

        FLAG_N = NFLAG_32(data);
        data >>= (32 - width);

        FLAG_Z = data;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        for (bit = 1 << (width - 1); bit && !(data & bit); bit >>= 1) {
            offset++;
        }

        REG_D[(word2 >> 12) & 7] = offset;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfins_32_d(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint* data = &DY;
        uint64 mask;
        uint64 insert = REG_D[(word2 >> 12) & 7];

        if (BIT_B(word2)) {
            offset = REG_D[offset & 7];
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        offset &= 31;
        width = ((width - 1) & 31) + 1;

        mask = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask = ROR_32(mask, offset);

        insert = MASK_OUT_ABOVE_32(insert << (32 - width));
        FLAG_N = NFLAG_32(insert);
        FLAG_Z = insert;
        insert = ROR_32(insert, offset);

        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        *data &= ~mask;
        *data |= insert;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfins_32_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint insert_base = REG_D[(word2 >> 12) & 7];
        uint insert_long;
        uint insert_byte;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_AI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        insert_base = MASK_OUT_ABOVE_32(insert_base << (32 - width));
        FLAG_N = NFLAG_32(insert_base);
        FLAG_Z = insert_base;
        insert_long = insert_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, (data_long & ~mask_long) | insert_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            insert_byte = MASK_OUT_ABOVE_8(insert_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, (data_byte & ~mask_byte) | insert_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfins_32_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint insert_base = REG_D[(word2 >> 12) & 7];
        uint insert_long;
        uint insert_byte;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_DI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        insert_base = MASK_OUT_ABOVE_32(insert_base << (32 - width));
        FLAG_N = NFLAG_32(insert_base);
        FLAG_Z = insert_base;
        insert_long = insert_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, (data_long & ~mask_long) | insert_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            insert_byte = MASK_OUT_ABOVE_8(insert_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, (data_byte & ~mask_byte) | insert_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfins_32_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint insert_base = REG_D[(word2 >> 12) & 7];
        uint insert_long;
        uint insert_byte;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_IX_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        insert_base = MASK_OUT_ABOVE_32(insert_base << (32 - width));
        FLAG_N = NFLAG_32(insert_base);
        FLAG_Z = insert_base;
        insert_long = insert_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, (data_long & ~mask_long) | insert_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            insert_byte = MASK_OUT_ABOVE_8(insert_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, (data_byte & ~mask_byte) | insert_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfins_32_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint insert_base = REG_D[(word2 >> 12) & 7];
        uint insert_long;
        uint insert_byte;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AW_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        insert_base = MASK_OUT_ABOVE_32(insert_base << (32 - width));
        FLAG_N = NFLAG_32(insert_base);
        FLAG_Z = insert_base;
        insert_long = insert_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, (data_long & ~mask_long) | insert_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            insert_byte = MASK_OUT_ABOVE_8(insert_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, (data_byte & ~mask_byte) | insert_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfins_32_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint insert_base = REG_D[(word2 >> 12) & 7];
        uint insert_long;
        uint insert_byte;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AL_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        insert_base = MASK_OUT_ABOVE_32(insert_base << (32 - width));
        FLAG_N = NFLAG_32(insert_base);
        FLAG_Z = insert_base;
        insert_long = insert_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, (data_long & ~mask_long) | insert_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            insert_byte = MASK_OUT_ABOVE_8(insert_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, (data_byte & ~mask_byte) | insert_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfset_32_d(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint* data = &DY;
        uint64 mask;

        if (BIT_B(word2)) {
            offset = REG_D[offset & 7];
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        offset &= 31;
        width = ((width - 1) & 31) + 1;

        mask = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask = ROR_32(mask, offset);

        FLAG_N = NFLAG_32(*data << offset);
        FLAG_Z = *data & mask;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        *data |= mask;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfset_32_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_AI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long | mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte | mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfset_32_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_DI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long | mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte | mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfset_32_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_IX_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long | mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte | mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfset_32_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AW_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long | mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte | mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bfset_32_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AL_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = NFLAG_32(data_long << offset);
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        m68ki_write_32(ea, data_long | mask_long);

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
            m68ki_write_8(ea + 4, data_byte | mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bftst_32_d(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint* data = &DY;
        uint64 mask;

        if (BIT_B(word2)) {
            offset = REG_D[offset & 7];
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        offset &= 31;
        width = ((width - 1) & 31) + 1;

        mask = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask = ROR_32(mask, offset);

        FLAG_N = NFLAG_32(*data << offset);
        FLAG_Z = *data & mask;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bftst_32_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_AI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = ((data_long & (0x80000000 >> offset)) << offset) >> 24;
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bftst_32_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_DI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = ((data_long & (0x80000000 >> offset)) << offset) >> 24;
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bftst_32_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AY_IX_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = ((data_long & (0x80000000 >> offset)) << offset) >> 24;
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bftst_32_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AW_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = ((data_long & (0x80000000 >> offset)) << offset) >> 24;
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bftst_32_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_AL_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = ((data_long & (0x80000000 >> offset)) << offset) >> 24;
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bftst_32_pcdi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_PCDI_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = ((data_long & (0x80000000 >> offset)) << offset) >> 24;
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bftst_32_pcix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint offset = (word2 >> 6) & 31;
        uint width = word2;
        uint mask_base;
        uint data_long;
        uint mask_long;
        uint data_byte = 0;
        uint mask_byte = 0;
        uint ea = EA_PCIX_8();

        if (BIT_B(word2)) {
            offset = MAKE_INT_32(REG_D[offset & 7]);
        }
        if (BIT_5(word2)) {
            width = REG_D[width & 7];
        }

        /* Offset is signed so we have to use ugly math =( */
        ea += offset / 8;
        offset %= 8;
        if (offset < 0) {
            offset += 8;
            ea--;
        }
        width = ((width - 1) & 31) + 1;

        mask_base = MASK_OUT_ABOVE_32(0xffffffff << (32 - width));
        mask_long = mask_base >> offset;

        data_long = m68ki_read_32(ea);
        FLAG_N = ((data_long & (0x80000000 >> offset)) << offset) >> 24;
        FLAG_Z = data_long & mask_long;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;

        if ((width + offset) > 32) {
            mask_byte = MASK_OUT_ABOVE_8(mask_base);
            data_byte = m68ki_read_8(ea + 4);
            FLAG_Z |= (data_byte & mask_byte);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_bkpt(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        m68ki_bkpt_ack(CPU_TYPE_IS_EC020_PLUS(CPU_TYPE) ? REG_IR & 7 : 0); /* auto-disable (see m68kcpu.h) */
    }
    m68ki_exception_illegal();
}

static void m68k_op_bra_8(void)
{
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
    if (REG_PC == REG_PPC) {
        USE_ALL_CYCLES();
    }
}

static void m68k_op_bra_16(void)
{
    uint offset = OPER_I_16();
    REG_PC -= 2;
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    m68ki_branch_16(offset);
    if (REG_PC == REG_PPC) {
        USE_ALL_CYCLES();
    }
}

static void m68k_op_bra_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint offset = OPER_I_32();
        REG_PC -= 4;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_32(offset);
        if (REG_PC == REG_PPC) {
            USE_ALL_CYCLES();
        }
        return;
    } else {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
        if (REG_PC == REG_PPC) {
            USE_ALL_CYCLES();
        }
    }
}

static void m68k_op_bset_32_r_d(void)
{
    uint* r_dst = &DY;
    uint mask = 1 << (DX & 0x1f);

    FLAG_Z = *r_dst & mask;
    *r_dst |= mask;
}

static void m68k_op_bset_8_r_ai(void)
{
    uint ea = EA_AY_AI_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_r_pi(void)
{
    uint ea = EA_AY_PI_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_r_pi7(void)
{
    uint ea = EA_A7_PI_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_r_pd(void)
{
    uint ea = EA_AY_PD_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_r_pd7(void)
{
    uint ea = EA_A7_PD_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_r_di(void)
{
    uint ea = EA_AY_DI_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_r_ix(void)
{
    uint ea = EA_AY_IX_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_r_aw(void)
{
    uint ea = EA_AW_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_r_al(void)
{
    uint ea = EA_AL_8();
    uint src = m68ki_read_8(ea);
    uint mask = 1 << (DX & 7);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_32_s_d(void)
{
    uint* r_dst = &DY;
    uint mask = 1 << (OPER_I_8() & 0x1f);

    FLAG_Z = *r_dst & mask;
    *r_dst |= mask;
}

static void m68k_op_bset_8_s_ai(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_AI_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_s_pi(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_PI_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_s_pi7(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_A7_PI_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_s_pd(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_PD_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_s_pd7(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_A7_PD_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_s_di(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_DI_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_s_ix(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AY_IX_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_s_aw(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AW_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bset_8_s_al(void)
{
    uint mask = 1 << (OPER_I_8() & 7);
    uint ea = EA_AL_8();
    uint src = m68ki_read_8(ea);

    FLAG_Z = src & mask;
    m68ki_write_8(ea, src | mask);
}

static void m68k_op_bsr_8(void)
{
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    m68ki_push_32(REG_PC);
    m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
}

static void m68k_op_bsr_16(void)
{
    uint offset = OPER_I_16();
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    m68ki_push_32(REG_PC);
    REG_PC -= 2;
    m68ki_branch_16(offset);
}

static void m68k_op_bsr_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint offset = OPER_I_32();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_push_32(REG_PC);
        REG_PC -= 4;
        m68ki_branch_32(offset);
        return;
    } else {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_push_32(REG_PC);
        m68ki_branch_8(MASK_OUT_ABOVE_8(REG_IR));
    }
}

static void m68k_op_btst_32_r_d(void)
{
    FLAG_Z = DY & (1 << (DX & 0x1f));
}

static void m68k_op_btst_8_r_ai(void)
{
    FLAG_Z = OPER_AY_AI_8() & (1 << (DX & 7));
}

static void m68k_op_btst_8_r_pi(void)
{
    FLAG_Z = OPER_AY_PI_8() & (1 << (DX & 7));
}

static void m68k_op_btst_8_r_pi7(void)
{
    FLAG_Z = OPER_A7_PI_8() & (1 << (DX & 7));
}

static void m68k_op_btst_8_r_pd(void)
{
    FLAG_Z = OPER_AY_PD_8() & (1 << (DX & 7));
}

static void m68k_op_btst_8_r_pd7(void)
{
    FLAG_Z = OPER_A7_PD_8() & (1 << (DX & 7));
}

static void m68k_op_btst_8_r_di(void)
{
    FLAG_Z = OPER_AY_DI_8() & (1 << (DX & 7));
}

static void m68k_op_btst_8_r_ix(void)
{
    FLAG_Z = OPER_AY_IX_8() & (1 << (DX & 7));
}

static void m68k_op_btst_8_r_aw(void)
{
    FLAG_Z = OPER_AW_8() & (1 << (DX & 7));
}

static void m68k_op_btst_8_r_al(void)
{
    FLAG_Z = OPER_AL_8() & (1 << (DX & 7));
}

static void m68k_op_btst_8_r_pcdi(void)
{
    FLAG_Z = OPER_PCDI_8() & (1 << (DX & 7));
}

static void m68k_op_btst_8_r_pcix(void)
{
    FLAG_Z = OPER_PCIX_8() & (1 << (DX & 7));
}

static void m68k_op_btst_8_r_i(void)
{
    FLAG_Z = OPER_I_8() & (1 << (DX & 7));
}

static void m68k_op_btst_32_s_d(void)
{
    FLAG_Z = DY & (1 << (OPER_I_8() & 0x1f));
}

static void m68k_op_btst_8_s_ai(void)
{
    uint bit = OPER_I_8() & 7;

    FLAG_Z = OPER_AY_AI_8() & (1 << bit);
}

static void m68k_op_btst_8_s_pi(void)
{
    uint bit = OPER_I_8() & 7;

    FLAG_Z = OPER_AY_PI_8() & (1 << bit);
}

static void m68k_op_btst_8_s_pi7(void)
{
    uint bit = OPER_I_8() & 7;

    FLAG_Z = OPER_A7_PI_8() & (1 << bit);
}

static void m68k_op_btst_8_s_pd(void)
{
    uint bit = OPER_I_8() & 7;

    FLAG_Z = OPER_AY_PD_8() & (1 << bit);
}

static void m68k_op_btst_8_s_pd7(void)
{
    uint bit = OPER_I_8() & 7;

    FLAG_Z = OPER_A7_PD_8() & (1 << bit);
}

static void m68k_op_btst_8_s_di(void)
{
    uint bit = OPER_I_8() & 7;

    FLAG_Z = OPER_AY_DI_8() & (1 << bit);
}

static void m68k_op_btst_8_s_ix(void)
{
    uint bit = OPER_I_8() & 7;

    FLAG_Z = OPER_AY_IX_8() & (1 << bit);
}

static void m68k_op_btst_8_s_aw(void)
{
    uint bit = OPER_I_8() & 7;

    FLAG_Z = OPER_AW_8() & (1 << bit);
}

static void m68k_op_btst_8_s_al(void)
{
    uint bit = OPER_I_8() & 7;

    FLAG_Z = OPER_AL_8() & (1 << bit);
}

static void m68k_op_btst_8_s_pcdi(void)
{
    uint bit = OPER_I_8() & 7;

    FLAG_Z = OPER_PCDI_8() & (1 << bit);
}

static void m68k_op_btst_8_s_pcix(void)
{
    uint bit = OPER_I_8() & 7;

    FLAG_Z = OPER_PCIX_8() & (1 << bit);
}

static void m68k_op_callm_32_ai(void)
{
    /* note: watch out for pcrelative modes */
    if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
        uint ea = EA_AY_AI_32();

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        REG_PC += 2;
        (void)ea; /* just to avoid an 'unused variable' warning */
        M68K_DO_LOG((M68K_LOG_FILEHANDLE "%s at %08x: called unimplemented instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PC - 2), REG_IR,
                     m68k_disassemble_quick(ADDRESS_68K(REG_PC - 2))));
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_callm_32_di(void)
{
    /* note: watch out for pcrelative modes */
    if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
        uint ea = EA_AY_DI_32();

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        REG_PC += 2;
        (void)ea; /* just to avoid an 'unused variable' warning */
        M68K_DO_LOG((M68K_LOG_FILEHANDLE "%s at %08x: called unimplemented instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PC - 2), REG_IR,
                     m68k_disassemble_quick(ADDRESS_68K(REG_PC - 2))));
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_callm_32_ix(void)
{
    /* note: watch out for pcrelative modes */
    if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
        uint ea = EA_AY_IX_32();

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        REG_PC += 2;
        (void)ea; /* just to avoid an 'unused variable' warning */
        M68K_DO_LOG((M68K_LOG_FILEHANDLE "%s at %08x: called unimplemented instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PC - 2), REG_IR,
                     m68k_disassemble_quick(ADDRESS_68K(REG_PC - 2))));
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_callm_32_aw(void)
{
    /* note: watch out for pcrelative modes */
    if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
        uint ea = EA_AW_32();

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        REG_PC += 2;
        (void)ea; /* just to avoid an 'unused variable' warning */
        M68K_DO_LOG((M68K_LOG_FILEHANDLE "%s at %08x: called unimplemented instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PC - 2), REG_IR,
                     m68k_disassemble_quick(ADDRESS_68K(REG_PC - 2))));
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_callm_32_al(void)
{
    /* note: watch out for pcrelative modes */
    if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
        uint ea = EA_AL_32();

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        REG_PC += 2;
        (void)ea; /* just to avoid an 'unused variable' warning */
        M68K_DO_LOG((M68K_LOG_FILEHANDLE "%s at %08x: called unimplemented instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PC - 2), REG_IR,
                     m68k_disassemble_quick(ADDRESS_68K(REG_PC - 2))));
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_callm_32_pcdi(void)
{
    /* note: watch out for pcrelative modes */
    if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
        uint ea = EA_PCDI_32();

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        REG_PC += 2;
        (void)ea; /* just to avoid an 'unused variable' warning */
        M68K_DO_LOG((M68K_LOG_FILEHANDLE "%s at %08x: called unimplemented instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PC - 2), REG_IR,
                     m68k_disassemble_quick(ADDRESS_68K(REG_PC - 2))));
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_callm_32_pcix(void)
{
    /* note: watch out for pcrelative modes */
    if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
        uint ea = EA_PCIX_32();

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        REG_PC += 2;
        (void)ea; /* just to avoid an 'unused variable' warning */
        M68K_DO_LOG((M68K_LOG_FILEHANDLE "%s at %08x: called unimplemented instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PC - 2), REG_IR,
                     m68k_disassemble_quick(ADDRESS_68K(REG_PC - 2))));
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_8_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_AI_8();
        uint dest = m68ki_read_8(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_8(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_8(res);
        FLAG_Z = MASK_OUT_ABOVE_8(res);
        FLAG_V = VFLAG_SUB_8(*compare, dest, res);
        FLAG_C = CFLAG_8(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_8(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_8(ea, MASK_OUT_ABOVE_8(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_8_pi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_PI_8();
        uint dest = m68ki_read_8(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_8(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_8(res);
        FLAG_Z = MASK_OUT_ABOVE_8(res);
        FLAG_V = VFLAG_SUB_8(*compare, dest, res);
        FLAG_C = CFLAG_8(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_8(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_8(ea, MASK_OUT_ABOVE_8(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_8_pi7(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_A7_PI_8();
        uint dest = m68ki_read_8(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_8(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_8(res);
        FLAG_Z = MASK_OUT_ABOVE_8(res);
        FLAG_V = VFLAG_SUB_8(*compare, dest, res);
        FLAG_C = CFLAG_8(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_8(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_8(ea, MASK_OUT_ABOVE_8(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_8_pd(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_PD_8();
        uint dest = m68ki_read_8(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_8(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_8(res);
        FLAG_Z = MASK_OUT_ABOVE_8(res);
        FLAG_V = VFLAG_SUB_8(*compare, dest, res);
        FLAG_C = CFLAG_8(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_8(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_8(ea, MASK_OUT_ABOVE_8(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_8_pd7(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_A7_PD_8();
        uint dest = m68ki_read_8(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_8(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_8(res);
        FLAG_Z = MASK_OUT_ABOVE_8(res);
        FLAG_V = VFLAG_SUB_8(*compare, dest, res);
        FLAG_C = CFLAG_8(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_8(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_8(ea, MASK_OUT_ABOVE_8(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_8_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_DI_8();
        uint dest = m68ki_read_8(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_8(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_8(res);
        FLAG_Z = MASK_OUT_ABOVE_8(res);
        FLAG_V = VFLAG_SUB_8(*compare, dest, res);
        FLAG_C = CFLAG_8(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_8(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_8(ea, MASK_OUT_ABOVE_8(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_8_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_IX_8();
        uint dest = m68ki_read_8(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_8(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_8(res);
        FLAG_Z = MASK_OUT_ABOVE_8(res);
        FLAG_V = VFLAG_SUB_8(*compare, dest, res);
        FLAG_C = CFLAG_8(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_8(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_8(ea, MASK_OUT_ABOVE_8(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_8_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AW_8();
        uint dest = m68ki_read_8(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_8(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_8(res);
        FLAG_Z = MASK_OUT_ABOVE_8(res);
        FLAG_V = VFLAG_SUB_8(*compare, dest, res);
        FLAG_C = CFLAG_8(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_8(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_8(ea, MASK_OUT_ABOVE_8(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_8_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AL_8();
        uint dest = m68ki_read_8(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_8(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_8(res);
        FLAG_Z = MASK_OUT_ABOVE_8(res);
        FLAG_V = VFLAG_SUB_8(*compare, dest, res);
        FLAG_C = CFLAG_8(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_8(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_8(ea, MASK_OUT_ABOVE_8(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_16_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_AI_16();
        uint dest = m68ki_read_16(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_16(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_16(res);
        FLAG_Z = MASK_OUT_ABOVE_16(res);
        FLAG_V = VFLAG_SUB_16(*compare, dest, res);
        FLAG_C = CFLAG_16(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_16(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_16(ea, MASK_OUT_ABOVE_16(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_16_pi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_PI_16();
        uint dest = m68ki_read_16(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_16(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_16(res);
        FLAG_Z = MASK_OUT_ABOVE_16(res);
        FLAG_V = VFLAG_SUB_16(*compare, dest, res);
        FLAG_C = CFLAG_16(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_16(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_16(ea, MASK_OUT_ABOVE_16(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_16_pd(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_PD_16();
        uint dest = m68ki_read_16(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_16(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_16(res);
        FLAG_Z = MASK_OUT_ABOVE_16(res);
        FLAG_V = VFLAG_SUB_16(*compare, dest, res);
        FLAG_C = CFLAG_16(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_16(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_16(ea, MASK_OUT_ABOVE_16(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_16_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_DI_16();
        uint dest = m68ki_read_16(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_16(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_16(res);
        FLAG_Z = MASK_OUT_ABOVE_16(res);
        FLAG_V = VFLAG_SUB_16(*compare, dest, res);
        FLAG_C = CFLAG_16(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_16(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_16(ea, MASK_OUT_ABOVE_16(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_16_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_IX_16();
        uint dest = m68ki_read_16(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_16(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_16(res);
        FLAG_Z = MASK_OUT_ABOVE_16(res);
        FLAG_V = VFLAG_SUB_16(*compare, dest, res);
        FLAG_C = CFLAG_16(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_16(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_16(ea, MASK_OUT_ABOVE_16(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_16_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AW_16();
        uint dest = m68ki_read_16(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_16(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_16(res);
        FLAG_Z = MASK_OUT_ABOVE_16(res);
        FLAG_V = VFLAG_SUB_16(*compare, dest, res);
        FLAG_C = CFLAG_16(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_16(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_16(ea, MASK_OUT_ABOVE_16(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_16_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AL_16();
        uint dest = m68ki_read_16(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - MASK_OUT_ABOVE_16(*compare);

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_16(res);
        FLAG_Z = MASK_OUT_ABOVE_16(res);
        FLAG_V = VFLAG_SUB_16(*compare, dest, res);
        FLAG_C = CFLAG_16(res);

        if (COND_NE()) {
            *compare = MASK_OUT_BELOW_16(*compare) | dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_16(ea, MASK_OUT_ABOVE_16(REG_D[(word2 >> 6) & 7]));
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_32_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_AI_32();
        uint dest = m68ki_read_32(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - *compare;

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_32(res);
        FLAG_Z = MASK_OUT_ABOVE_32(res);
        FLAG_V = VFLAG_SUB_32(*compare, dest, res);
        FLAG_C = CFLAG_SUB_32(*compare, dest, res);

        if (COND_NE()) {
            *compare = dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_32(ea, REG_D[(word2 >> 6) & 7]);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_32_pi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_PI_32();
        uint dest = m68ki_read_32(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - *compare;

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_32(res);
        FLAG_Z = MASK_OUT_ABOVE_32(res);
        FLAG_V = VFLAG_SUB_32(*compare, dest, res);
        FLAG_C = CFLAG_SUB_32(*compare, dest, res);

        if (COND_NE()) {
            *compare = dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_32(ea, REG_D[(word2 >> 6) & 7]);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_32_pd(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_PD_32();
        uint dest = m68ki_read_32(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - *compare;

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_32(res);
        FLAG_Z = MASK_OUT_ABOVE_32(res);
        FLAG_V = VFLAG_SUB_32(*compare, dest, res);
        FLAG_C = CFLAG_SUB_32(*compare, dest, res);

        if (COND_NE()) {
            *compare = dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_32(ea, REG_D[(word2 >> 6) & 7]);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_32_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_DI_32();
        uint dest = m68ki_read_32(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - *compare;

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_32(res);
        FLAG_Z = MASK_OUT_ABOVE_32(res);
        FLAG_V = VFLAG_SUB_32(*compare, dest, res);
        FLAG_C = CFLAG_SUB_32(*compare, dest, res);

        if (COND_NE()) {
            *compare = dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_32(ea, REG_D[(word2 >> 6) & 7]);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_32_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AY_IX_32();
        uint dest = m68ki_read_32(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - *compare;

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_32(res);
        FLAG_Z = MASK_OUT_ABOVE_32(res);
        FLAG_V = VFLAG_SUB_32(*compare, dest, res);
        FLAG_C = CFLAG_SUB_32(*compare, dest, res);

        if (COND_NE()) {
            *compare = dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_32(ea, REG_D[(word2 >> 6) & 7]);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_32_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AW_32();
        uint dest = m68ki_read_32(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - *compare;

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_32(res);
        FLAG_Z = MASK_OUT_ABOVE_32(res);
        FLAG_V = VFLAG_SUB_32(*compare, dest, res);
        FLAG_C = CFLAG_SUB_32(*compare, dest, res);

        if (COND_NE()) {
            *compare = dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_32(ea, REG_D[(word2 >> 6) & 7]);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas_32_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint ea = EA_AL_32();
        uint dest = m68ki_read_32(ea);
        uint* compare = &REG_D[word2 & 7];
        uint res = dest - *compare;

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_32(res);
        FLAG_Z = MASK_OUT_ABOVE_32(res);
        FLAG_V = VFLAG_SUB_32(*compare, dest, res);
        FLAG_C = CFLAG_SUB_32(*compare, dest, res);

        if (COND_NE()) {
            *compare = dest;
        } else {
            USE_CYCLES(3);
            m68ki_write_32(ea, REG_D[(word2 >> 6) & 7]);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas2_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_32();
        uint* compare1 = &REG_D[(word2 >> 16) & 7];
        uint ea1 = REG_DA[(word2 >> 28) & 15];
        uint dest1 = m68ki_read_16(ea1);
        uint res1 = dest1 - MASK_OUT_ABOVE_16(*compare1);
        uint* compare2 = &REG_D[word2 & 7];
        uint ea2 = REG_DA[(word2 >> 12) & 15];
        uint dest2 = m68ki_read_16(ea2);
        uint res2;

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_16(res1);
        FLAG_Z = MASK_OUT_ABOVE_16(res1);
        FLAG_V = VFLAG_SUB_16(*compare1, dest1, res1);
        FLAG_C = CFLAG_16(res1);

        if (COND_EQ()) {
            res2 = dest2 - MASK_OUT_ABOVE_16(*compare2);

            FLAG_N = NFLAG_16(res2);
            FLAG_Z = MASK_OUT_ABOVE_16(res2);
            FLAG_V = VFLAG_SUB_16(*compare2, dest2, res2);
            FLAG_C = CFLAG_16(res2);

            if (COND_EQ()) {
                USE_CYCLES(3);
                m68ki_write_16(ea1, REG_D[(word2 >> 22) & 7]);
                m68ki_write_16(ea2, REG_D[(word2 >> 6) & 7]);
                return;
            }
        }
        *compare1 = BIT_1F(word2) ? (uint)MAKE_INT_16(dest1) : MASK_OUT_BELOW_16(*compare1) | dest1;
        *compare2 = BIT_F(word2) ? (uint)MAKE_INT_16(dest2) : MASK_OUT_BELOW_16(*compare2) | dest2;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cas2_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_32();
        uint* compare1 = &REG_D[(word2 >> 16) & 7];
        uint ea1 = REG_DA[(word2 >> 28) & 15];
        uint dest1 = m68ki_read_32(ea1);
        uint res1 = dest1 - *compare1;
        uint* compare2 = &REG_D[word2 & 7];
        uint ea2 = REG_DA[(word2 >> 12) & 15];
        uint dest2 = m68ki_read_32(ea2);
        uint res2;

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        FLAG_N = NFLAG_32(res1);
        FLAG_Z = MASK_OUT_ABOVE_32(res1);
        FLAG_V = VFLAG_SUB_32(*compare1, dest1, res1);
        FLAG_C = CFLAG_SUB_32(*compare1, dest1, res1);

        if (COND_EQ()) {
            res2 = dest2 - *compare2;

            FLAG_N = NFLAG_32(res2);
            FLAG_Z = MASK_OUT_ABOVE_32(res2);
            FLAG_V = VFLAG_SUB_32(*compare2, dest2, res2);
            FLAG_C = CFLAG_SUB_32(*compare2, dest2, res2);

            if (COND_EQ()) {
                USE_CYCLES(3);
                m68ki_write_32(ea1, REG_D[(word2 >> 22) & 7]);
                m68ki_write_32(ea2, REG_D[(word2 >> 6) & 7]);
                return;
            }
        }
        *compare1 = dest1;
        *compare2 = dest2;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk_16_d(void)
{
    sint src = MAKE_INT_16(DX);
    sint bound = MAKE_INT_16(DY);

    FLAG_Z = ZFLAG_16(src); /* Undocumented */
    FLAG_V = VFLAG_CLEAR;   /* Undocumented */
    FLAG_C = CFLAG_CLEAR;   /* Undocumented */

    if (src >= 0 && src <= bound) {
        return;
    }
    FLAG_N = (src < 0) << 7;
    m68ki_exception_trap(EXCEPTION_CHK);
}

static void m68k_op_chk_16_ai(void)
{
    sint src = MAKE_INT_16(DX);
    sint bound = MAKE_INT_16(OPER_AY_AI_16());

    FLAG_Z = ZFLAG_16(src); /* Undocumented */
    FLAG_V = VFLAG_CLEAR;   /* Undocumented */
    FLAG_C = CFLAG_CLEAR;   /* Undocumented */

    if (src >= 0 && src <= bound) {
        return;
    }
    FLAG_N = (src < 0) << 7;
    m68ki_exception_trap(EXCEPTION_CHK);
}

static void m68k_op_chk_16_pi(void)
{
    sint src = MAKE_INT_16(DX);
    sint bound = MAKE_INT_16(OPER_AY_PI_16());

    FLAG_Z = ZFLAG_16(src); /* Undocumented */
    FLAG_V = VFLAG_CLEAR;   /* Undocumented */
    FLAG_C = CFLAG_CLEAR;   /* Undocumented */

    if (src >= 0 && src <= bound) {
        return;
    }
    FLAG_N = (src < 0) << 7;
    m68ki_exception_trap(EXCEPTION_CHK);
}

static void m68k_op_chk_16_pd(void)
{
    sint src = MAKE_INT_16(DX);
    sint bound = MAKE_INT_16(OPER_AY_PD_16());

    FLAG_Z = ZFLAG_16(src); /* Undocumented */
    FLAG_V = VFLAG_CLEAR;   /* Undocumented */
    FLAG_C = CFLAG_CLEAR;   /* Undocumented */

    if (src >= 0 && src <= bound) {
        return;
    }
    FLAG_N = (src < 0) << 7;
    m68ki_exception_trap(EXCEPTION_CHK);
}

static void m68k_op_chk_16_di(void)
{
    sint src = MAKE_INT_16(DX);
    sint bound = MAKE_INT_16(OPER_AY_DI_16());

    FLAG_Z = ZFLAG_16(src); /* Undocumented */
    FLAG_V = VFLAG_CLEAR;   /* Undocumented */
    FLAG_C = CFLAG_CLEAR;   /* Undocumented */

    if (src >= 0 && src <= bound) {
        return;
    }
    FLAG_N = (src < 0) << 7;
    m68ki_exception_trap(EXCEPTION_CHK);
}

static void m68k_op_chk_16_ix(void)
{
    sint src = MAKE_INT_16(DX);
    sint bound = MAKE_INT_16(OPER_AY_IX_16());

    FLAG_Z = ZFLAG_16(src); /* Undocumented */
    FLAG_V = VFLAG_CLEAR;   /* Undocumented */
    FLAG_C = CFLAG_CLEAR;   /* Undocumented */

    if (src >= 0 && src <= bound) {
        return;
    }
    FLAG_N = (src < 0) << 7;
    m68ki_exception_trap(EXCEPTION_CHK);
}

static void m68k_op_chk_16_aw(void)
{
    sint src = MAKE_INT_16(DX);
    sint bound = MAKE_INT_16(OPER_AW_16());

    FLAG_Z = ZFLAG_16(src); /* Undocumented */
    FLAG_V = VFLAG_CLEAR;   /* Undocumented */
    FLAG_C = CFLAG_CLEAR;   /* Undocumented */

    if (src >= 0 && src <= bound) {
        return;
    }
    FLAG_N = (src < 0) << 7;
    m68ki_exception_trap(EXCEPTION_CHK);
}

static void m68k_op_chk_16_al(void)
{
    sint src = MAKE_INT_16(DX);
    sint bound = MAKE_INT_16(OPER_AL_16());

    FLAG_Z = ZFLAG_16(src); /* Undocumented */
    FLAG_V = VFLAG_CLEAR;   /* Undocumented */
    FLAG_C = CFLAG_CLEAR;   /* Undocumented */

    if (src >= 0 && src <= bound) {
        return;
    }
    FLAG_N = (src < 0) << 7;
    m68ki_exception_trap(EXCEPTION_CHK);
}

static void m68k_op_chk_16_pcdi(void)
{
    sint src = MAKE_INT_16(DX);
    sint bound = MAKE_INT_16(OPER_PCDI_16());

    FLAG_Z = ZFLAG_16(src); /* Undocumented */
    FLAG_V = VFLAG_CLEAR;   /* Undocumented */
    FLAG_C = CFLAG_CLEAR;   /* Undocumented */

    if (src >= 0 && src <= bound) {
        return;
    }
    FLAG_N = (src < 0) << 7;
    m68ki_exception_trap(EXCEPTION_CHK);
}

static void m68k_op_chk_16_pcix(void)
{
    sint src = MAKE_INT_16(DX);
    sint bound = MAKE_INT_16(OPER_PCIX_16());

    FLAG_Z = ZFLAG_16(src); /* Undocumented */
    FLAG_V = VFLAG_CLEAR;   /* Undocumented */
    FLAG_C = CFLAG_CLEAR;   /* Undocumented */

    if (src >= 0 && src <= bound) {
        return;
    }
    FLAG_N = (src < 0) << 7;
    m68ki_exception_trap(EXCEPTION_CHK);
}

static void m68k_op_chk_16_i(void)
{
    sint src = MAKE_INT_16(DX);
    sint bound = MAKE_INT_16(OPER_I_16());

    FLAG_Z = ZFLAG_16(src); /* Undocumented */
    FLAG_V = VFLAG_CLEAR;   /* Undocumented */
    FLAG_C = CFLAG_CLEAR;   /* Undocumented */

    if (src >= 0 && src <= bound) {
        return;
    }
    FLAG_N = (src < 0) << 7;
    m68ki_exception_trap(EXCEPTION_CHK);
}

static void m68k_op_chk_32_d(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        sint src = MAKE_INT_32(DX);
        sint bound = MAKE_INT_32(DY);

        FLAG_Z = ZFLAG_32(src); /* Undocumented */
        FLAG_V = VFLAG_CLEAR;   /* Undocumented */
        FLAG_C = CFLAG_CLEAR;   /* Undocumented */

        if (src >= 0 && src <= bound) {
            return;
        }
        FLAG_N = (src < 0) << 7;
        m68ki_exception_trap(EXCEPTION_CHK);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk_32_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        sint src = MAKE_INT_32(DX);
        sint bound = MAKE_INT_32(OPER_AY_AI_32());

        FLAG_Z = ZFLAG_32(src); /* Undocumented */
        FLAG_V = VFLAG_CLEAR;   /* Undocumented */
        FLAG_C = CFLAG_CLEAR;   /* Undocumented */

        if (src >= 0 && src <= bound) {
            return;
        }
        FLAG_N = (src < 0) << 7;
        m68ki_exception_trap(EXCEPTION_CHK);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk_32_pi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        sint src = MAKE_INT_32(DX);
        sint bound = MAKE_INT_32(OPER_AY_PI_32());

        FLAG_Z = ZFLAG_32(src); /* Undocumented */
        FLAG_V = VFLAG_CLEAR;   /* Undocumented */
        FLAG_C = CFLAG_CLEAR;   /* Undocumented */

        if (src >= 0 && src <= bound) {
            return;
        }
        FLAG_N = (src < 0) << 7;
        m68ki_exception_trap(EXCEPTION_CHK);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk_32_pd(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        sint src = MAKE_INT_32(DX);
        sint bound = MAKE_INT_32(OPER_AY_PD_32());

        FLAG_Z = ZFLAG_32(src); /* Undocumented */
        FLAG_V = VFLAG_CLEAR;   /* Undocumented */
        FLAG_C = CFLAG_CLEAR;   /* Undocumented */

        if (src >= 0 && src <= bound) {
            return;
        }
        FLAG_N = (src < 0) << 7;
        m68ki_exception_trap(EXCEPTION_CHK);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk_32_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        sint src = MAKE_INT_32(DX);
        sint bound = MAKE_INT_32(OPER_AY_DI_32());

        FLAG_Z = ZFLAG_32(src); /* Undocumented */
        FLAG_V = VFLAG_CLEAR;   /* Undocumented */
        FLAG_C = CFLAG_CLEAR;   /* Undocumented */

        if (src >= 0 && src <= bound) {
            return;
        }
        FLAG_N = (src < 0) << 7;
        m68ki_exception_trap(EXCEPTION_CHK);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk_32_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        sint src = MAKE_INT_32(DX);
        sint bound = MAKE_INT_32(OPER_AY_IX_32());

        FLAG_Z = ZFLAG_32(src); /* Undocumented */
        FLAG_V = VFLAG_CLEAR;   /* Undocumented */
        FLAG_C = CFLAG_CLEAR;   /* Undocumented */

        if (src >= 0 && src <= bound) {
            return;
        }
        FLAG_N = (src < 0) << 7;
        m68ki_exception_trap(EXCEPTION_CHK);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk_32_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        sint src = MAKE_INT_32(DX);
        sint bound = MAKE_INT_32(OPER_AW_32());

        FLAG_Z = ZFLAG_32(src); /* Undocumented */
        FLAG_V = VFLAG_CLEAR;   /* Undocumented */
        FLAG_C = CFLAG_CLEAR;   /* Undocumented */

        if (src >= 0 && src <= bound) {
            return;
        }
        FLAG_N = (src < 0) << 7;
        m68ki_exception_trap(EXCEPTION_CHK);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk_32_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        sint src = MAKE_INT_32(DX);
        sint bound = MAKE_INT_32(OPER_AL_32());

        FLAG_Z = ZFLAG_32(src); /* Undocumented */
        FLAG_V = VFLAG_CLEAR;   /* Undocumented */
        FLAG_C = CFLAG_CLEAR;   /* Undocumented */

        if (src >= 0 && src <= bound) {
            return;
        }
        FLAG_N = (src < 0) << 7;
        m68ki_exception_trap(EXCEPTION_CHK);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk_32_pcdi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        sint src = MAKE_INT_32(DX);
        sint bound = MAKE_INT_32(OPER_PCDI_32());

        FLAG_Z = ZFLAG_32(src); /* Undocumented */
        FLAG_V = VFLAG_CLEAR;   /* Undocumented */
        FLAG_C = CFLAG_CLEAR;   /* Undocumented */

        if (src >= 0 && src <= bound) {
            return;
        }
        FLAG_N = (src < 0) << 7;
        m68ki_exception_trap(EXCEPTION_CHK);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk_32_pcix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        sint src = MAKE_INT_32(DX);
        sint bound = MAKE_INT_32(OPER_PCIX_32());

        FLAG_Z = ZFLAG_32(src); /* Undocumented */
        FLAG_V = VFLAG_CLEAR;   /* Undocumented */
        FLAG_C = CFLAG_CLEAR;   /* Undocumented */

        if (src >= 0 && src <= bound) {
            return;
        }
        FLAG_N = (src < 0) << 7;
        m68ki_exception_trap(EXCEPTION_CHK);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk_32_i(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        sint src = MAKE_INT_32(DX);
        sint bound = MAKE_INT_32(OPER_I_32());

        FLAG_Z = ZFLAG_32(src); /* Undocumented */
        FLAG_V = VFLAG_CLEAR;   /* Undocumented */
        FLAG_C = CFLAG_CLEAR;   /* Undocumented */

        if (src >= 0 && src <= bound) {
            return;
        }
        FLAG_N = (src < 0) << 7;
        m68ki_exception_trap(EXCEPTION_CHK);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_8_pcdi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15] & 0xff;
        uint ea = EA_PCDI_8();
        sint lower_bound = m68ki_read_pcrel_8(ea);
        sint upper_bound = m68ki_read_pcrel_8(ea + 1);

        if (!BIT_F(word2)) {
            compare = (int32)(int8)compare;
        }

        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }

    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_8_pcix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15] & 0xff;
        uint ea = EA_PCIX_8();
        sint lower_bound = m68ki_read_pcrel_8(ea);
        sint upper_bound = m68ki_read_pcrel_8(ea + 1);

        if (!BIT_F(word2)) {
            compare = (int32)(int8)compare;
        }
        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||, faster operation short circuits

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_8_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15] & 0xff;
        uint ea = EA_AY_AI_8();
        sint lower_bound = (int8)m68ki_read_8(ea);
        sint upper_bound = (int8)m68ki_read_8(ea + 1);

        if (!BIT_F(word2)) {
            compare = (int32)(int8)compare;
        }

        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_8_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15] & 0xff;
        uint ea = EA_AY_DI_8();
        sint lower_bound = (int8)m68ki_read_8(ea);
        sint upper_bound = (int8)m68ki_read_8(ea + 1);

        if (!BIT_F(word2)) {
            compare = (int32)(int8)compare;
        }

        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_8_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15] & 0xff;
        uint ea = EA_AY_IX_8();
        sint lower_bound = (int8)m68ki_read_8(ea);
        sint upper_bound = (int8)m68ki_read_8(ea + 1);

        if (!BIT_F(word2)) {
            compare = (int32)(int8)compare;
        }

        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_8_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15] & 0xff;
        uint ea = EA_AW_8();
        sint lower_bound = (int8)m68ki_read_8(ea);
        sint upper_bound = (int8)m68ki_read_8(ea + 1);

        if (!BIT_F(word2)) {
            compare = (int32)(int8)compare;
        }

        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_8_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15] & 0xff;
        uint ea = EA_AL_8();
        sint lower_bound = (int8)m68ki_read_8(ea);
        sint upper_bound = (int8)m68ki_read_8(ea + 1);

        if (!BIT_F(word2)) {
            compare = (int32)(int8)compare;
        }

        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_16_pcdi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15] & 0xffff;
        uint ea = EA_PCDI_16();
        sint lower_bound = (int16)m68ki_read_pcrel_16(ea);
        sint upper_bound = (int16)m68ki_read_pcrel_16(ea + 2);

        if (!BIT_F(word2)) {
            compare = (int32)(int16)compare;
        }
        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_16_pcix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15] & 0xffff;
        uint ea = EA_PCIX_16();
        sint lower_bound = (int16)m68ki_read_pcrel_16(ea);
        sint upper_bound = (int16)m68ki_read_pcrel_16(ea + 2);

        if (!BIT_F(word2)) {
            compare = (int32)(int16)compare;
        }
        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_16_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15] & 0xffff;
        uint ea = EA_AY_AI_16();
        sint lower_bound = (int16)m68ki_read_16(ea);
        sint upper_bound = (int16)m68ki_read_16(ea + 2);

        if (!BIT_F(word2)) {
            compare = (int32)(int16)compare;
        }
        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_16_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15] & 0xffff;
        uint ea = EA_AY_DI_16();
        sint lower_bound = (int16)m68ki_read_16(ea);
        sint upper_bound = (int16)m68ki_read_16(ea + 2);

        if (!BIT_F(word2)) {
            compare = (int32)(int16)compare;
        }
        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_16_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15] & 0xffff;
        uint ea = EA_AY_IX_16();
        sint lower_bound = (int16)m68ki_read_16(ea);
        sint upper_bound = (int16)m68ki_read_16(ea + 2);

        if (!BIT_F(word2)) {
            compare = (int32)(int16)compare;
        }
        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_16_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15] & 0xffff;
        uint ea = EA_AW_16();
        sint lower_bound = (int16)m68ki_read_16(ea);
        sint upper_bound = (int16)m68ki_read_16(ea + 2);

        if (!BIT_F(word2)) {
            compare = (int32)(int16)compare;
        }
        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_16_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15] & 0xffff;
        uint ea = EA_AL_16();
        sint lower_bound = (int16)m68ki_read_16(ea);
        sint upper_bound = (int16)m68ki_read_16(ea + 2);

        if (!BIT_F(word2)) {
            compare = (int32)(int16)compare;
        }
        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_32_pcdi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15];
        uint ea = EA_PCDI_32();
        sint lower_bound = m68ki_read_pcrel_32(ea);
        sint upper_bound = m68ki_read_pcrel_32(ea + 4);

        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_32_pcix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        sint compare = REG_DA[(word2 >> 12) & 15];
        uint ea = EA_PCIX_32();
        sint lower_bound = m68ki_read_32(ea);
        sint upper_bound = m68ki_read_32(ea + 4);

        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_32_ai(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        // JFF changed the logic. chk2/cmp2 uses signed values, not unsigned
        sint compare = REG_DA[(word2 >> 12) & 15];
        uint ea = EA_AY_AI_32();
        sint lower_bound = m68ki_read_32(ea);
        sint upper_bound = m68ki_read_32(ea + 4);

        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_32_di(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        // JFF changed the logic. chk2/cmp2 uses signed values, not unsigned
        sint compare = REG_DA[(word2 >> 12) & 15];
        uint ea = EA_AY_DI_32();
        sint lower_bound = m68ki_read_32(ea);
        sint upper_bound = m68ki_read_32(ea + 4);

        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_32_ix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        // JFF changed the logic. chk2/cmp2 uses signed values, not unsigned
        sint compare = REG_DA[(word2 >> 12) & 15];
        uint ea = EA_AY_IX_32();
        sint lower_bound = m68ki_read_32(ea);
        sint upper_bound = m68ki_read_32(ea + 4);

        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_32_aw(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        // JFF changed the logic. chk2/cmp2 uses signed values, not unsigned
        sint compare = REG_DA[(word2 >> 12) & 15];
        uint ea = EA_AW_32();
        sint lower_bound = m68ki_read_32(ea);
        sint upper_bound = m68ki_read_32(ea + 4);

        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_chk2cmp2_32_al(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        // JFF changed the logic. chk2/cmp2 uses signed values, not unsigned
        sint compare = REG_DA[(word2 >> 12) & 15];
        uint ea = EA_AL_32();
        sint lower_bound = m68ki_read_32(ea);
        sint upper_bound = m68ki_read_32(ea + 4);

        FLAG_Z = !((upper_bound == compare) || (lower_bound == compare)); // JFF: | => ||

        FLAG_C = (lower_bound <= upper_bound ? compare < lower_bound || compare > upper_bound : compare > upper_bound || compare < lower_bound) << 8;

        if (COND_CS() && BIT_B(word2)) {
            m68ki_exception_trap(EXCEPTION_CHK);
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_clr_8_d(void)
{
    DY &= 0xffffff00;

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_8_al(void)
{
    m68ki_write_8(EA_AL_8(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_16_d(void)
{
    DY &= 0xffff0000;

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_16_ai(void)
{
    m68ki_write_16(EA_AY_AI_16(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_16_pi(void)
{
    m68ki_write_16(EA_AY_PI_16(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_16_pd(void)
{
    m68ki_write_16(EA_AY_PD_16(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_16_di(void)
{
    m68ki_write_16(EA_AY_DI_16(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_16_ix(void)
{
    m68ki_write_16(EA_AY_IX_16(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_16_aw(void)
{
    m68ki_write_16(EA_AW_16(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_16_al(void)
{
    m68ki_write_16(EA_AL_16(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_32_d(void)
{
    DY = 0;

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_32_ai(void)
{
    m68ki_write_32(EA_AY_AI_32(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_32_pi(void)
{
    m68ki_write_32(EA_AY_PI_32(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_32_pd(void)
{
    m68ki_write_32(EA_AY_PD_32(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_32_di(void)
{
    m68ki_write_32(EA_AY_DI_32(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_32_ix(void)
{
    m68ki_write_32(EA_AY_IX_32(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_32_aw(void)
{
    m68ki_write_32(EA_AW_32(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_clr_32_al(void)
{
    m68ki_write_32(EA_AL_32(), 0);

    FLAG_N = NFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    FLAG_Z = ZFLAG_SET;
}

static void m68k_op_cmp_8_d(void)
{
    uint src = MASK_OUT_ABOVE_8(DY);
    uint dst = MASK_OUT_ABOVE_8(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmp_8_ai(void)
{
    uint src = OPER_AY_AI_8();
    uint dst = MASK_OUT_ABOVE_8(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmp_8_pi(void)
{
    uint src = OPER_AY_PI_8();
    uint dst = MASK_OUT_ABOVE_8(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmp_8_pi7(void)
{
    uint src = OPER_A7_PI_8();
    uint dst = MASK_OUT_ABOVE_8(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmp_8_pd(void)
{
    uint src = OPER_AY_PD_8();
    uint dst = MASK_OUT_ABOVE_8(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmp_8_pd7(void)
{
    uint src = OPER_A7_PD_8();
    uint dst = MASK_OUT_ABOVE_8(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmp_8_di(void)
{
    uint src = OPER_AY_DI_8();
    uint dst = MASK_OUT_ABOVE_8(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmp_8_ix(void)
{
    uint src = OPER_AY_IX_8();
    uint dst = MASK_OUT_ABOVE_8(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmp_8_aw(void)
{
    uint src = OPER_AW_8();
    uint dst = MASK_OUT_ABOVE_8(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmp_8_al(void)
{
    uint src = OPER_AL_8();
    uint dst = MASK_OUT_ABOVE_8(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmp_8_pcdi(void)
{
    uint src = OPER_PCDI_8();
    uint dst = MASK_OUT_ABOVE_8(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmp_8_pcix(void)
{
    uint src = OPER_PCIX_8();
    uint dst = MASK_OUT_ABOVE_8(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmp_8_i(void)
{
    uint src = OPER_I_8();
    uint dst = MASK_OUT_ABOVE_8(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmp_16_d(void)
{
    uint src = MASK_OUT_ABOVE_16(DY);
    uint dst = MASK_OUT_ABOVE_16(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmp_16_a(void)
{
    uint src = MASK_OUT_ABOVE_16(AY);
    uint dst = MASK_OUT_ABOVE_16(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmp_16_ai(void)
{
    uint src = OPER_AY_AI_16();
    uint dst = MASK_OUT_ABOVE_16(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmp_16_pi(void)
{
    uint src = OPER_AY_PI_16();
    uint dst = MASK_OUT_ABOVE_16(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmp_16_pd(void)
{
    uint src = OPER_AY_PD_16();
    uint dst = MASK_OUT_ABOVE_16(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmp_16_di(void)
{
    uint src = OPER_AY_DI_16();
    uint dst = MASK_OUT_ABOVE_16(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmp_16_ix(void)
{
    uint src = OPER_AY_IX_16();
    uint dst = MASK_OUT_ABOVE_16(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmp_16_aw(void)
{
    uint src = OPER_AW_16();
    uint dst = MASK_OUT_ABOVE_16(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmp_16_al(void)
{
    uint src = OPER_AL_16();
    uint dst = MASK_OUT_ABOVE_16(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmp_16_pcdi(void)
{
    uint src = OPER_PCDI_16();
    uint dst = MASK_OUT_ABOVE_16(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmp_16_pcix(void)
{
    uint src = OPER_PCIX_16();
    uint dst = MASK_OUT_ABOVE_16(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmp_16_i(void)
{
    uint src = OPER_I_16();
    uint dst = MASK_OUT_ABOVE_16(DX);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmp_32_d(void)
{
    uint src = DY;
    uint dst = DX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmp_32_a(void)
{
    uint src = AY;
    uint dst = DX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmp_32_ai(void)
{
    uint src = OPER_AY_AI_32();
    uint dst = DX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmp_32_pi(void)
{
    uint src = OPER_AY_PI_32();
    uint dst = DX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmp_32_pd(void)
{
    uint src = OPER_AY_PD_32();
    uint dst = DX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmp_32_di(void)
{
    uint src = OPER_AY_DI_32();
    uint dst = DX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmp_32_ix(void)
{
    uint src = OPER_AY_IX_32();
    uint dst = DX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmp_32_aw(void)
{
    uint src = OPER_AW_32();
    uint dst = DX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmp_32_al(void)
{
    uint src = OPER_AL_32();
    uint dst = DX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmp_32_pcdi(void)
{
    uint src = OPER_PCDI_32();
    uint dst = DX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmp_32_pcix(void)
{
    uint src = OPER_PCIX_32();
    uint dst = DX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmp_32_i(void)
{
    uint src = OPER_I_32();
    uint dst = DX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_16_d(void)
{
    uint src = MAKE_INT_16(DY);
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_16_a(void)
{
    uint src = MAKE_INT_16(AY);
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_16_ai(void)
{
    uint src = MAKE_INT_16(OPER_AY_AI_16());
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_16_pi(void)
{
    uint src = MAKE_INT_16(OPER_AY_PI_16());
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_16_pd(void)
{
    uint src = MAKE_INT_16(OPER_AY_PD_16());
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_16_di(void)
{
    uint src = MAKE_INT_16(OPER_AY_DI_16());
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_16_ix(void)
{
    uint src = MAKE_INT_16(OPER_AY_IX_16());
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_16_aw(void)
{
    uint src = MAKE_INT_16(OPER_AW_16());
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_16_al(void)
{
    uint src = MAKE_INT_16(OPER_AL_16());
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_16_pcdi(void)
{
    uint src = MAKE_INT_16(OPER_PCDI_16());
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_16_pcix(void)
{
    uint src = MAKE_INT_16(OPER_PCIX_16());
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_16_i(void)
{
    uint src = MAKE_INT_16(OPER_I_16());
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_32_d(void)
{
    uint src = DY;
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_32_a(void)
{
    uint src = AY;
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_32_ai(void)
{
    uint src = OPER_AY_AI_32();
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_32_pi(void)
{
    uint src = OPER_AY_PI_32();
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_32_pd(void)
{
    uint src = OPER_AY_PD_32();
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_32_di(void)
{
    uint src = OPER_AY_DI_32();
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_32_ix(void)
{
    uint src = OPER_AY_IX_32();
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_32_aw(void)
{
    uint src = OPER_AW_32();
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_32_al(void)
{
    uint src = OPER_AL_32();
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_32_pcdi(void)
{
    uint src = OPER_PCDI_32();
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_32_pcix(void)
{
    uint src = OPER_PCIX_32();
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpa_32_i(void)
{
    uint src = OPER_I_32();
    uint dst = AX;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpi_8_d(void)
{
    uint src = OPER_I_8();
    uint dst = MASK_OUT_ABOVE_8(DY);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmpi_8_ai(void)
{
    uint src = OPER_I_8();
    uint dst = OPER_AY_AI_8();
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmpi_8_pi(void)
{
    uint src = OPER_I_8();
    uint dst = OPER_AY_PI_8();
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmpi_8_pi7(void)
{
    uint src = OPER_I_8();
    uint dst = OPER_A7_PI_8();
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmpi_8_pd(void)
{
    uint src = OPER_I_8();
    uint dst = OPER_AY_PD_8();
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmpi_8_pd7(void)
{
    uint src = OPER_I_8();
    uint dst = OPER_A7_PD_8();
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmpi_8_di(void)
{
    uint src = OPER_I_8();
    uint dst = OPER_AY_DI_8();
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmpi_8_ix(void)
{
    uint src = OPER_I_8();
    uint dst = OPER_AY_IX_8();
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmpi_8_aw(void)
{
    uint src = OPER_I_8();
    uint dst = OPER_AW_8();
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmpi_8_al(void)
{
    uint src = OPER_I_8();
    uint dst = OPER_AL_8();
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmpi_8_pcdi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint src = OPER_I_8();
        uint dst = OPER_PCDI_8();
        uint res = dst - src;

        FLAG_N = NFLAG_8(res);
        FLAG_Z = MASK_OUT_ABOVE_8(res);
        FLAG_V = VFLAG_SUB_8(src, dst, res);
        FLAG_C = CFLAG_8(res);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cmpi_8_pcix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint src = OPER_I_8();
        uint dst = OPER_PCIX_8();
        uint res = dst - src;

        FLAG_N = NFLAG_8(res);
        FLAG_Z = MASK_OUT_ABOVE_8(res);
        FLAG_V = VFLAG_SUB_8(src, dst, res);
        FLAG_C = CFLAG_8(res);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cmpi_16_d(void)
{
    uint src = OPER_I_16();
    uint dst = MASK_OUT_ABOVE_16(DY);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmpi_16_ai(void)
{
    uint src = OPER_I_16();
    uint dst = OPER_AY_AI_16();
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmpi_16_pi(void)
{
    uint src = OPER_I_16();
    uint dst = OPER_AY_PI_16();
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmpi_16_pd(void)
{
    uint src = OPER_I_16();
    uint dst = OPER_AY_PD_16();
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmpi_16_di(void)
{
    uint src = OPER_I_16();
    uint dst = OPER_AY_DI_16();
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmpi_16_ix(void)
{
    uint src = OPER_I_16();
    uint dst = OPER_AY_IX_16();
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmpi_16_aw(void)
{
    uint src = OPER_I_16();
    uint dst = OPER_AW_16();
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmpi_16_al(void)
{
    uint src = OPER_I_16();
    uint dst = OPER_AL_16();
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmpi_16_pcdi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint src = OPER_I_16();
        uint dst = OPER_PCDI_16();
        uint res = dst - src;

        FLAG_N = NFLAG_16(res);
        FLAG_Z = MASK_OUT_ABOVE_16(res);
        FLAG_V = VFLAG_SUB_16(src, dst, res);
        FLAG_C = CFLAG_16(res);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cmpi_16_pcix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint src = OPER_I_16();
        uint dst = OPER_PCIX_16();
        uint res = dst - src;

        FLAG_N = NFLAG_16(res);
        FLAG_Z = MASK_OUT_ABOVE_16(res);
        FLAG_V = VFLAG_SUB_16(src, dst, res);
        FLAG_C = CFLAG_16(res);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cmpi_32_d(void)
{
    uint src = OPER_I_32();
    uint dst = DY;
    uint res = dst - src;

    m68ki_cmpild_callback(src, REG_IR & 7); /* auto-disable (see m68kcpu.h) */
    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpi_32_ai(void)
{
    uint src = OPER_I_32();
    uint dst = OPER_AY_AI_32();
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpi_32_pi(void)
{
    uint src = OPER_I_32();
    uint dst = OPER_AY_PI_32();
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpi_32_pd(void)
{
    uint src = OPER_I_32();
    uint dst = OPER_AY_PD_32();
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpi_32_di(void)
{
    uint src = OPER_I_32();
    uint dst = OPER_AY_DI_32();
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpi_32_ix(void)
{
    uint src = OPER_I_32();
    uint dst = OPER_AY_IX_32();
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpi_32_aw(void)
{
    uint src = OPER_I_32();
    uint dst = OPER_AW_32();
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpi_32_al(void)
{
    uint src = OPER_I_32();
    uint dst = OPER_AL_32();
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cmpi_32_pcdi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint src = OPER_I_32();
        uint dst = OPER_PCDI_32();
        uint res = dst - src;

        FLAG_N = NFLAG_32(res);
        FLAG_Z = MASK_OUT_ABOVE_32(res);
        FLAG_V = VFLAG_SUB_32(src, dst, res);
        FLAG_C = CFLAG_SUB_32(src, dst, res);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cmpi_32_pcix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint src = OPER_I_32();
        uint dst = OPER_PCIX_32();
        uint res = dst - src;

        FLAG_N = NFLAG_32(res);
        FLAG_Z = MASK_OUT_ABOVE_32(res);
        FLAG_V = VFLAG_SUB_32(src, dst, res);
        FLAG_C = CFLAG_SUB_32(src, dst, res);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_cmpm_8_ax7(void)
{
    uint src = OPER_AY_PI_8();
    uint dst = OPER_A7_PI_8();
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmpm_8_ay7(void)
{
    uint src = OPER_A7_PI_8();
    uint dst = OPER_AX_PI_8();
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmpm_8_axy7(void)
{
    uint src = OPER_A7_PI_8();
    uint dst = OPER_A7_PI_8();
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmpm_8(void)
{
    uint src = OPER_AY_PI_8();
    uint dst = OPER_AX_PI_8();
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_C = CFLAG_8(res);
}

static void m68k_op_cmpm_16(void)
{
    uint src = OPER_AY_PI_16();
    uint dst = OPER_AX_PI_16();
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_C = CFLAG_16(res);
}

static void m68k_op_cmpm_32(void)
{
    uint src = OPER_AY_PI_32();
    uint dst = OPER_AX_PI_32();
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_C = CFLAG_SUB_32(src, dst, res);
}

static void m68k_op_cpbcc_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        M68K_DO_LOG((M68K_LOG_FILEHANDLE "%s at %08x: called unimplemented instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PC - 2), REG_IR,
                     m68k_disassemble_quick(ADDRESS_68K(REG_PC - 2))));
        return;
    }
    m68ki_exception_1111();
}

static void m68k_op_cpdbcc_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        M68K_DO_LOG((M68K_LOG_FILEHANDLE "%s at %08x: called unimplemented instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PC - 2), REG_IR,
                     m68k_disassemble_quick(ADDRESS_68K(REG_PC - 2))));
        return;
    }
    m68ki_exception_1111();
}

static void m68k_op_cpgen_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        M68K_DO_LOG((M68K_LOG_FILEHANDLE "%s at %08x: called unimplemented instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PC - 2), REG_IR,
                     m68k_disassemble_quick(ADDRESS_68K(REG_PC - 2))));
        return;
    }
    m68ki_exception_1111();
}

static void m68k_op_cpscc_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        M68K_DO_LOG((M68K_LOG_FILEHANDLE "%s at %08x: called unimplemented instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PC - 2), REG_IR,
                     m68k_disassemble_quick(ADDRESS_68K(REG_PC - 2))));
        return;
    }
    m68ki_exception_1111();
}

static void m68k_op_cptrapcc_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        M68K_DO_LOG((M68K_LOG_FILEHANDLE "%s at %08x: called unimplemented instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PC - 2), REG_IR,
                     m68k_disassemble_quick(ADDRESS_68K(REG_PC - 2))));
        // JFF: unsupported, but at least if the trap doesn't occur, app should still work, so at least PC increase is correct
        REG_PC += 4;
        return;
    }
    m68ki_exception_1111();
}

static void m68k_op_dbt_16(void)
{
    REG_PC += 2;
}

static void m68k_op_dbf_16(void)
{
    uint* r_dst = &DY;
    uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
    if (res != 0xffff) {
        uint offset = OPER_I_16();
        REG_PC -= 2;
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_branch_16(offset);
        USE_CYCLES(CYC_DBCC_F_NOEXP);
        return;
    }
    REG_PC += 2;
    USE_CYCLES(CYC_DBCC_F_EXP);
}

static void m68k_op_dbhi_16(void)
{
    if (COND_NOT_HI()) {
        uint* r_dst = &DY;
        uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        if (res != 0xffff) {
            uint offset = OPER_I_16();
            REG_PC -= 2;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_16(offset);
            USE_CYCLES(CYC_DBCC_F_NOEXP);
            return;
        }
        REG_PC += 2;
        USE_CYCLES(CYC_DBCC_F_EXP);
        return;
    }
    REG_PC += 2;
}

static void m68k_op_dbls_16(void)
{
    if (COND_NOT_LS()) {
        uint* r_dst = &DY;
        uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        if (res != 0xffff) {
            uint offset = OPER_I_16();
            REG_PC -= 2;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_16(offset);
            USE_CYCLES(CYC_DBCC_F_NOEXP);
            return;
        }
        REG_PC += 2;
        USE_CYCLES(CYC_DBCC_F_EXP);
        return;
    }
    REG_PC += 2;
}

static void m68k_op_dbcc_16(void)
{
    if (COND_NOT_CC()) {
        uint* r_dst = &DY;
        uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        if (res != 0xffff) {
            uint offset = OPER_I_16();
            REG_PC -= 2;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_16(offset);
            USE_CYCLES(CYC_DBCC_F_NOEXP);
            return;
        }
        REG_PC += 2;
        USE_CYCLES(CYC_DBCC_F_EXP);
        return;
    }
    REG_PC += 2;
}

static void m68k_op_dbcs_16(void)
{
    if (COND_NOT_CS()) {
        uint* r_dst = &DY;
        uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        if (res != 0xffff) {
            uint offset = OPER_I_16();
            REG_PC -= 2;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_16(offset);
            USE_CYCLES(CYC_DBCC_F_NOEXP);
            return;
        }
        REG_PC += 2;
        USE_CYCLES(CYC_DBCC_F_EXP);
        return;
    }
    REG_PC += 2;
}

static void m68k_op_dbne_16(void)
{
    if (COND_NOT_NE()) {
        uint* r_dst = &DY;
        uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        if (res != 0xffff) {
            uint offset = OPER_I_16();
            REG_PC -= 2;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_16(offset);
            USE_CYCLES(CYC_DBCC_F_NOEXP);
            return;
        }
        REG_PC += 2;
        USE_CYCLES(CYC_DBCC_F_EXP);
        return;
    }
    REG_PC += 2;
}

static void m68k_op_dbeq_16(void)
{
    if (COND_NOT_EQ()) {
        uint* r_dst = &DY;
        uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        if (res != 0xffff) {
            uint offset = OPER_I_16();
            REG_PC -= 2;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_16(offset);
            USE_CYCLES(CYC_DBCC_F_NOEXP);
            return;
        }
        REG_PC += 2;
        USE_CYCLES(CYC_DBCC_F_EXP);
        return;
    }
    REG_PC += 2;
}

static void m68k_op_dbvc_16(void)
{
    if (COND_NOT_VC()) {
        uint* r_dst = &DY;
        uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        if (res != 0xffff) {
            uint offset = OPER_I_16();
            REG_PC -= 2;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_16(offset);
            USE_CYCLES(CYC_DBCC_F_NOEXP);
            return;
        }
        REG_PC += 2;
        USE_CYCLES(CYC_DBCC_F_EXP);
        return;
    }
    REG_PC += 2;
}

static void m68k_op_dbvs_16(void)
{
    if (COND_NOT_VS()) {
        uint* r_dst = &DY;
        uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        if (res != 0xffff) {
            uint offset = OPER_I_16();
            REG_PC -= 2;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_16(offset);
            USE_CYCLES(CYC_DBCC_F_NOEXP);
            return;
        }
        REG_PC += 2;
        USE_CYCLES(CYC_DBCC_F_EXP);
        return;
    }
    REG_PC += 2;
}

static void m68k_op_dbpl_16(void)
{
    if (COND_NOT_PL()) {
        uint* r_dst = &DY;
        uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        if (res != 0xffff) {
            uint offset = OPER_I_16();
            REG_PC -= 2;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_16(offset);
            USE_CYCLES(CYC_DBCC_F_NOEXP);
            return;
        }
        REG_PC += 2;
        USE_CYCLES(CYC_DBCC_F_EXP);
        return;
    }
    REG_PC += 2;
}

static void m68k_op_dbmi_16(void)
{
    if (COND_NOT_MI()) {
        uint* r_dst = &DY;
        uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        if (res != 0xffff) {
            uint offset = OPER_I_16();
            REG_PC -= 2;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_16(offset);
            USE_CYCLES(CYC_DBCC_F_NOEXP);
            return;
        }
        REG_PC += 2;
        USE_CYCLES(CYC_DBCC_F_EXP);
        return;
    }
    REG_PC += 2;
}

static void m68k_op_dbge_16(void)
{
    if (COND_NOT_GE()) {
        uint* r_dst = &DY;
        uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        if (res != 0xffff) {
            uint offset = OPER_I_16();
            REG_PC -= 2;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_16(offset);
            USE_CYCLES(CYC_DBCC_F_NOEXP);
            return;
        }
        REG_PC += 2;
        USE_CYCLES(CYC_DBCC_F_EXP);
        return;
    }
    REG_PC += 2;
}

static void m68k_op_dblt_16(void)
{
    if (COND_NOT_LT()) {
        uint* r_dst = &DY;
        uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        if (res != 0xffff) {
            uint offset = OPER_I_16();
            REG_PC -= 2;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_16(offset);
            USE_CYCLES(CYC_DBCC_F_NOEXP);
            return;
        }
        REG_PC += 2;
        USE_CYCLES(CYC_DBCC_F_EXP);
        return;
    }
    REG_PC += 2;
}

static void m68k_op_dbgt_16(void)
{
    if (COND_NOT_GT()) {
        uint* r_dst = &DY;
        uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        if (res != 0xffff) {
            uint offset = OPER_I_16();
            REG_PC -= 2;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_16(offset);
            USE_CYCLES(CYC_DBCC_F_NOEXP);
            return;
        }
        REG_PC += 2;
        USE_CYCLES(CYC_DBCC_F_EXP);
        return;
    }
    REG_PC += 2;
}

static void m68k_op_dble_16(void)
{
    if (COND_NOT_LE()) {
        uint* r_dst = &DY;
        uint res = MASK_OUT_ABOVE_16(*r_dst - 1);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        if (res != 0xffff) {
            uint offset = OPER_I_16();
            REG_PC -= 2;
            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            m68ki_branch_16(offset);
            USE_CYCLES(CYC_DBCC_F_NOEXP);
            return;
        }
        REG_PC += 2;
        USE_CYCLES(CYC_DBCC_F_EXP);
        return;
    }
    REG_PC += 2;
}

static void m68k_op_divs_16_d(void)
{
    uint* r_dst = &DX;
    sint src = MAKE_INT_16(DY);
    sint quotient;
    sint remainder;

    if (src != 0) {
        if ((uint32)*r_dst == 0x80000000 && src == -1) {
            FLAG_Z = 0;
            FLAG_N = NFLAG_CLEAR;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = 0;
            return;
        }

        quotient = MAKE_INT_32(*r_dst) / src;
        remainder = MAKE_INT_32(*r_dst) % src;

        if (quotient == MAKE_INT_16(quotient)) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divs_16_ai(void)
{
    uint* r_dst = &DX;
    sint src = MAKE_INT_16(OPER_AY_AI_16());
    sint quotient;
    sint remainder;

    if (src != 0) {
        if ((uint32)*r_dst == 0x80000000 && src == -1) {
            FLAG_Z = 0;
            FLAG_N = NFLAG_CLEAR;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = 0;
            return;
        }

        quotient = MAKE_INT_32(*r_dst) / src;
        remainder = MAKE_INT_32(*r_dst) % src;

        if (quotient == MAKE_INT_16(quotient)) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divs_16_pi(void)
{
    uint* r_dst = &DX;
    sint src = MAKE_INT_16(OPER_AY_PI_16());
    sint quotient;
    sint remainder;

    if (src != 0) {
        if ((uint32)*r_dst == 0x80000000 && src == -1) {
            FLAG_Z = 0;
            FLAG_N = NFLAG_CLEAR;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = 0;
            return;
        }

        quotient = MAKE_INT_32(*r_dst) / src;
        remainder = MAKE_INT_32(*r_dst) % src;

        if (quotient == MAKE_INT_16(quotient)) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divs_16_pd(void)
{
    uint* r_dst = &DX;
    sint src = MAKE_INT_16(OPER_AY_PD_16());
    sint quotient;
    sint remainder;

    if (src != 0) {
        if ((uint32)*r_dst == 0x80000000 && src == -1) {
            FLAG_Z = 0;
            FLAG_N = NFLAG_CLEAR;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = 0;
            return;
        }

        quotient = MAKE_INT_32(*r_dst) / src;
        remainder = MAKE_INT_32(*r_dst) % src;

        if (quotient == MAKE_INT_16(quotient)) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divs_16_di(void)
{
    uint* r_dst = &DX;
    sint src = MAKE_INT_16(OPER_AY_DI_16());
    sint quotient;
    sint remainder;

    if (src != 0) {
        if ((uint32)*r_dst == 0x80000000 && src == -1) {
            FLAG_Z = 0;
            FLAG_N = NFLAG_CLEAR;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = 0;
            return;
        }

        quotient = MAKE_INT_32(*r_dst) / src;
        remainder = MAKE_INT_32(*r_dst) % src;

        if (quotient == MAKE_INT_16(quotient)) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divs_16_ix(void)
{
    uint* r_dst = &DX;
    sint src = MAKE_INT_16(OPER_AY_IX_16());
    sint quotient;
    sint remainder;

    if (src != 0) {
        if ((uint32)*r_dst == 0x80000000 && src == -1) {
            FLAG_Z = 0;
            FLAG_N = NFLAG_CLEAR;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = 0;
            return;
        }

        quotient = MAKE_INT_32(*r_dst) / src;
        remainder = MAKE_INT_32(*r_dst) % src;

        if (quotient == MAKE_INT_16(quotient)) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divs_16_aw(void)
{
    uint* r_dst = &DX;
    sint src = MAKE_INT_16(OPER_AW_16());
    sint quotient;
    sint remainder;

    if (src != 0) {
        if ((uint32)*r_dst == 0x80000000 && src == -1) {
            FLAG_Z = 0;
            FLAG_N = NFLAG_CLEAR;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = 0;
            return;
        }

        quotient = MAKE_INT_32(*r_dst) / src;
        remainder = MAKE_INT_32(*r_dst) % src;

        if (quotient == MAKE_INT_16(quotient)) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divs_16_al(void)
{
    uint* r_dst = &DX;
    sint src = MAKE_INT_16(OPER_AL_16());
    sint quotient;
    sint remainder;

    if (src != 0) {
        if ((uint32)*r_dst == 0x80000000 && src == -1) {
            FLAG_Z = 0;
            FLAG_N = NFLAG_CLEAR;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = 0;
            return;
        }

        quotient = MAKE_INT_32(*r_dst) / src;
        remainder = MAKE_INT_32(*r_dst) % src;

        if (quotient == MAKE_INT_16(quotient)) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divs_16_pcdi(void)
{
    uint* r_dst = &DX;
    sint src = MAKE_INT_16(OPER_PCDI_16());
    sint quotient;
    sint remainder;

    if (src != 0) {
        if ((uint32)*r_dst == 0x80000000 && src == -1) {
            FLAG_Z = 0;
            FLAG_N = NFLAG_CLEAR;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = 0;
            return;
        }

        quotient = MAKE_INT_32(*r_dst) / src;
        remainder = MAKE_INT_32(*r_dst) % src;

        if (quotient == MAKE_INT_16(quotient)) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divs_16_pcix(void)
{
    uint* r_dst = &DX;
    sint src = MAKE_INT_16(OPER_PCIX_16());
    sint quotient;
    sint remainder;

    if (src != 0) {
        if ((uint32)*r_dst == 0x80000000 && src == -1) {
            FLAG_Z = 0;
            FLAG_N = NFLAG_CLEAR;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = 0;
            return;
        }

        quotient = MAKE_INT_32(*r_dst) / src;
        remainder = MAKE_INT_32(*r_dst) % src;

        if (quotient == MAKE_INT_16(quotient)) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divs_16_i(void)
{
    uint* r_dst = &DX;
    sint src = MAKE_INT_16(OPER_I_16());
    sint quotient;
    sint remainder;

    if (src != 0) {
        if ((uint32)*r_dst == 0x80000000 && src == -1) {
            FLAG_Z = 0;
            FLAG_N = NFLAG_CLEAR;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = 0;
            return;
        }

        quotient = MAKE_INT_32(*r_dst) / src;
        remainder = MAKE_INT_32(*r_dst) % src;

        if (quotient == MAKE_INT_16(quotient)) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divu_16_d(void)
{
    uint* r_dst = &DX;
    uint src = MASK_OUT_ABOVE_16(DY);

    if (src != 0) {
        uint quotient = *r_dst / src;
        uint remainder = *r_dst % src;

        if (quotient < 0x10000) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divu_16_ai(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_AI_16();

    if (src != 0) {
        uint quotient = *r_dst / src;
        uint remainder = *r_dst % src;

        if (quotient < 0x10000) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divu_16_pi(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_PI_16();

    if (src != 0) {
        uint quotient = *r_dst / src;
        uint remainder = *r_dst % src;

        if (quotient < 0x10000) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divu_16_pd(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_PD_16();

    if (src != 0) {
        uint quotient = *r_dst / src;
        uint remainder = *r_dst % src;

        if (quotient < 0x10000) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divu_16_di(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_DI_16();

    if (src != 0) {
        uint quotient = *r_dst / src;
        uint remainder = *r_dst % src;

        if (quotient < 0x10000) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divu_16_ix(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_IX_16();

    if (src != 0) {
        uint quotient = *r_dst / src;
        uint remainder = *r_dst % src;

        if (quotient < 0x10000) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divu_16_aw(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AW_16();

    if (src != 0) {
        uint quotient = *r_dst / src;
        uint remainder = *r_dst % src;

        if (quotient < 0x10000) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divu_16_al(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AL_16();

    if (src != 0) {
        uint quotient = *r_dst / src;
        uint remainder = *r_dst % src;

        if (quotient < 0x10000) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divu_16_pcdi(void)
{
    uint* r_dst = &DX;
    uint src = OPER_PCDI_16();

    if (src != 0) {
        uint quotient = *r_dst / src;
        uint remainder = *r_dst % src;

        if (quotient < 0x10000) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divu_16_pcix(void)
{
    uint* r_dst = &DX;
    uint src = OPER_PCIX_16();

    if (src != 0) {
        uint quotient = *r_dst / src;
        uint remainder = *r_dst % src;

        if (quotient < 0x10000) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divu_16_i(void)
{
    uint* r_dst = &DX;
    uint src = OPER_I_16();

    if (src != 0) {
        uint quotient = *r_dst / src;
        uint remainder = *r_dst % src;

        if (quotient < 0x10000) {
            FLAG_Z = quotient;
            FLAG_N = NFLAG_16(quotient);
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            *r_dst = MASK_OUT_ABOVE_32(MASK_OUT_ABOVE_16(quotient) | (remainder << 16));
            return;
        }
        FLAG_V = VFLAG_SET;
        return;
    }
    m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
}

static void m68k_op_divl_32_d(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 divisor = DY;
        uint64 dividend = 0;
        uint64 quotient = 0;
        uint64 remainder = 0;

        if (divisor != 0) {
            if (BIT_A(word2)) /* 64 bit */
            {
                dividend = REG_D[word2 & 7];
                dividend <<= 32;
                dividend |= REG_D[(word2 >> 12) & 7];

                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)dividend / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)dividend % (sint64)((sint32)divisor));
                    if ((sint64)quotient != (sint64)((sint32)quotient)) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    if (quotient > 0xffffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    remainder = dividend % divisor;
                }
            } else /* 32 bit */
            {
                dividend = REG_D[(word2 >> 12) & 7];
                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)((sint32)dividend) / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)((sint32)dividend) % (sint64)((sint32)divisor));
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    remainder = dividend % divisor;
                }
            }

            REG_D[word2 & 7] = remainder;
            REG_D[(word2 >> 12) & 7] = quotient;

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint divisor = DY;
        uint dividend_hi = REG_D[word2 & 7];
        uint dividend_lo = REG_D[(word2 >> 12) & 7];
        uint quotient = 0;
        uint remainder = 0;
        uint dividend_neg = 0;
        uint divisor_neg = 0;
        sint i;
        uint overflow;

        if (divisor != 0) {
            /* quad / long : long quotient, long remainder */
            if (BIT_A(word2)) {
                if (BIT_B(word2)) /* signed */
                {
                    /* special case in signed divide */
                    if (dividend_hi == 0 && dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                        REG_D[word2 & 7] = 0;
                        REG_D[(word2 >> 12) & 7] = 0x80000000;

                        FLAG_N = NFLAG_SET;
                        FLAG_Z = ZFLAG_CLEAR;
                        FLAG_V = VFLAG_CLEAR;
                        FLAG_C = CFLAG_CLEAR;
                        return;
                    }
                    if (GET_MSB_32(dividend_hi)) {
                        dividend_neg = 1;
                        dividend_hi = (uint)MASK_OUT_ABOVE_32((-(sint)dividend_hi) - (dividend_lo != 0));
                        dividend_lo = (uint)MASK_OUT_ABOVE_32(-(sint)dividend_lo);
                    }
                    if (GET_MSB_32(divisor)) {
                        divisor_neg = 1;
                        divisor = (uint)MASK_OUT_ABOVE_32(-(sint)divisor);
                    }
                }

                /* if the upper long is greater than the divisor, we're overflowing. */
                if (dividend_hi >= divisor) {
                    FLAG_V = VFLAG_SET;
                    return;
                }

                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    remainder = (remainder << 1) + ((dividend_hi >> i) & 1);
                    if (remainder >= divisor) {
                        remainder -= divisor;
                        quotient++;
                    }
                }
                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    overflow = GET_MSB_32(remainder);
                    remainder = (remainder << 1) + ((dividend_lo >> i) & 1);
                    if (remainder >= divisor || overflow) {
                        remainder -= divisor;
                        quotient++;
                    }
                }

                if (BIT_B(word2)) /* signed */
                {
                    if (quotient > 0x7fffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    if (dividend_neg) {
                        remainder = (uint)MASK_OUT_ABOVE_32(-(sint)remainder);
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                    if (divisor_neg) {
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                }

                REG_D[word2 & 7] = remainder;
                REG_D[(word2 >> 12) & 7] = quotient;

                FLAG_N = NFLAG_32(quotient);
                FLAG_Z = quotient;
                FLAG_V = VFLAG_CLEAR;
                FLAG_C = CFLAG_CLEAR;
                return;
            }

            /* long / long: long quotient, maybe long remainder */
            if (BIT_B(word2)) /* signed */
            {
                /* Special case in divide */
                if (dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                    FLAG_N = NFLAG_SET;
                    FLAG_Z = ZFLAG_CLEAR;
                    FLAG_V = VFLAG_CLEAR;
                    FLAG_C = CFLAG_CLEAR;
                    REG_D[(word2 >> 12) & 7] = 0x80000000;
                    REG_D[word2 & 7] = 0;
                    return;
                }
                REG_D[word2 & 7] = MAKE_INT_32(dividend_lo) % MAKE_INT_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MAKE_INT_32(dividend_lo) / MAKE_INT_32(divisor);
            } else {
                REG_D[word2 & 7] = MASK_OUT_ABOVE_32(dividend_lo) % MASK_OUT_ABOVE_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(dividend_lo) / MASK_OUT_ABOVE_32(divisor);
            }

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_divl_32_ai(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 divisor = OPER_AY_AI_32();
        uint64 dividend = 0;
        uint64 quotient = 0;
        uint64 remainder = 0;

        if (divisor != 0) {
            if (BIT_A(word2)) /* 64 bit */
            {
                dividend = REG_D[word2 & 7];
                dividend <<= 32;
                dividend |= REG_D[(word2 >> 12) & 7];

                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)dividend / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)dividend % (sint64)((sint32)divisor));
                    if ((sint64)quotient != (sint64)((sint32)quotient)) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    if (quotient > 0xffffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    remainder = dividend % divisor;
                }
            } else /* 32 bit */
            {
                dividend = REG_D[(word2 >> 12) & 7];
                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)((sint32)dividend) / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)((sint32)dividend) % (sint64)((sint32)divisor));
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    remainder = dividend % divisor;
                }
            }

            REG_D[word2 & 7] = remainder;
            REG_D[(word2 >> 12) & 7] = quotient;

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint divisor = OPER_AY_AI_32();
        uint dividend_hi = REG_D[word2 & 7];
        uint dividend_lo = REG_D[(word2 >> 12) & 7];
        uint quotient = 0;
        uint remainder = 0;
        uint dividend_neg = 0;
        uint divisor_neg = 0;
        sint i;
        uint overflow;

        if (divisor != 0) {
            /* quad / long : long quotient, long remainder */
            if (BIT_A(word2)) {
                if (BIT_B(word2)) /* signed */
                {
                    /* special case in signed divide */
                    if (dividend_hi == 0 && dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                        REG_D[word2 & 7] = 0;
                        REG_D[(word2 >> 12) & 7] = 0x80000000;

                        FLAG_N = NFLAG_SET;
                        FLAG_Z = ZFLAG_CLEAR;
                        FLAG_V = VFLAG_CLEAR;
                        FLAG_C = CFLAG_CLEAR;
                        return;
                    }
                    if (GET_MSB_32(dividend_hi)) {
                        dividend_neg = 1;
                        dividend_hi = (uint)MASK_OUT_ABOVE_32((-(sint)dividend_hi) - (dividend_lo != 0));
                        dividend_lo = (uint)MASK_OUT_ABOVE_32(-(sint)dividend_lo);
                    }
                    if (GET_MSB_32(divisor)) {
                        divisor_neg = 1;
                        divisor = (uint)MASK_OUT_ABOVE_32(-(sint)divisor);
                    }
                }

                /* if the upper long is greater than the divisor, we're overflowing. */
                if (dividend_hi >= divisor) {
                    FLAG_V = VFLAG_SET;
                    return;
                }

                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    remainder = (remainder << 1) + ((dividend_hi >> i) & 1);
                    if (remainder >= divisor) {
                        remainder -= divisor;
                        quotient++;
                    }
                }
                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    overflow = GET_MSB_32(remainder);
                    remainder = (remainder << 1) + ((dividend_lo >> i) & 1);
                    if (remainder >= divisor || overflow) {
                        remainder -= divisor;
                        quotient++;
                    }
                }

                if (BIT_B(word2)) /* signed */
                {
                    if (quotient > 0x7fffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    if (dividend_neg) {
                        remainder = (uint)MASK_OUT_ABOVE_32(-(sint)remainder);
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                    if (divisor_neg) {
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                }

                REG_D[word2 & 7] = remainder;
                REG_D[(word2 >> 12) & 7] = quotient;

                FLAG_N = NFLAG_32(quotient);
                FLAG_Z = quotient;
                FLAG_V = VFLAG_CLEAR;
                FLAG_C = CFLAG_CLEAR;
                return;
            }

            /* long / long: long quotient, maybe long remainder */
            if (BIT_B(word2)) /* signed */
            {
                /* Special case in divide */
                if (dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                    FLAG_N = NFLAG_SET;
                    FLAG_Z = ZFLAG_CLEAR;
                    FLAG_V = VFLAG_CLEAR;
                    FLAG_C = CFLAG_CLEAR;
                    REG_D[(word2 >> 12) & 7] = 0x80000000;
                    REG_D[word2 & 7] = 0;
                    return;
                }
                REG_D[word2 & 7] = MAKE_INT_32(dividend_lo) % MAKE_INT_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MAKE_INT_32(dividend_lo) / MAKE_INT_32(divisor);
            } else {
                REG_D[word2 & 7] = MASK_OUT_ABOVE_32(dividend_lo) % MASK_OUT_ABOVE_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(dividend_lo) / MASK_OUT_ABOVE_32(divisor);
            }

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_divl_32_pi(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 divisor = OPER_AY_PI_32();
        uint64 dividend = 0;
        uint64 quotient = 0;
        uint64 remainder = 0;

        if (divisor != 0) {
            if (BIT_A(word2)) /* 64 bit */
            {
                dividend = REG_D[word2 & 7];
                dividend <<= 32;
                dividend |= REG_D[(word2 >> 12) & 7];

                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)dividend / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)dividend % (sint64)((sint32)divisor));
                    if ((sint64)quotient != (sint64)((sint32)quotient)) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    if (quotient > 0xffffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    remainder = dividend % divisor;
                }
            } else /* 32 bit */
            {
                dividend = REG_D[(word2 >> 12) & 7];
                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)((sint32)dividend) / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)((sint32)dividend) % (sint64)((sint32)divisor));
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    remainder = dividend % divisor;
                }
            }

            REG_D[word2 & 7] = remainder;
            REG_D[(word2 >> 12) & 7] = quotient;

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint divisor = OPER_AY_PI_32();
        uint dividend_hi = REG_D[word2 & 7];
        uint dividend_lo = REG_D[(word2 >> 12) & 7];
        uint quotient = 0;
        uint remainder = 0;
        uint dividend_neg = 0;
        uint divisor_neg = 0;
        sint i;
        uint overflow;

        if (divisor != 0) {
            /* quad / long : long quotient, long remainder */
            if (BIT_A(word2)) {
                if (BIT_B(word2)) /* signed */
                {
                    /* special case in signed divide */
                    if (dividend_hi == 0 && dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                        REG_D[word2 & 7] = 0;
                        REG_D[(word2 >> 12) & 7] = 0x80000000;

                        FLAG_N = NFLAG_SET;
                        FLAG_Z = ZFLAG_CLEAR;
                        FLAG_V = VFLAG_CLEAR;
                        FLAG_C = CFLAG_CLEAR;
                        return;
                    }
                    if (GET_MSB_32(dividend_hi)) {
                        dividend_neg = 1;
                        dividend_hi = (uint)MASK_OUT_ABOVE_32((-(sint)dividend_hi) - (dividend_lo != 0));
                        dividend_lo = (uint)MASK_OUT_ABOVE_32(-(sint)dividend_lo);
                    }
                    if (GET_MSB_32(divisor)) {
                        divisor_neg = 1;
                        divisor = (uint)MASK_OUT_ABOVE_32(-(sint)divisor);
                    }
                }

                /* if the upper long is greater than the divisor, we're overflowing. */
                if (dividend_hi >= divisor) {
                    FLAG_V = VFLAG_SET;
                    return;
                }

                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    remainder = (remainder << 1) + ((dividend_hi >> i) & 1);
                    if (remainder >= divisor) {
                        remainder -= divisor;
                        quotient++;
                    }
                }
                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    overflow = GET_MSB_32(remainder);
                    remainder = (remainder << 1) + ((dividend_lo >> i) & 1);
                    if (remainder >= divisor || overflow) {
                        remainder -= divisor;
                        quotient++;
                    }
                }

                if (BIT_B(word2)) /* signed */
                {
                    if (quotient > 0x7fffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    if (dividend_neg) {
                        remainder = (uint)MASK_OUT_ABOVE_32(-(sint)remainder);
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                    if (divisor_neg) {
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                }

                REG_D[word2 & 7] = remainder;
                REG_D[(word2 >> 12) & 7] = quotient;

                FLAG_N = NFLAG_32(quotient);
                FLAG_Z = quotient;
                FLAG_V = VFLAG_CLEAR;
                FLAG_C = CFLAG_CLEAR;
                return;
            }

            /* long / long: long quotient, maybe long remainder */
            if (BIT_B(word2)) /* signed */
            {
                /* Special case in divide */
                if (dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                    FLAG_N = NFLAG_SET;
                    FLAG_Z = ZFLAG_CLEAR;
                    FLAG_V = VFLAG_CLEAR;
                    FLAG_C = CFLAG_CLEAR;
                    REG_D[(word2 >> 12) & 7] = 0x80000000;
                    REG_D[word2 & 7] = 0;
                    return;
                }
                REG_D[word2 & 7] = MAKE_INT_32(dividend_lo) % MAKE_INT_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MAKE_INT_32(dividend_lo) / MAKE_INT_32(divisor);
            } else {
                REG_D[word2 & 7] = MASK_OUT_ABOVE_32(dividend_lo) % MASK_OUT_ABOVE_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(dividend_lo) / MASK_OUT_ABOVE_32(divisor);
            }

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_divl_32_pd(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 divisor = OPER_AY_PD_32();
        uint64 dividend = 0;
        uint64 quotient = 0;
        uint64 remainder = 0;

        if (divisor != 0) {
            if (BIT_A(word2)) /* 64 bit */
            {
                dividend = REG_D[word2 & 7];
                dividend <<= 32;
                dividend |= REG_D[(word2 >> 12) & 7];

                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)dividend / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)dividend % (sint64)((sint32)divisor));
                    if ((sint64)quotient != (sint64)((sint32)quotient)) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    if (quotient > 0xffffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    remainder = dividend % divisor;
                }
            } else /* 32 bit */
            {
                dividend = REG_D[(word2 >> 12) & 7];
                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)((sint32)dividend) / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)((sint32)dividend) % (sint64)((sint32)divisor));
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    remainder = dividend % divisor;
                }
            }

            REG_D[word2 & 7] = remainder;
            REG_D[(word2 >> 12) & 7] = quotient;

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint divisor = OPER_AY_PD_32();
        uint dividend_hi = REG_D[word2 & 7];
        uint dividend_lo = REG_D[(word2 >> 12) & 7];
        uint quotient = 0;
        uint remainder = 0;
        uint dividend_neg = 0;
        uint divisor_neg = 0;
        sint i;
        uint overflow;

        if (divisor != 0) {
            /* quad / long : long quotient, long remainder */
            if (BIT_A(word2)) {
                if (BIT_B(word2)) /* signed */
                {
                    /* special case in signed divide */
                    if (dividend_hi == 0 && dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                        REG_D[word2 & 7] = 0;
                        REG_D[(word2 >> 12) & 7] = 0x80000000;

                        FLAG_N = NFLAG_SET;
                        FLAG_Z = ZFLAG_CLEAR;
                        FLAG_V = VFLAG_CLEAR;
                        FLAG_C = CFLAG_CLEAR;
                        return;
                    }
                    if (GET_MSB_32(dividend_hi)) {
                        dividend_neg = 1;
                        dividend_hi = (uint)MASK_OUT_ABOVE_32((-(sint)dividend_hi) - (dividend_lo != 0));
                        dividend_lo = (uint)MASK_OUT_ABOVE_32(-(sint)dividend_lo);
                    }
                    if (GET_MSB_32(divisor)) {
                        divisor_neg = 1;
                        divisor = (uint)MASK_OUT_ABOVE_32(-(sint)divisor);
                    }
                }

                /* if the upper long is greater than the divisor, we're overflowing. */
                if (dividend_hi >= divisor) {
                    FLAG_V = VFLAG_SET;
                    return;
                }

                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    remainder = (remainder << 1) + ((dividend_hi >> i) & 1);
                    if (remainder >= divisor) {
                        remainder -= divisor;
                        quotient++;
                    }
                }
                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    overflow = GET_MSB_32(remainder);
                    remainder = (remainder << 1) + ((dividend_lo >> i) & 1);
                    if (remainder >= divisor || overflow) {
                        remainder -= divisor;
                        quotient++;
                    }
                }

                if (BIT_B(word2)) /* signed */
                {
                    if (quotient > 0x7fffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    if (dividend_neg) {
                        remainder = (uint)MASK_OUT_ABOVE_32(-(sint)remainder);
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                    if (divisor_neg) {
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                }

                REG_D[word2 & 7] = remainder;
                REG_D[(word2 >> 12) & 7] = quotient;

                FLAG_N = NFLAG_32(quotient);
                FLAG_Z = quotient;
                FLAG_V = VFLAG_CLEAR;
                FLAG_C = CFLAG_CLEAR;
                return;
            }

            /* long / long: long quotient, maybe long remainder */
            if (BIT_B(word2)) /* signed */
            {
                /* Special case in divide */
                if (dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                    FLAG_N = NFLAG_SET;
                    FLAG_Z = ZFLAG_CLEAR;
                    FLAG_V = VFLAG_CLEAR;
                    FLAG_C = CFLAG_CLEAR;
                    REG_D[(word2 >> 12) & 7] = 0x80000000;
                    REG_D[word2 & 7] = 0;
                    return;
                }
                REG_D[word2 & 7] = MAKE_INT_32(dividend_lo) % MAKE_INT_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MAKE_INT_32(dividend_lo) / MAKE_INT_32(divisor);
            } else {
                REG_D[word2 & 7] = MASK_OUT_ABOVE_32(dividend_lo) % MASK_OUT_ABOVE_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(dividend_lo) / MASK_OUT_ABOVE_32(divisor);
            }

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_divl_32_di(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 divisor = OPER_AY_DI_32();
        uint64 dividend = 0;
        uint64 quotient = 0;
        uint64 remainder = 0;

        if (divisor != 0) {
            if (BIT_A(word2)) /* 64 bit */
            {
                dividend = REG_D[word2 & 7];
                dividend <<= 32;
                dividend |= REG_D[(word2 >> 12) & 7];

                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)dividend / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)dividend % (sint64)((sint32)divisor));
                    if ((sint64)quotient != (sint64)((sint32)quotient)) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    if (quotient > 0xffffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    remainder = dividend % divisor;
                }
            } else /* 32 bit */
            {
                dividend = REG_D[(word2 >> 12) & 7];
                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)((sint32)dividend) / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)((sint32)dividend) % (sint64)((sint32)divisor));
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    remainder = dividend % divisor;
                }
            }

            REG_D[word2 & 7] = remainder;
            REG_D[(word2 >> 12) & 7] = quotient;

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint divisor = OPER_AY_DI_32();
        uint dividend_hi = REG_D[word2 & 7];
        uint dividend_lo = REG_D[(word2 >> 12) & 7];
        uint quotient = 0;
        uint remainder = 0;
        uint dividend_neg = 0;
        uint divisor_neg = 0;
        sint i;
        uint overflow;

        if (divisor != 0) {
            /* quad / long : long quotient, long remainder */
            if (BIT_A(word2)) {
                if (BIT_B(word2)) /* signed */
                {
                    /* special case in signed divide */
                    if (dividend_hi == 0 && dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                        REG_D[word2 & 7] = 0;
                        REG_D[(word2 >> 12) & 7] = 0x80000000;

                        FLAG_N = NFLAG_SET;
                        FLAG_Z = ZFLAG_CLEAR;
                        FLAG_V = VFLAG_CLEAR;
                        FLAG_C = CFLAG_CLEAR;
                        return;
                    }
                    if (GET_MSB_32(dividend_hi)) {
                        dividend_neg = 1;
                        dividend_hi = (uint)MASK_OUT_ABOVE_32((-(sint)dividend_hi) - (dividend_lo != 0));
                        dividend_lo = (uint)MASK_OUT_ABOVE_32(-(sint)dividend_lo);
                    }
                    if (GET_MSB_32(divisor)) {
                        divisor_neg = 1;
                        divisor = (uint)MASK_OUT_ABOVE_32(-(sint)divisor);
                    }
                }

                /* if the upper long is greater than the divisor, we're overflowing. */
                if (dividend_hi >= divisor) {
                    FLAG_V = VFLAG_SET;
                    return;
                }

                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    remainder = (remainder << 1) + ((dividend_hi >> i) & 1);
                    if (remainder >= divisor) {
                        remainder -= divisor;
                        quotient++;
                    }
                }
                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    overflow = GET_MSB_32(remainder);
                    remainder = (remainder << 1) + ((dividend_lo >> i) & 1);
                    if (remainder >= divisor || overflow) {
                        remainder -= divisor;
                        quotient++;
                    }
                }

                if (BIT_B(word2)) /* signed */
                {
                    if (quotient > 0x7fffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    if (dividend_neg) {
                        remainder = (uint)MASK_OUT_ABOVE_32(-(sint)remainder);
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                    if (divisor_neg) {
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                }

                REG_D[word2 & 7] = remainder;
                REG_D[(word2 >> 12) & 7] = quotient;

                FLAG_N = NFLAG_32(quotient);
                FLAG_Z = quotient;
                FLAG_V = VFLAG_CLEAR;
                FLAG_C = CFLAG_CLEAR;
                return;
            }

            /* long / long: long quotient, maybe long remainder */
            if (BIT_B(word2)) /* signed */
            {
                /* Special case in divide */
                if (dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                    FLAG_N = NFLAG_SET;
                    FLAG_Z = ZFLAG_CLEAR;
                    FLAG_V = VFLAG_CLEAR;
                    FLAG_C = CFLAG_CLEAR;
                    REG_D[(word2 >> 12) & 7] = 0x80000000;
                    REG_D[word2 & 7] = 0;
                    return;
                }
                REG_D[word2 & 7] = MAKE_INT_32(dividend_lo) % MAKE_INT_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MAKE_INT_32(dividend_lo) / MAKE_INT_32(divisor);
            } else {
                REG_D[word2 & 7] = MASK_OUT_ABOVE_32(dividend_lo) % MASK_OUT_ABOVE_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(dividend_lo) / MASK_OUT_ABOVE_32(divisor);
            }

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_divl_32_ix(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 divisor = OPER_AY_IX_32();
        uint64 dividend = 0;
        uint64 quotient = 0;
        uint64 remainder = 0;

        if (divisor != 0) {
            if (BIT_A(word2)) /* 64 bit */
            {
                dividend = REG_D[word2 & 7];
                dividend <<= 32;
                dividend |= REG_D[(word2 >> 12) & 7];

                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)dividend / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)dividend % (sint64)((sint32)divisor));
                    if ((sint64)quotient != (sint64)((sint32)quotient)) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    if (quotient > 0xffffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    remainder = dividend % divisor;
                }
            } else /* 32 bit */
            {
                dividend = REG_D[(word2 >> 12) & 7];
                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)((sint32)dividend) / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)((sint32)dividend) % (sint64)((sint32)divisor));
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    remainder = dividend % divisor;
                }
            }

            REG_D[word2 & 7] = remainder;
            REG_D[(word2 >> 12) & 7] = quotient;

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint divisor = OPER_AY_IX_32();
        uint dividend_hi = REG_D[word2 & 7];
        uint dividend_lo = REG_D[(word2 >> 12) & 7];
        uint quotient = 0;
        uint remainder = 0;
        uint dividend_neg = 0;
        uint divisor_neg = 0;
        sint i;
        uint overflow;

        if (divisor != 0) {
            /* quad / long : long quotient, long remainder */
            if (BIT_A(word2)) {
                if (BIT_B(word2)) /* signed */
                {
                    /* special case in signed divide */
                    if (dividend_hi == 0 && dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                        REG_D[word2 & 7] = 0;
                        REG_D[(word2 >> 12) & 7] = 0x80000000;

                        FLAG_N = NFLAG_SET;
                        FLAG_Z = ZFLAG_CLEAR;
                        FLAG_V = VFLAG_CLEAR;
                        FLAG_C = CFLAG_CLEAR;
                        return;
                    }
                    if (GET_MSB_32(dividend_hi)) {
                        dividend_neg = 1;
                        dividend_hi = (uint)MASK_OUT_ABOVE_32((-(sint)dividend_hi) - (dividend_lo != 0));
                        dividend_lo = (uint)MASK_OUT_ABOVE_32(-(sint)dividend_lo);
                    }
                    if (GET_MSB_32(divisor)) {
                        divisor_neg = 1;
                        divisor = (uint)MASK_OUT_ABOVE_32(-(sint)divisor);
                    }
                }

                /* if the upper long is greater than the divisor, we're overflowing. */
                if (dividend_hi >= divisor) {
                    FLAG_V = VFLAG_SET;
                    return;
                }

                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    remainder = (remainder << 1) + ((dividend_hi >> i) & 1);
                    if (remainder >= divisor) {
                        remainder -= divisor;
                        quotient++;
                    }
                }
                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    overflow = GET_MSB_32(remainder);
                    remainder = (remainder << 1) + ((dividend_lo >> i) & 1);
                    if (remainder >= divisor || overflow) {
                        remainder -= divisor;
                        quotient++;
                    }
                }

                if (BIT_B(word2)) /* signed */
                {
                    if (quotient > 0x7fffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    if (dividend_neg) {
                        remainder = (uint)MASK_OUT_ABOVE_32(-(sint)remainder);
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                    if (divisor_neg) {
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                }

                REG_D[word2 & 7] = remainder;
                REG_D[(word2 >> 12) & 7] = quotient;

                FLAG_N = NFLAG_32(quotient);
                FLAG_Z = quotient;
                FLAG_V = VFLAG_CLEAR;
                FLAG_C = CFLAG_CLEAR;
                return;
            }

            /* long / long: long quotient, maybe long remainder */
            if (BIT_B(word2)) /* signed */
            {
                /* Special case in divide */
                if (dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                    FLAG_N = NFLAG_SET;
                    FLAG_Z = ZFLAG_CLEAR;
                    FLAG_V = VFLAG_CLEAR;
                    FLAG_C = CFLAG_CLEAR;
                    REG_D[(word2 >> 12) & 7] = 0x80000000;
                    REG_D[word2 & 7] = 0;
                    return;
                }
                REG_D[word2 & 7] = MAKE_INT_32(dividend_lo) % MAKE_INT_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MAKE_INT_32(dividend_lo) / MAKE_INT_32(divisor);
            } else {
                REG_D[word2 & 7] = MASK_OUT_ABOVE_32(dividend_lo) % MASK_OUT_ABOVE_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(dividend_lo) / MASK_OUT_ABOVE_32(divisor);
            }

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_divl_32_aw(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 divisor = OPER_AW_32();
        uint64 dividend = 0;
        uint64 quotient = 0;
        uint64 remainder = 0;

        if (divisor != 0) {
            if (BIT_A(word2)) /* 64 bit */
            {
                dividend = REG_D[word2 & 7];
                dividend <<= 32;
                dividend |= REG_D[(word2 >> 12) & 7];

                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)dividend / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)dividend % (sint64)((sint32)divisor));
                    if ((sint64)quotient != (sint64)((sint32)quotient)) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    if (quotient > 0xffffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    remainder = dividend % divisor;
                }
            } else /* 32 bit */
            {
                dividend = REG_D[(word2 >> 12) & 7];
                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)((sint32)dividend) / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)((sint32)dividend) % (sint64)((sint32)divisor));
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    remainder = dividend % divisor;
                }
            }

            REG_D[word2 & 7] = remainder;
            REG_D[(word2 >> 12) & 7] = quotient;

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint divisor = OPER_AW_32();
        uint dividend_hi = REG_D[word2 & 7];
        uint dividend_lo = REG_D[(word2 >> 12) & 7];
        uint quotient = 0;
        uint remainder = 0;
        uint dividend_neg = 0;
        uint divisor_neg = 0;
        sint i;
        uint overflow;

        if (divisor != 0) {
            /* quad / long : long quotient, long remainder */
            if (BIT_A(word2)) {
                if (BIT_B(word2)) /* signed */
                {
                    /* special case in signed divide */
                    if (dividend_hi == 0 && dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                        REG_D[word2 & 7] = 0;
                        REG_D[(word2 >> 12) & 7] = 0x80000000;

                        FLAG_N = NFLAG_SET;
                        FLAG_Z = ZFLAG_CLEAR;
                        FLAG_V = VFLAG_CLEAR;
                        FLAG_C = CFLAG_CLEAR;
                        return;
                    }
                    if (GET_MSB_32(dividend_hi)) {
                        dividend_neg = 1;
                        dividend_hi = (uint)MASK_OUT_ABOVE_32((-(sint)dividend_hi) - (dividend_lo != 0));
                        dividend_lo = (uint)MASK_OUT_ABOVE_32(-(sint)dividend_lo);
                    }
                    if (GET_MSB_32(divisor)) {
                        divisor_neg = 1;
                        divisor = (uint)MASK_OUT_ABOVE_32(-(sint)divisor);
                    }
                }

                /* if the upper long is greater than the divisor, we're overflowing. */
                if (dividend_hi >= divisor) {
                    FLAG_V = VFLAG_SET;
                    return;
                }

                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    remainder = (remainder << 1) + ((dividend_hi >> i) & 1);
                    if (remainder >= divisor) {
                        remainder -= divisor;
                        quotient++;
                    }
                }
                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    overflow = GET_MSB_32(remainder);
                    remainder = (remainder << 1) + ((dividend_lo >> i) & 1);
                    if (remainder >= divisor || overflow) {
                        remainder -= divisor;
                        quotient++;
                    }
                }

                if (BIT_B(word2)) /* signed */
                {
                    if (quotient > 0x7fffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    if (dividend_neg) {
                        remainder = (uint)MASK_OUT_ABOVE_32(-(sint)remainder);
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                    if (divisor_neg) {
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                }

                REG_D[word2 & 7] = remainder;
                REG_D[(word2 >> 12) & 7] = quotient;

                FLAG_N = NFLAG_32(quotient);
                FLAG_Z = quotient;
                FLAG_V = VFLAG_CLEAR;
                FLAG_C = CFLAG_CLEAR;
                return;
            }

            /* long / long: long quotient, maybe long remainder */
            if (BIT_B(word2)) /* signed */
            {
                /* Special case in divide */
                if (dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                    FLAG_N = NFLAG_SET;
                    FLAG_Z = ZFLAG_CLEAR;
                    FLAG_V = VFLAG_CLEAR;
                    FLAG_C = CFLAG_CLEAR;
                    REG_D[(word2 >> 12) & 7] = 0x80000000;
                    REG_D[word2 & 7] = 0;
                    return;
                }
                REG_D[word2 & 7] = MAKE_INT_32(dividend_lo) % MAKE_INT_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MAKE_INT_32(dividend_lo) / MAKE_INT_32(divisor);
            } else {
                REG_D[word2 & 7] = MASK_OUT_ABOVE_32(dividend_lo) % MASK_OUT_ABOVE_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(dividend_lo) / MASK_OUT_ABOVE_32(divisor);
            }

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_divl_32_al(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 divisor = OPER_AL_32();
        uint64 dividend = 0;
        uint64 quotient = 0;
        uint64 remainder = 0;

        if (divisor != 0) {
            if (BIT_A(word2)) /* 64 bit */
            {
                dividend = REG_D[word2 & 7];
                dividend <<= 32;
                dividend |= REG_D[(word2 >> 12) & 7];

                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)dividend / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)dividend % (sint64)((sint32)divisor));
                    if ((sint64)quotient != (sint64)((sint32)quotient)) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    if (quotient > 0xffffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    remainder = dividend % divisor;
                }
            } else /* 32 bit */
            {
                dividend = REG_D[(word2 >> 12) & 7];
                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)((sint32)dividend) / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)((sint32)dividend) % (sint64)((sint32)divisor));
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    remainder = dividend % divisor;
                }
            }

            REG_D[word2 & 7] = remainder;
            REG_D[(word2 >> 12) & 7] = quotient;

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint divisor = OPER_AL_32();
        uint dividend_hi = REG_D[word2 & 7];
        uint dividend_lo = REG_D[(word2 >> 12) & 7];
        uint quotient = 0;
        uint remainder = 0;
        uint dividend_neg = 0;
        uint divisor_neg = 0;
        sint i;
        uint overflow;

        if (divisor != 0) {
            /* quad / long : long quotient, long remainder */
            if (BIT_A(word2)) {
                if (BIT_B(word2)) /* signed */
                {
                    /* special case in signed divide */
                    if (dividend_hi == 0 && dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                        REG_D[word2 & 7] = 0;
                        REG_D[(word2 >> 12) & 7] = 0x80000000;

                        FLAG_N = NFLAG_SET;
                        FLAG_Z = ZFLAG_CLEAR;
                        FLAG_V = VFLAG_CLEAR;
                        FLAG_C = CFLAG_CLEAR;
                        return;
                    }
                    if (GET_MSB_32(dividend_hi)) {
                        dividend_neg = 1;
                        dividend_hi = (uint)MASK_OUT_ABOVE_32((-(sint)dividend_hi) - (dividend_lo != 0));
                        dividend_lo = (uint)MASK_OUT_ABOVE_32(-(sint)dividend_lo);
                    }
                    if (GET_MSB_32(divisor)) {
                        divisor_neg = 1;
                        divisor = (uint)MASK_OUT_ABOVE_32(-(sint)divisor);
                    }
                }

                /* if the upper long is greater than the divisor, we're overflowing. */
                if (dividend_hi >= divisor) {
                    FLAG_V = VFLAG_SET;
                    return;
                }

                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    remainder = (remainder << 1) + ((dividend_hi >> i) & 1);
                    if (remainder >= divisor) {
                        remainder -= divisor;
                        quotient++;
                    }
                }
                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    overflow = GET_MSB_32(remainder);
                    remainder = (remainder << 1) + ((dividend_lo >> i) & 1);
                    if (remainder >= divisor || overflow) {
                        remainder -= divisor;
                        quotient++;
                    }
                }

                if (BIT_B(word2)) /* signed */
                {
                    if (quotient > 0x7fffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    if (dividend_neg) {
                        remainder = (uint)MASK_OUT_ABOVE_32(-(sint)remainder);
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                    if (divisor_neg) {
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                }

                REG_D[word2 & 7] = remainder;
                REG_D[(word2 >> 12) & 7] = quotient;

                FLAG_N = NFLAG_32(quotient);
                FLAG_Z = quotient;
                FLAG_V = VFLAG_CLEAR;
                FLAG_C = CFLAG_CLEAR;
                return;
            }

            /* long / long: long quotient, maybe long remainder */
            if (BIT_B(word2)) /* signed */
            {
                /* Special case in divide */
                if (dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                    FLAG_N = NFLAG_SET;
                    FLAG_Z = ZFLAG_CLEAR;
                    FLAG_V = VFLAG_CLEAR;
                    FLAG_C = CFLAG_CLEAR;
                    REG_D[(word2 >> 12) & 7] = 0x80000000;
                    REG_D[word2 & 7] = 0;
                    return;
                }
                REG_D[word2 & 7] = MAKE_INT_32(dividend_lo) % MAKE_INT_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MAKE_INT_32(dividend_lo) / MAKE_INT_32(divisor);
            } else {
                REG_D[word2 & 7] = MASK_OUT_ABOVE_32(dividend_lo) % MASK_OUT_ABOVE_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(dividend_lo) / MASK_OUT_ABOVE_32(divisor);
            }

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_divl_32_pcdi(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 divisor = OPER_PCDI_32();
        uint64 dividend = 0;
        uint64 quotient = 0;
        uint64 remainder = 0;

        if (divisor != 0) {
            if (BIT_A(word2)) /* 64 bit */
            {
                dividend = REG_D[word2 & 7];
                dividend <<= 32;
                dividend |= REG_D[(word2 >> 12) & 7];

                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)dividend / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)dividend % (sint64)((sint32)divisor));
                    if ((sint64)quotient != (sint64)((sint32)quotient)) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    if (quotient > 0xffffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    remainder = dividend % divisor;
                }
            } else /* 32 bit */
            {
                dividend = REG_D[(word2 >> 12) & 7];
                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)((sint32)dividend) / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)((sint32)dividend) % (sint64)((sint32)divisor));
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    remainder = dividend % divisor;
                }
            }

            REG_D[word2 & 7] = remainder;
            REG_D[(word2 >> 12) & 7] = quotient;

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint divisor = OPER_PCDI_32();
        uint dividend_hi = REG_D[word2 & 7];
        uint dividend_lo = REG_D[(word2 >> 12) & 7];
        uint quotient = 0;
        uint remainder = 0;
        uint dividend_neg = 0;
        uint divisor_neg = 0;
        sint i;
        uint overflow;

        if (divisor != 0) {
            /* quad / long : long quotient, long remainder */
            if (BIT_A(word2)) {
                if (BIT_B(word2)) /* signed */
                {
                    /* special case in signed divide */
                    if (dividend_hi == 0 && dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                        REG_D[word2 & 7] = 0;
                        REG_D[(word2 >> 12) & 7] = 0x80000000;

                        FLAG_N = NFLAG_SET;
                        FLAG_Z = ZFLAG_CLEAR;
                        FLAG_V = VFLAG_CLEAR;
                        FLAG_C = CFLAG_CLEAR;
                        return;
                    }
                    if (GET_MSB_32(dividend_hi)) {
                        dividend_neg = 1;
                        dividend_hi = (uint)MASK_OUT_ABOVE_32((-(sint)dividend_hi) - (dividend_lo != 0));
                        dividend_lo = (uint)MASK_OUT_ABOVE_32(-(sint)dividend_lo);
                    }
                    if (GET_MSB_32(divisor)) {
                        divisor_neg = 1;
                        divisor = (uint)MASK_OUT_ABOVE_32(-(sint)divisor);
                    }
                }

                /* if the upper long is greater than the divisor, we're overflowing. */
                if (dividend_hi >= divisor) {
                    FLAG_V = VFLAG_SET;
                    return;
                }

                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    remainder = (remainder << 1) + ((dividend_hi >> i) & 1);
                    if (remainder >= divisor) {
                        remainder -= divisor;
                        quotient++;
                    }
                }
                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    overflow = GET_MSB_32(remainder);
                    remainder = (remainder << 1) + ((dividend_lo >> i) & 1);
                    if (remainder >= divisor || overflow) {
                        remainder -= divisor;
                        quotient++;
                    }
                }

                if (BIT_B(word2)) /* signed */
                {
                    if (quotient > 0x7fffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    if (dividend_neg) {
                        remainder = (uint)MASK_OUT_ABOVE_32(-(sint)remainder);
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                    if (divisor_neg) {
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                }

                REG_D[word2 & 7] = remainder;
                REG_D[(word2 >> 12) & 7] = quotient;

                FLAG_N = NFLAG_32(quotient);
                FLAG_Z = quotient;
                FLAG_V = VFLAG_CLEAR;
                FLAG_C = CFLAG_CLEAR;
                return;
            }

            /* long / long: long quotient, maybe long remainder */
            if (BIT_B(word2)) /* signed */
            {
                /* Special case in divide */
                if (dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                    FLAG_N = NFLAG_SET;
                    FLAG_Z = ZFLAG_CLEAR;
                    FLAG_V = VFLAG_CLEAR;
                    FLAG_C = CFLAG_CLEAR;
                    REG_D[(word2 >> 12) & 7] = 0x80000000;
                    REG_D[word2 & 7] = 0;
                    return;
                }
                REG_D[word2 & 7] = MAKE_INT_32(dividend_lo) % MAKE_INT_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MAKE_INT_32(dividend_lo) / MAKE_INT_32(divisor);
            } else {
                REG_D[word2 & 7] = MASK_OUT_ABOVE_32(dividend_lo) % MASK_OUT_ABOVE_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(dividend_lo) / MASK_OUT_ABOVE_32(divisor);
            }

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_divl_32_pcix(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 divisor = OPER_PCIX_32();
        uint64 dividend = 0;
        uint64 quotient = 0;
        uint64 remainder = 0;

        if (divisor != 0) {
            if (BIT_A(word2)) /* 64 bit */
            {
                dividend = REG_D[word2 & 7];
                dividend <<= 32;
                dividend |= REG_D[(word2 >> 12) & 7];

                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)dividend / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)dividend % (sint64)((sint32)divisor));
                    if ((sint64)quotient != (sint64)((sint32)quotient)) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    if (quotient > 0xffffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    remainder = dividend % divisor;
                }
            } else /* 32 bit */
            {
                dividend = REG_D[(word2 >> 12) & 7];
                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)((sint32)dividend) / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)((sint32)dividend) % (sint64)((sint32)divisor));
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    remainder = dividend % divisor;
                }
            }

            REG_D[word2 & 7] = remainder;
            REG_D[(word2 >> 12) & 7] = quotient;

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint divisor = OPER_PCIX_32();
        uint dividend_hi = REG_D[word2 & 7];
        uint dividend_lo = REG_D[(word2 >> 12) & 7];
        uint quotient = 0;
        uint remainder = 0;
        uint dividend_neg = 0;
        uint divisor_neg = 0;
        sint i;
        uint overflow;

        if (divisor != 0) {
            /* quad / long : long quotient, long remainder */
            if (BIT_A(word2)) {
                if (BIT_B(word2)) /* signed */
                {
                    /* special case in signed divide */
                    if (dividend_hi == 0 && dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                        REG_D[word2 & 7] = 0;
                        REG_D[(word2 >> 12) & 7] = 0x80000000;

                        FLAG_N = NFLAG_SET;
                        FLAG_Z = ZFLAG_CLEAR;
                        FLAG_V = VFLAG_CLEAR;
                        FLAG_C = CFLAG_CLEAR;
                        return;
                    }
                    if (GET_MSB_32(dividend_hi)) {
                        dividend_neg = 1;
                        dividend_hi = (uint)MASK_OUT_ABOVE_32((-(sint)dividend_hi) - (dividend_lo != 0));
                        dividend_lo = (uint)MASK_OUT_ABOVE_32(-(sint)dividend_lo);
                    }
                    if (GET_MSB_32(divisor)) {
                        divisor_neg = 1;
                        divisor = (uint)MASK_OUT_ABOVE_32(-(sint)divisor);
                    }
                }

                /* if the upper long is greater than the divisor, we're overflowing. */
                if (dividend_hi >= divisor) {
                    FLAG_V = VFLAG_SET;
                    return;
                }

                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    remainder = (remainder << 1) + ((dividend_hi >> i) & 1);
                    if (remainder >= divisor) {
                        remainder -= divisor;
                        quotient++;
                    }
                }
                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    overflow = GET_MSB_32(remainder);
                    remainder = (remainder << 1) + ((dividend_lo >> i) & 1);
                    if (remainder >= divisor || overflow) {
                        remainder -= divisor;
                        quotient++;
                    }
                }

                if (BIT_B(word2)) /* signed */
                {
                    if (quotient > 0x7fffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    if (dividend_neg) {
                        remainder = (uint)MASK_OUT_ABOVE_32(-(sint)remainder);
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                    if (divisor_neg) {
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                }

                REG_D[word2 & 7] = remainder;
                REG_D[(word2 >> 12) & 7] = quotient;

                FLAG_N = NFLAG_32(quotient);
                FLAG_Z = quotient;
                FLAG_V = VFLAG_CLEAR;
                FLAG_C = CFLAG_CLEAR;
                return;
            }

            /* long / long: long quotient, maybe long remainder */
            if (BIT_B(word2)) /* signed */
            {
                /* Special case in divide */
                if (dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                    FLAG_N = NFLAG_SET;
                    FLAG_Z = ZFLAG_CLEAR;
                    FLAG_V = VFLAG_CLEAR;
                    FLAG_C = CFLAG_CLEAR;
                    REG_D[(word2 >> 12) & 7] = 0x80000000;
                    REG_D[word2 & 7] = 0;
                    return;
                }
                REG_D[word2 & 7] = MAKE_INT_32(dividend_lo) % MAKE_INT_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MAKE_INT_32(dividend_lo) / MAKE_INT_32(divisor);
            } else {
                REG_D[word2 & 7] = MASK_OUT_ABOVE_32(dividend_lo) % MASK_OUT_ABOVE_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(dividend_lo) / MASK_OUT_ABOVE_32(divisor);
            }

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_divl_32_i(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 divisor = OPER_I_32();
        uint64 dividend = 0;
        uint64 quotient = 0;
        uint64 remainder = 0;

        if (divisor != 0) {
            if (BIT_A(word2)) /* 64 bit */
            {
                dividend = REG_D[word2 & 7];
                dividend <<= 32;
                dividend |= REG_D[(word2 >> 12) & 7];

                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)dividend / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)dividend % (sint64)((sint32)divisor));
                    if ((sint64)quotient != (sint64)((sint32)quotient)) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    if (quotient > 0xffffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    remainder = dividend % divisor;
                }
            } else /* 32 bit */
            {
                dividend = REG_D[(word2 >> 12) & 7];
                if (BIT_B(word2)) /* signed */
                {
                    quotient = (uint64)((sint64)((sint32)dividend) / (sint64)((sint32)divisor));
                    remainder = (uint64)((sint64)((sint32)dividend) % (sint64)((sint32)divisor));
                } else /* unsigned */
                {
                    quotient = dividend / divisor;
                    remainder = dividend % divisor;
                }
            }

            REG_D[word2 & 7] = remainder;
            REG_D[(word2 >> 12) & 7] = quotient;

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint divisor = OPER_I_32();
        uint dividend_hi = REG_D[word2 & 7];
        uint dividend_lo = REG_D[(word2 >> 12) & 7];
        uint quotient = 0;
        uint remainder = 0;
        uint dividend_neg = 0;
        uint divisor_neg = 0;
        sint i;
        uint overflow;

        if (divisor != 0) {
            /* quad / long : long quotient, long remainder */
            if (BIT_A(word2)) {
                if (BIT_B(word2)) /* signed */
                {
                    /* special case in signed divide */
                    if (dividend_hi == 0 && dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                        REG_D[word2 & 7] = 0;
                        REG_D[(word2 >> 12) & 7] = 0x80000000;

                        FLAG_N = NFLAG_SET;
                        FLAG_Z = ZFLAG_CLEAR;
                        FLAG_V = VFLAG_CLEAR;
                        FLAG_C = CFLAG_CLEAR;
                        return;
                    }
                    if (GET_MSB_32(dividend_hi)) {
                        dividend_neg = 1;
                        dividend_hi = (uint)MASK_OUT_ABOVE_32((-(sint)dividend_hi) - (dividend_lo != 0));
                        dividend_lo = (uint)MASK_OUT_ABOVE_32(-(sint)dividend_lo);
                    }
                    if (GET_MSB_32(divisor)) {
                        divisor_neg = 1;
                        divisor = (uint)MASK_OUT_ABOVE_32(-(sint)divisor);
                    }
                }

                /* if the upper long is greater than the divisor, we're overflowing. */
                if (dividend_hi >= divisor) {
                    FLAG_V = VFLAG_SET;
                    return;
                }

                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    remainder = (remainder << 1) + ((dividend_hi >> i) & 1);
                    if (remainder >= divisor) {
                        remainder -= divisor;
                        quotient++;
                    }
                }
                for (i = 31; i >= 0; i--) {
                    quotient <<= 1;
                    overflow = GET_MSB_32(remainder);
                    remainder = (remainder << 1) + ((dividend_lo >> i) & 1);
                    if (remainder >= divisor || overflow) {
                        remainder -= divisor;
                        quotient++;
                    }
                }

                if (BIT_B(word2)) /* signed */
                {
                    if (quotient > 0x7fffffff) {
                        FLAG_V = VFLAG_SET;
                        return;
                    }
                    if (dividend_neg) {
                        remainder = (uint)MASK_OUT_ABOVE_32(-(sint)remainder);
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                    if (divisor_neg) {
                        quotient = (uint)MASK_OUT_ABOVE_32(-(sint)quotient);
                    }
                }

                REG_D[word2 & 7] = remainder;
                REG_D[(word2 >> 12) & 7] = quotient;

                FLAG_N = NFLAG_32(quotient);
                FLAG_Z = quotient;
                FLAG_V = VFLAG_CLEAR;
                FLAG_C = CFLAG_CLEAR;
                return;
            }

            /* long / long: long quotient, maybe long remainder */
            if (BIT_B(word2)) /* signed */
            {
                /* Special case in divide */
                if (dividend_lo == 0x80000000 && divisor == 0xffffffff) {
                    FLAG_N = NFLAG_SET;
                    FLAG_Z = ZFLAG_CLEAR;
                    FLAG_V = VFLAG_CLEAR;
                    FLAG_C = CFLAG_CLEAR;
                    REG_D[(word2 >> 12) & 7] = 0x80000000;
                    REG_D[word2 & 7] = 0;
                    return;
                }
                REG_D[word2 & 7] = MAKE_INT_32(dividend_lo) % MAKE_INT_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MAKE_INT_32(dividend_lo) / MAKE_INT_32(divisor);
            } else {
                REG_D[word2 & 7] = MASK_OUT_ABOVE_32(dividend_lo) % MASK_OUT_ABOVE_32(divisor);
                quotient = REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(dividend_lo) / MASK_OUT_ABOVE_32(divisor);
            }

            FLAG_N = NFLAG_32(quotient);
            FLAG_Z = quotient;
            FLAG_V = VFLAG_CLEAR;
            FLAG_C = CFLAG_CLEAR;
            return;
        }
        m68ki_exception_trap(EXCEPTION_ZERO_DIVIDE);
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_eor_8_d(void)
{
    uint res = MASK_OUT_ABOVE_8(DY ^= MASK_OUT_ABOVE_8(DX));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_8_ai(void)
{
    uint ea = EA_AY_AI_8();
    uint res = MASK_OUT_ABOVE_8(DX ^ m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_8_pi(void)
{
    uint ea = EA_AY_PI_8();
    uint res = MASK_OUT_ABOVE_8(DX ^ m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_8_pi7(void)
{
    uint ea = EA_A7_PI_8();
    uint res = MASK_OUT_ABOVE_8(DX ^ m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_8_pd(void)
{
    uint ea = EA_AY_PD_8();
    uint res = MASK_OUT_ABOVE_8(DX ^ m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_8_pd7(void)
{
    uint ea = EA_A7_PD_8();
    uint res = MASK_OUT_ABOVE_8(DX ^ m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_8_di(void)
{
    uint ea = EA_AY_DI_8();
    uint res = MASK_OUT_ABOVE_8(DX ^ m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_8_ix(void)
{
    uint ea = EA_AY_IX_8();
    uint res = MASK_OUT_ABOVE_8(DX ^ m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_8_aw(void)
{
    uint ea = EA_AW_8();
    uint res = MASK_OUT_ABOVE_8(DX ^ m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_8_al(void)
{
    uint ea = EA_AL_8();
    uint res = MASK_OUT_ABOVE_8(DX ^ m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_16_d(void)
{
    uint res = MASK_OUT_ABOVE_16(DY ^= MASK_OUT_ABOVE_16(DX));

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_16_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint res = MASK_OUT_ABOVE_16(DX ^ m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_16_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint res = MASK_OUT_ABOVE_16(DX ^ m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_16_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint res = MASK_OUT_ABOVE_16(DX ^ m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_16_di(void)
{
    uint ea = EA_AY_DI_16();
    uint res = MASK_OUT_ABOVE_16(DX ^ m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_16_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint res = MASK_OUT_ABOVE_16(DX ^ m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_16_aw(void)
{
    uint ea = EA_AW_16();
    uint res = MASK_OUT_ABOVE_16(DX ^ m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_16_al(void)
{
    uint ea = EA_AL_16();
    uint res = MASK_OUT_ABOVE_16(DX ^ m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_32_d(void)
{
    uint res = DY ^= DX;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_32_ai(void)
{
    uint ea = EA_AY_AI_32();
    uint res = DX ^ m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_32_pi(void)
{
    uint ea = EA_AY_PI_32();
    uint res = DX ^ m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_32_pd(void)
{
    uint ea = EA_AY_PD_32();
    uint res = DX ^ m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_32_di(void)
{
    uint ea = EA_AY_DI_32();
    uint res = DX ^ m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_32_ix(void)
{
    uint ea = EA_AY_IX_32();
    uint res = DX ^ m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_32_aw(void)
{
    uint ea = EA_AW_32();
    uint res = DX ^ m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eor_32_al(void)
{
    uint ea = EA_AL_32();
    uint res = DX ^ m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_8_d(void)
{
    uint res = MASK_OUT_ABOVE_8(DY ^= OPER_I_8());

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_8_ai(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_AI_8();
    uint res = src ^ m68ki_read_8(ea);

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_8_pi(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_PI_8();
    uint res = src ^ m68ki_read_8(ea);

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_8_pi7(void)
{
    uint src = OPER_I_8();
    uint ea = EA_A7_PI_8();
    uint res = src ^ m68ki_read_8(ea);

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_8_pd(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_PD_8();
    uint res = src ^ m68ki_read_8(ea);

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_8_pd7(void)
{
    uint src = OPER_I_8();
    uint ea = EA_A7_PD_8();
    uint res = src ^ m68ki_read_8(ea);

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_8_di(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_DI_8();
    uint res = src ^ m68ki_read_8(ea);

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_8_ix(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_IX_8();
    uint res = src ^ m68ki_read_8(ea);

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_8_aw(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AW_8();
    uint res = src ^ m68ki_read_8(ea);

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_8_al(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AL_8();
    uint res = src ^ m68ki_read_8(ea);

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_16_d(void)
{
    uint res = MASK_OUT_ABOVE_16(DY ^= OPER_I_16());

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_16_ai(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_AI_16();
    uint res = src ^ m68ki_read_16(ea);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_16_pi(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_PI_16();
    uint res = src ^ m68ki_read_16(ea);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_16_pd(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_PD_16();
    uint res = src ^ m68ki_read_16(ea);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_16_di(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_DI_16();
    uint res = src ^ m68ki_read_16(ea);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_16_ix(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_IX_16();
    uint res = src ^ m68ki_read_16(ea);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_16_aw(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AW_16();
    uint res = src ^ m68ki_read_16(ea);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_16_al(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AL_16();
    uint res = src ^ m68ki_read_16(ea);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_32_d(void)
{
    uint res = DY ^= OPER_I_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_32_ai(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_AI_32();
    uint res = src ^ m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_32_pi(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_PI_32();
    uint res = src ^ m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_32_pd(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_PD_32();
    uint res = src ^ m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_32_di(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_DI_32();
    uint res = src ^ m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_32_ix(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_IX_32();
    uint res = src ^ m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_32_aw(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AW_32();
    uint res = src ^ m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_32_al(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AL_32();
    uint res = src ^ m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_eori_16_toc(void)
{
    m68ki_set_ccr(m68ki_get_ccr() ^ OPER_I_8());
}

static void m68k_op_eori_16_tos(void)
{
    if (FLAG_S) {
        uint src = OPER_I_16();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_set_sr(m68ki_get_sr() ^ src);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_exg_32_dd(void)
{
    uint* reg_a = &DX;
    uint* reg_b = &DY;
    uint tmp = *reg_a;
    *reg_a = *reg_b;
    *reg_b = tmp;
}

static void m68k_op_exg_32_aa(void)
{
    uint* reg_a = &AX;
    uint* reg_b = &AY;
    uint tmp = *reg_a;
    *reg_a = *reg_b;
    *reg_b = tmp;
}

static void m68k_op_exg_32_da(void)
{
    uint* reg_a = &DX;
    uint* reg_b = &AY;
    uint tmp = *reg_a;
    *reg_a = *reg_b;
    *reg_b = tmp;
}

static void m68k_op_ext_16(void)
{
    uint* r_dst = &DY;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | MASK_OUT_ABOVE_8(*r_dst) | (GET_MSB_8(*r_dst) ? 0xff00 : 0);

    FLAG_N = NFLAG_16(*r_dst);
    FLAG_Z = MASK_OUT_ABOVE_16(*r_dst);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_ext_32(void)
{
    uint* r_dst = &DY;

    *r_dst = MASK_OUT_ABOVE_16(*r_dst) | (GET_MSB_16(*r_dst) ? 0xffff0000 : 0);

    FLAG_N = NFLAG_32(*r_dst);
    FLAG_Z = *r_dst;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_extb_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint* r_dst = &DY;

        *r_dst = MASK_OUT_ABOVE_8(*r_dst) | (GET_MSB_8(*r_dst) ? 0xffffff00 : 0);

        FLAG_N = NFLAG_32(*r_dst);
        FLAG_Z = *r_dst;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_illegal(void)
{
    m68ki_exception_illegal();
}

static void m68k_op_jmp_32_ai(void)
{
    m68ki_jump(EA_AY_AI_32());
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    if (REG_PC == REG_PPC) {
        USE_ALL_CYCLES();
    }
}

static void m68k_op_jmp_32_di(void)
{
    m68ki_jump(EA_AY_DI_32());
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    if (REG_PC == REG_PPC) {
        USE_ALL_CYCLES();
    }
}

static void m68k_op_jmp_32_ix(void)
{
    m68ki_jump(EA_AY_IX_32());
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    if (REG_PC == REG_PPC) {
        USE_ALL_CYCLES();
    }
}

static void m68k_op_jmp_32_aw(void)
{
    m68ki_jump(EA_AW_32());
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    if (REG_PC == REG_PPC) {
        USE_ALL_CYCLES();
    }
}

static void m68k_op_jmp_32_al(void)
{
    m68ki_jump(EA_AL_32());
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    if (REG_PC == REG_PPC) {
        USE_ALL_CYCLES();
    }
}

static void m68k_op_jmp_32_pcdi(void)
{
    m68ki_jump(EA_PCDI_32());
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    if (REG_PC == REG_PPC) {
        USE_ALL_CYCLES();
    }
}

static void m68k_op_jmp_32_pcix(void)
{
    m68ki_jump(EA_PCIX_32());
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    if (REG_PC == REG_PPC) {
        USE_ALL_CYCLES();
    }
}

static void m68k_op_jsr_32_ai(void)
{
    uint ea = EA_AY_AI_32();
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    m68ki_push_32(REG_PC);
    m68ki_jump(ea);
}

static void m68k_op_jsr_32_di(void)
{
    uint ea = EA_AY_DI_32();
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    m68ki_push_32(REG_PC);
    m68ki_jump(ea);
}

static void m68k_op_jsr_32_ix(void)
{
    uint ea = EA_AY_IX_32();
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    m68ki_push_32(REG_PC);
    m68ki_jump(ea);
}

static void m68k_op_jsr_32_aw(void)
{
    uint ea = EA_AW_32();
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    m68ki_push_32(REG_PC);
    m68ki_jump(ea);
}

static void m68k_op_jsr_32_al(void)
{
    uint ea = EA_AL_32();
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    m68ki_push_32(REG_PC);
    m68ki_jump(ea);
}

static void m68k_op_jsr_32_pcdi(void)
{
    uint ea = EA_PCDI_32();
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    m68ki_push_32(REG_PC);
    m68ki_jump(ea);
}

static void m68k_op_jsr_32_pcix(void)
{
    uint ea = EA_PCIX_32();
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    m68ki_push_32(REG_PC);
    m68ki_jump(ea);
}

static void m68k_op_lea_32_ai(void)
{
    AX = EA_AY_AI_32();
}

static void m68k_op_lea_32_di(void)
{
    AX = EA_AY_DI_32();
}

static void m68k_op_lea_32_ix(void)
{
    AX = EA_AY_IX_32();
}

static void m68k_op_lea_32_aw(void)
{
    AX = EA_AW_32();
}

static void m68k_op_lea_32_al(void)
{
    AX = EA_AL_32();
}

static void m68k_op_lea_32_pcdi(void)
{
    AX = EA_PCDI_32();
}

static void m68k_op_lea_32_pcix(void)
{
    AX = EA_PCIX_32();
}

static void m68k_op_link_16_a7(void)
{
    REG_A[7] -= 4;
    m68ki_write_32(REG_A[7], REG_A[7]);
    REG_A[7] = MASK_OUT_ABOVE_32(REG_A[7] + MAKE_INT_16(OPER_I_16()));
}

static void m68k_op_link_16(void)
{
    uint* r_dst = &AY;

    m68ki_push_32(*r_dst);
    *r_dst = REG_A[7];
    REG_A[7] = MASK_OUT_ABOVE_32(REG_A[7] + MAKE_INT_16(OPER_I_16()));
}

static void m68k_op_link_32_a7(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_A[7] -= 4;
        m68ki_write_32(REG_A[7], REG_A[7]);
        REG_A[7] = MASK_OUT_ABOVE_32(REG_A[7] + OPER_I_32());
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_link_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint* r_dst = &AY;

        m68ki_push_32(*r_dst);
        *r_dst = REG_A[7];
        REG_A[7] = MASK_OUT_ABOVE_32(REG_A[7] + OPER_I_32());
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_lsr_8_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src >> shift;

    if (shift != 0 && CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_CLEAR;
    FLAG_Z = res;
    FLAG_X = FLAG_C = src << (9 - shift);
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsr_16_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src >> shift;

    if (shift != 0 && CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_CLEAR;
    FLAG_Z = res;
    FLAG_X = FLAG_C = src << (9 - shift);
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsr_32_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = *r_dst;
    uint res = src >> shift;

    if (shift != 0 && CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = res;

    FLAG_N = NFLAG_CLEAR;
    FLAG_Z = res;
    FLAG_X = FLAG_C = src << (9 - shift);
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsr_8_r(void)
{
    uint* r_dst = &DY;
    uint shift = DX & 0x3f;
    uint src = MASK_OUT_ABOVE_8(*r_dst);
    uint res = src >> shift;

    if (shift != 0) {
        if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
            USE_CYCLES(shift << CYC_SHIFT);
        }

        if (shift <= 8) {
            *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;
            FLAG_X = FLAG_C = src << (9 - shift);
            FLAG_N = NFLAG_CLEAR;
            FLAG_Z = res;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        *r_dst &= 0xffffff00;
        FLAG_X = XFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        FLAG_N = NFLAG_CLEAR;
        FLAG_Z = ZFLAG_SET;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_8(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsr_16_r(void)
{
    uint* r_dst = &DY;
    uint shift = DX & 0x3f;
    uint src = MASK_OUT_ABOVE_16(*r_dst);
    uint res = src >> shift;

    if (shift != 0) {
        if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
            USE_CYCLES(shift << CYC_SHIFT);
        }

        if (shift <= 16) {
            *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
            FLAG_C = FLAG_X = (src >> (shift - 1)) << 8;
            FLAG_N = NFLAG_CLEAR;
            FLAG_Z = res;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        *r_dst &= 0xffff0000;
        FLAG_X = XFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        FLAG_N = NFLAG_CLEAR;
        FLAG_Z = ZFLAG_SET;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_16(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsr_32_r(void)
{
    uint* r_dst = &DY;
    uint shift = DX & 0x3f;
    uint src = *r_dst;
    uint res = src >> shift;

    if (shift != 0) {
        if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
            USE_CYCLES(shift << CYC_SHIFT);
        }

        if (shift < 32) {
            *r_dst = res;
            FLAG_C = FLAG_X = (src >> (shift - 1)) << 8;
            FLAG_N = NFLAG_CLEAR;
            FLAG_Z = res;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        *r_dst = 0;
        FLAG_X = FLAG_C = (shift == 32 ? GET_MSB_32(src) >> 23 : 0);
        FLAG_N = NFLAG_CLEAR;
        FLAG_Z = ZFLAG_SET;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_32(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsr_16_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint src = m68ki_read_16(ea);
    uint res = src >> 1;

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_CLEAR;
    FLAG_Z = res;
    FLAG_C = FLAG_X = src << 8;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsr_16_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint src = m68ki_read_16(ea);
    uint res = src >> 1;

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_CLEAR;
    FLAG_Z = res;
    FLAG_C = FLAG_X = src << 8;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsr_16_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint src = m68ki_read_16(ea);
    uint res = src >> 1;

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_CLEAR;
    FLAG_Z = res;
    FLAG_C = FLAG_X = src << 8;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsr_16_di(void)
{
    uint ea = EA_AY_DI_16();
    uint src = m68ki_read_16(ea);
    uint res = src >> 1;

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_CLEAR;
    FLAG_Z = res;
    FLAG_C = FLAG_X = src << 8;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsr_16_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint src = m68ki_read_16(ea);
    uint res = src >> 1;

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_CLEAR;
    FLAG_Z = res;
    FLAG_C = FLAG_X = src << 8;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsr_16_aw(void)
{
    uint ea = EA_AW_16();
    uint src = m68ki_read_16(ea);
    uint res = src >> 1;

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_CLEAR;
    FLAG_Z = res;
    FLAG_C = FLAG_X = src << 8;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsr_16_al(void)
{
    uint ea = EA_AL_16();
    uint src = m68ki_read_16(ea);
    uint res = src >> 1;

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_CLEAR;
    FLAG_Z = res;
    FLAG_C = FLAG_X = src << 8;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsl_8_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = MASK_OUT_ABOVE_8(*r_dst);
    uint res = MASK_OUT_ABOVE_8(src << shift);

    if (shift != 0 && CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src << shift;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsl_16_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = MASK_OUT_ABOVE_16(*r_dst);
    uint res = MASK_OUT_ABOVE_16(src << shift);

    if (shift != 0 && CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> (8 - shift);
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsl_32_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = *r_dst;
    uint res = MASK_OUT_ABOVE_32(src << shift);

    if (shift != 0 && CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> (24 - shift);
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsl_8_r(void)
{
    uint* r_dst = &DY;
    uint shift = DX & 0x3f;
    uint src = MASK_OUT_ABOVE_8(*r_dst);
    uint res = MASK_OUT_ABOVE_8(src << shift);

    if (shift != 0) {
        if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
            USE_CYCLES(shift << CYC_SHIFT);
        }

        if (shift <= 8) {
            *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;
            FLAG_X = FLAG_C = src << shift;
            FLAG_N = NFLAG_8(res);
            FLAG_Z = res;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        *r_dst &= 0xffffff00;
        FLAG_X = XFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        FLAG_N = NFLAG_CLEAR;
        FLAG_Z = ZFLAG_SET;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_8(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsl_16_r(void)
{
    uint* r_dst = &DY;
    uint shift = DX & 0x3f;
    uint src = MASK_OUT_ABOVE_16(*r_dst);
    uint res = MASK_OUT_ABOVE_16(src << shift);

    if (shift != 0) {
        if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
            USE_CYCLES(shift << CYC_SHIFT);
        }

        if (shift <= 16) {
            *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
            FLAG_X = FLAG_C = (src << shift) >> 8;
            FLAG_N = NFLAG_16(res);
            FLAG_Z = res;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        *r_dst &= 0xffff0000;
        FLAG_X = XFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        FLAG_N = NFLAG_CLEAR;
        FLAG_Z = ZFLAG_SET;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_16(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsl_32_r(void)
{
    uint* r_dst = &DY;
    uint shift = DX & 0x3f;
    uint src = *r_dst;
    uint res = MASK_OUT_ABOVE_32(src << shift);

    if (shift != 0) {
        if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
            USE_CYCLES(shift << CYC_SHIFT);
        }

        if (shift < 32) {
            *r_dst = res;
            FLAG_X = FLAG_C = (src >> (32 - shift)) << 8;
            FLAG_N = NFLAG_32(res);
            FLAG_Z = res;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        *r_dst = 0;
        FLAG_X = FLAG_C = ((shift == 32 ? src & 1 : 0)) << 8;
        FLAG_N = NFLAG_CLEAR;
        FLAG_Z = ZFLAG_SET;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_32(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsl_16_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(src << 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> 7;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsl_16_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(src << 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> 7;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsl_16_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(src << 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> 7;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsl_16_di(void)
{
    uint ea = EA_AY_DI_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(src << 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> 7;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsl_16_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(src << 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> 7;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsl_16_aw(void)
{
    uint ea = EA_AW_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(src << 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> 7;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_lsl_16_al(void)
{
    uint ea = EA_AL_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(src << 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_X = FLAG_C = src >> 7;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_move_8_d_d(void)
{
    uint res = MASK_OUT_ABOVE_8(DY);
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_d_ai(void)
{
    uint res = OPER_AY_AI_8();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_d_pi(void)
{
    uint res = OPER_AY_PI_8();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_d_pi7(void)
{
    uint res = OPER_A7_PI_8();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_d_pd(void)
{
    uint res = OPER_AY_PD_8();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_d_pd7(void)
{
    uint res = OPER_A7_PD_8();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_d_di(void)
{
    uint res = OPER_AY_DI_8();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_d_ix(void)
{
    uint res = OPER_AY_IX_8();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_d_aw(void)
{
    uint res = OPER_AW_8();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_d_al(void)
{
    uint res = OPER_AL_8();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_d_pcdi(void)
{
    uint res = OPER_PCDI_8();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_d_pcix(void)
{
    uint res = OPER_PCIX_8();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_d_i(void)
{
    uint res = OPER_I_8();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ai_d(void)
{
    uint res = MASK_OUT_ABOVE_8(DY);
    uint ea = EA_AX_AI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ai_ai(void)
{
    uint res = OPER_AY_AI_8();
    uint ea = EA_AX_AI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ai_pi(void)
{
    uint res = OPER_AY_PI_8();
    uint ea = EA_AX_AI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ai_pi7(void)
{
    uint res = OPER_A7_PI_8();
    uint ea = EA_AX_AI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ai_pd(void)
{
    uint res = OPER_AY_PD_8();
    uint ea = EA_AX_AI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ai_pd7(void)
{
    uint res = OPER_A7_PD_8();
    uint ea = EA_AX_AI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ai_di(void)
{
    uint res = OPER_AY_DI_8();
    uint ea = EA_AX_AI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ai_ix(void)
{
    uint res = OPER_AY_IX_8();
    uint ea = EA_AX_AI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ai_aw(void)
{
    uint res = OPER_AW_8();
    uint ea = EA_AX_AI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ai_al(void)
{
    uint res = OPER_AL_8();
    uint ea = EA_AX_AI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ai_pcdi(void)
{
    uint res = OPER_PCDI_8();
    uint ea = EA_AX_AI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ai_pcix(void)
{
    uint res = OPER_PCIX_8();
    uint ea = EA_AX_AI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ai_i(void)
{
    uint res = OPER_I_8();
    uint ea = EA_AX_AI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi7_d(void)
{
    uint res = MASK_OUT_ABOVE_8(DY);
    uint ea = EA_A7_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi_d(void)
{
    uint res = MASK_OUT_ABOVE_8(DY);
    uint ea = EA_AX_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi7_ai(void)
{
    uint res = OPER_AY_AI_8();
    uint ea = EA_A7_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi7_pi(void)
{
    uint res = OPER_AY_PI_8();
    uint ea = EA_A7_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi7_pi7(void)
{
    uint res = OPER_A7_PI_8();
    uint ea = EA_A7_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi7_pd(void)
{
    uint res = OPER_AY_PD_8();
    uint ea = EA_A7_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi7_pd7(void)
{
    uint res = OPER_A7_PD_8();
    uint ea = EA_A7_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi7_di(void)
{
    uint res = OPER_AY_DI_8();
    uint ea = EA_A7_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi7_ix(void)
{
    uint res = OPER_AY_IX_8();
    uint ea = EA_A7_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi7_aw(void)
{
    uint res = OPER_AW_8();
    uint ea = EA_A7_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi7_al(void)
{
    uint res = OPER_AL_8();
    uint ea = EA_A7_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi7_pcdi(void)
{
    uint res = OPER_PCDI_8();
    uint ea = EA_A7_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi7_pcix(void)
{
    uint res = OPER_PCIX_8();
    uint ea = EA_A7_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi7_i(void)
{
    uint res = OPER_I_8();
    uint ea = EA_A7_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi_ai(void)
{
    uint res = OPER_AY_AI_8();
    uint ea = EA_AX_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi_pi(void)
{
    uint res = OPER_AY_PI_8();
    uint ea = EA_AX_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi_pi7(void)
{
    uint res = OPER_A7_PI_8();
    uint ea = EA_AX_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi_pd(void)
{
    uint res = OPER_AY_PD_8();
    uint ea = EA_AX_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi_pd7(void)
{
    uint res = OPER_A7_PD_8();
    uint ea = EA_AX_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi_di(void)
{
    uint res = OPER_AY_DI_8();
    uint ea = EA_AX_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi_ix(void)
{
    uint res = OPER_AY_IX_8();
    uint ea = EA_AX_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi_aw(void)
{
    uint res = OPER_AW_8();
    uint ea = EA_AX_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi_al(void)
{
    uint res = OPER_AL_8();
    uint ea = EA_AX_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi_pcdi(void)
{
    uint res = OPER_PCDI_8();
    uint ea = EA_AX_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi_pcix(void)
{
    uint res = OPER_PCIX_8();
    uint ea = EA_AX_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pi_i(void)
{
    uint res = OPER_I_8();
    uint ea = EA_AX_PI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd7_d(void)
{
    uint res = MASK_OUT_ABOVE_8(DY);
    uint ea = EA_A7_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd_d(void)
{
    uint res = MASK_OUT_ABOVE_8(DY);
    uint ea = EA_AX_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd7_ai(void)
{
    uint res = OPER_AY_AI_8();
    uint ea = EA_A7_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd7_pi(void)
{
    uint res = OPER_AY_PI_8();
    uint ea = EA_A7_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd7_pi7(void)
{
    uint res = OPER_A7_PI_8();
    uint ea = EA_A7_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd7_pd(void)
{
    uint res = OPER_AY_PD_8();
    uint ea = EA_A7_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd7_pd7(void)
{
    uint res = OPER_A7_PD_8();
    uint ea = EA_A7_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd7_di(void)
{
    uint res = OPER_AY_DI_8();
    uint ea = EA_A7_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd7_ix(void)
{
    uint res = OPER_AY_IX_8();
    uint ea = EA_A7_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd7_aw(void)
{
    uint res = OPER_AW_8();
    uint ea = EA_A7_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd7_al(void)
{
    uint res = OPER_AL_8();
    uint ea = EA_A7_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd7_pcdi(void)
{
    uint res = OPER_PCDI_8();
    uint ea = EA_A7_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd7_pcix(void)
{
    uint res = OPER_PCIX_8();
    uint ea = EA_A7_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd7_i(void)
{
    uint res = OPER_I_8();
    uint ea = EA_A7_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd_ai(void)
{
    uint res = OPER_AY_AI_8();
    uint ea = EA_AX_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd_pi(void)
{
    uint res = OPER_AY_PI_8();
    uint ea = EA_AX_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd_pi7(void)
{
    uint res = OPER_A7_PI_8();
    uint ea = EA_AX_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd_pd(void)
{
    uint res = OPER_AY_PD_8();
    uint ea = EA_AX_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd_pd7(void)
{
    uint res = OPER_A7_PD_8();
    uint ea = EA_AX_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd_di(void)
{
    uint res = OPER_AY_DI_8();
    uint ea = EA_AX_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd_ix(void)
{
    uint res = OPER_AY_IX_8();
    uint ea = EA_AX_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd_aw(void)
{
    uint res = OPER_AW_8();
    uint ea = EA_AX_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd_al(void)
{
    uint res = OPER_AL_8();
    uint ea = EA_AX_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd_pcdi(void)
{
    uint res = OPER_PCDI_8();
    uint ea = EA_AX_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd_pcix(void)
{
    uint res = OPER_PCIX_8();
    uint ea = EA_AX_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_pd_i(void)
{
    uint res = OPER_I_8();
    uint ea = EA_AX_PD_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_di_d(void)
{
    uint res = MASK_OUT_ABOVE_8(DY);
    uint ea = EA_AX_DI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_di_ai(void)
{
    uint res = OPER_AY_AI_8();
    uint ea = EA_AX_DI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_di_pi(void)
{
    uint res = OPER_AY_PI_8();
    uint ea = EA_AX_DI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_di_pi7(void)
{
    uint res = OPER_A7_PI_8();
    uint ea = EA_AX_DI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_di_pd(void)
{
    uint res = OPER_AY_PD_8();
    uint ea = EA_AX_DI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_di_pd7(void)
{
    uint res = OPER_A7_PD_8();
    uint ea = EA_AX_DI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_di_di(void)
{
    uint res = OPER_AY_DI_8();
    uint ea = EA_AX_DI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_di_ix(void)
{
    uint res = OPER_AY_IX_8();
    uint ea = EA_AX_DI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_di_aw(void)
{
    uint res = OPER_AW_8();
    uint ea = EA_AX_DI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_di_al(void)
{
    uint res = OPER_AL_8();
    uint ea = EA_AX_DI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_di_pcdi(void)
{
    uint res = OPER_PCDI_8();
    uint ea = EA_AX_DI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_di_pcix(void)
{
    uint res = OPER_PCIX_8();
    uint ea = EA_AX_DI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_di_i(void)
{
    uint res = OPER_I_8();
    uint ea = EA_AX_DI_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ix_d(void)
{
    uint res = MASK_OUT_ABOVE_8(DY);
    uint ea = EA_AX_IX_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ix_ai(void)
{
    uint res = OPER_AY_AI_8();
    uint ea = EA_AX_IX_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ix_pi(void)
{
    uint res = OPER_AY_PI_8();
    uint ea = EA_AX_IX_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ix_pi7(void)
{
    uint res = OPER_A7_PI_8();
    uint ea = EA_AX_IX_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ix_pd(void)
{
    uint res = OPER_AY_PD_8();
    uint ea = EA_AX_IX_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ix_pd7(void)
{
    uint res = OPER_A7_PD_8();
    uint ea = EA_AX_IX_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ix_di(void)
{
    uint res = OPER_AY_DI_8();
    uint ea = EA_AX_IX_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ix_ix(void)
{
    uint res = OPER_AY_IX_8();
    uint ea = EA_AX_IX_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ix_aw(void)
{
    uint res = OPER_AW_8();
    uint ea = EA_AX_IX_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ix_al(void)
{
    uint res = OPER_AL_8();
    uint ea = EA_AX_IX_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ix_pcdi(void)
{
    uint res = OPER_PCDI_8();
    uint ea = EA_AX_IX_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ix_pcix(void)
{
    uint res = OPER_PCIX_8();
    uint ea = EA_AX_IX_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_ix_i(void)
{
    uint res = OPER_I_8();
    uint ea = EA_AX_IX_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_aw_d(void)
{
    uint res = MASK_OUT_ABOVE_8(DY);
    uint ea = EA_AW_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_aw_ai(void)
{
    uint res = OPER_AY_AI_8();
    uint ea = EA_AW_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_aw_pi(void)
{
    uint res = OPER_AY_PI_8();
    uint ea = EA_AW_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_aw_pi7(void)
{
    uint res = OPER_A7_PI_8();
    uint ea = EA_AW_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_aw_pd(void)
{
    uint res = OPER_AY_PD_8();
    uint ea = EA_AW_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_aw_pd7(void)
{
    uint res = OPER_A7_PD_8();
    uint ea = EA_AW_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_aw_di(void)
{
    uint res = OPER_AY_DI_8();
    uint ea = EA_AW_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_aw_ix(void)
{
    uint res = OPER_AY_IX_8();
    uint ea = EA_AW_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_aw_aw(void)
{
    uint res = OPER_AW_8();
    uint ea = EA_AW_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_aw_al(void)
{
    uint res = OPER_AL_8();
    uint ea = EA_AW_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_aw_pcdi(void)
{
    uint res = OPER_PCDI_8();
    uint ea = EA_AW_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_aw_pcix(void)
{
    uint res = OPER_PCIX_8();
    uint ea = EA_AW_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_aw_i(void)
{
    uint res = OPER_I_8();
    uint ea = EA_AW_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_al_d(void)
{
    uint res = MASK_OUT_ABOVE_8(DY);
    uint ea = EA_AL_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_al_ai(void)
{
    uint res = OPER_AY_AI_8();
    uint ea = EA_AL_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_al_pi(void)
{
    uint res = OPER_AY_PI_8();
    uint ea = EA_AL_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_al_pi7(void)
{
    uint res = OPER_A7_PI_8();
    uint ea = EA_AL_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_al_pd(void)
{
    uint res = OPER_AY_PD_8();
    uint ea = EA_AL_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_al_pd7(void)
{
    uint res = OPER_A7_PD_8();
    uint ea = EA_AL_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_al_di(void)
{
    uint res = OPER_AY_DI_8();
    uint ea = EA_AL_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_al_ix(void)
{
    uint res = OPER_AY_IX_8();
    uint ea = EA_AL_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_al_aw(void)
{
    uint res = OPER_AW_8();
    uint ea = EA_AL_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_al_al(void)
{
    uint res = OPER_AL_8();
    uint ea = EA_AL_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_al_pcdi(void)
{
    uint res = OPER_PCDI_8();
    uint ea = EA_AL_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_al_pcix(void)
{
    uint res = OPER_PCIX_8();
    uint ea = EA_AL_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_8_al_i(void)
{
    uint res = OPER_I_8();
    uint ea = EA_AL_8();

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_d_d(void)
{
    uint res = MASK_OUT_ABOVE_16(DY);
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_d_a(void)
{
    uint res = MASK_OUT_ABOVE_16(AY);
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_d_ai(void)
{
    uint res = OPER_AY_AI_16();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_d_pi(void)
{
    uint res = OPER_AY_PI_16();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_d_pd(void)
{
    uint res = OPER_AY_PD_16();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_d_di(void)
{
    uint res = OPER_AY_DI_16();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_d_ix(void)
{
    uint res = OPER_AY_IX_16();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_d_aw(void)
{
    uint res = OPER_AW_16();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_d_al(void)
{
    uint res = OPER_AL_16();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_d_pcdi(void)
{
    uint res = OPER_PCDI_16();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_d_pcix(void)
{
    uint res = OPER_PCIX_16();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_d_i(void)
{
    uint res = OPER_I_16();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ai_d(void)
{
    uint res = MASK_OUT_ABOVE_16(DY);
    uint ea = EA_AX_AI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ai_a(void)
{
    uint res = MASK_OUT_ABOVE_16(AY);
    uint ea = EA_AX_AI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ai_ai(void)
{
    uint res = OPER_AY_AI_16();
    uint ea = EA_AX_AI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ai_pi(void)
{
    uint res = OPER_AY_PI_16();
    uint ea = EA_AX_AI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ai_pd(void)
{
    uint res = OPER_AY_PD_16();
    uint ea = EA_AX_AI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ai_di(void)
{
    uint res = OPER_AY_DI_16();
    uint ea = EA_AX_AI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ai_ix(void)
{
    uint res = OPER_AY_IX_16();
    uint ea = EA_AX_AI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ai_aw(void)
{
    uint res = OPER_AW_16();
    uint ea = EA_AX_AI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ai_al(void)
{
    uint res = OPER_AL_16();
    uint ea = EA_AX_AI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ai_pcdi(void)
{
    uint res = OPER_PCDI_16();
    uint ea = EA_AX_AI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ai_pcix(void)
{
    uint res = OPER_PCIX_16();
    uint ea = EA_AX_AI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ai_i(void)
{
    uint res = OPER_I_16();
    uint ea = EA_AX_AI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pi_d(void)
{
    uint res = MASK_OUT_ABOVE_16(DY);
    uint ea = EA_AX_PI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pi_a(void)
{
    uint res = MASK_OUT_ABOVE_16(AY);
    uint ea = EA_AX_PI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pi_ai(void)
{
    uint res = OPER_AY_AI_16();
    uint ea = EA_AX_PI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pi_pi(void)
{
    uint res = OPER_AY_PI_16();
    uint ea = EA_AX_PI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pi_pd(void)
{
    uint res = OPER_AY_PD_16();
    uint ea = EA_AX_PI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pi_di(void)
{
    uint res = OPER_AY_DI_16();
    uint ea = EA_AX_PI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pi_ix(void)
{
    uint res = OPER_AY_IX_16();
    uint ea = EA_AX_PI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pi_aw(void)
{
    uint res = OPER_AW_16();
    uint ea = EA_AX_PI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pi_al(void)
{
    uint res = OPER_AL_16();
    uint ea = EA_AX_PI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pi_pcdi(void)
{
    uint res = OPER_PCDI_16();
    uint ea = EA_AX_PI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pi_pcix(void)
{
    uint res = OPER_PCIX_16();
    uint ea = EA_AX_PI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pi_i(void)
{
    uint res = OPER_I_16();
    uint ea = EA_AX_PI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pd_d(void)
{
    uint res = MASK_OUT_ABOVE_16(DY);
    uint ea = EA_AX_PD_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pd_a(void)
{
    uint res = MASK_OUT_ABOVE_16(AY);
    uint ea = EA_AX_PD_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pd_ai(void)
{
    uint res = OPER_AY_AI_16();
    uint ea = EA_AX_PD_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pd_pi(void)
{
    uint res = OPER_AY_PI_16();
    uint ea = EA_AX_PD_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pd_pd(void)
{
    uint res = OPER_AY_PD_16();
    uint ea = EA_AX_PD_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pd_di(void)
{
    uint res = OPER_AY_DI_16();
    uint ea = EA_AX_PD_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pd_ix(void)
{
    uint res = OPER_AY_IX_16();
    uint ea = EA_AX_PD_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pd_aw(void)
{
    uint res = OPER_AW_16();
    uint ea = EA_AX_PD_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pd_al(void)
{
    uint res = OPER_AL_16();
    uint ea = EA_AX_PD_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pd_pcdi(void)
{
    uint res = OPER_PCDI_16();
    uint ea = EA_AX_PD_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pd_pcix(void)
{
    uint res = OPER_PCIX_16();
    uint ea = EA_AX_PD_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_pd_i(void)
{
    uint res = OPER_I_16();
    uint ea = EA_AX_PD_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_di_d(void)
{
    uint res = MASK_OUT_ABOVE_16(DY);
    uint ea = EA_AX_DI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_di_a(void)
{
    uint res = MASK_OUT_ABOVE_16(AY);
    uint ea = EA_AX_DI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_di_ai(void)
{
    uint res = OPER_AY_AI_16();
    uint ea = EA_AX_DI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_di_pi(void)
{
    uint res = OPER_AY_PI_16();
    uint ea = EA_AX_DI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_di_pd(void)
{
    uint res = OPER_AY_PD_16();
    uint ea = EA_AX_DI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_di_di(void)
{
    uint res = OPER_AY_DI_16();
    uint ea = EA_AX_DI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_di_ix(void)
{
    uint res = OPER_AY_IX_16();
    uint ea = EA_AX_DI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_di_aw(void)
{
    uint res = OPER_AW_16();
    uint ea = EA_AX_DI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_di_al(void)
{
    uint res = OPER_AL_16();
    uint ea = EA_AX_DI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_di_pcdi(void)
{
    uint res = OPER_PCDI_16();
    uint ea = EA_AX_DI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_di_pcix(void)
{
    uint res = OPER_PCIX_16();
    uint ea = EA_AX_DI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_di_i(void)
{
    uint res = OPER_I_16();
    uint ea = EA_AX_DI_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ix_d(void)
{
    uint res = MASK_OUT_ABOVE_16(DY);
    uint ea = EA_AX_IX_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ix_a(void)
{
    uint res = MASK_OUT_ABOVE_16(AY);
    uint ea = EA_AX_IX_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ix_ai(void)
{
    uint res = OPER_AY_AI_16();
    uint ea = EA_AX_IX_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ix_pi(void)
{
    uint res = OPER_AY_PI_16();
    uint ea = EA_AX_IX_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ix_pd(void)
{
    uint res = OPER_AY_PD_16();
    uint ea = EA_AX_IX_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ix_di(void)
{
    uint res = OPER_AY_DI_16();
    uint ea = EA_AX_IX_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ix_ix(void)
{
    uint res = OPER_AY_IX_16();
    uint ea = EA_AX_IX_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ix_aw(void)
{
    uint res = OPER_AW_16();
    uint ea = EA_AX_IX_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ix_al(void)
{
    uint res = OPER_AL_16();
    uint ea = EA_AX_IX_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ix_pcdi(void)
{
    uint res = OPER_PCDI_16();
    uint ea = EA_AX_IX_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ix_pcix(void)
{
    uint res = OPER_PCIX_16();
    uint ea = EA_AX_IX_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_ix_i(void)
{
    uint res = OPER_I_16();
    uint ea = EA_AX_IX_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_aw_d(void)
{
    uint res = MASK_OUT_ABOVE_16(DY);
    uint ea = EA_AW_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_aw_a(void)
{
    uint res = MASK_OUT_ABOVE_16(AY);
    uint ea = EA_AW_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_aw_ai(void)
{
    uint res = OPER_AY_AI_16();
    uint ea = EA_AW_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_aw_pi(void)
{
    uint res = OPER_AY_PI_16();
    uint ea = EA_AW_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_aw_pd(void)
{
    uint res = OPER_AY_PD_16();
    uint ea = EA_AW_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_aw_di(void)
{
    uint res = OPER_AY_DI_16();
    uint ea = EA_AW_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_aw_ix(void)
{
    uint res = OPER_AY_IX_16();
    uint ea = EA_AW_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_aw_aw(void)
{
    uint res = OPER_AW_16();
    uint ea = EA_AW_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_aw_al(void)
{
    uint res = OPER_AL_16();
    uint ea = EA_AW_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_aw_pcdi(void)
{
    uint res = OPER_PCDI_16();
    uint ea = EA_AW_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_aw_pcix(void)
{
    uint res = OPER_PCIX_16();
    uint ea = EA_AW_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_aw_i(void)
{
    uint res = OPER_I_16();
    uint ea = EA_AW_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_al_d(void)
{
    uint res = MASK_OUT_ABOVE_16(DY);
    uint ea = EA_AL_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_al_a(void)
{
    uint res = MASK_OUT_ABOVE_16(AY);
    uint ea = EA_AL_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_al_ai(void)
{
    uint res = OPER_AY_AI_16();
    uint ea = EA_AL_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_al_pi(void)
{
    uint res = OPER_AY_PI_16();
    uint ea = EA_AL_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_al_pd(void)
{
    uint res = OPER_AY_PD_16();
    uint ea = EA_AL_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_al_di(void)
{
    uint res = OPER_AY_DI_16();
    uint ea = EA_AL_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_al_ix(void)
{
    uint res = OPER_AY_IX_16();
    uint ea = EA_AL_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_al_aw(void)
{
    uint res = OPER_AW_16();
    uint ea = EA_AL_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_al_al(void)
{
    uint res = OPER_AL_16();
    uint ea = EA_AL_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_al_pcdi(void)
{
    uint res = OPER_PCDI_16();
    uint ea = EA_AL_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_al_pcix(void)
{
    uint res = OPER_PCIX_16();
    uint ea = EA_AL_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_16_al_i(void)
{
    uint res = OPER_I_16();
    uint ea = EA_AL_16();

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_d_d(void)
{
    uint res = DY;
    uint* r_dst = &DX;

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_d_a(void)
{
    uint res = AY;
    uint* r_dst = &DX;

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_d_ai(void)
{
    uint res = OPER_AY_AI_32();
    uint* r_dst = &DX;

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_d_pi(void)
{
    uint res = OPER_AY_PI_32();
    uint* r_dst = &DX;

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_d_pd(void)
{
    uint res = OPER_AY_PD_32();
    uint* r_dst = &DX;

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_d_di(void)
{
    uint res = OPER_AY_DI_32();
    uint* r_dst = &DX;

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_d_ix(void)
{
    uint res = OPER_AY_IX_32();
    uint* r_dst = &DX;

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_d_aw(void)
{
    uint res = OPER_AW_32();
    uint* r_dst = &DX;

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_d_al(void)
{
    uint res = OPER_AL_32();
    uint* r_dst = &DX;

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_d_pcdi(void)
{
    uint res = OPER_PCDI_32();
    uint* r_dst = &DX;

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_d_pcix(void)
{
    uint res = OPER_PCIX_32();
    uint* r_dst = &DX;

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_d_i(void)
{
    uint res = OPER_I_32();
    uint* r_dst = &DX;

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ai_d(void)
{
    uint res = DY;
    uint ea = EA_AX_AI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ai_a(void)
{
    uint res = AY;
    uint ea = EA_AX_AI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ai_ai(void)
{
    uint res = OPER_AY_AI_32();
    uint ea = EA_AX_AI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ai_pi(void)
{
    uint res = OPER_AY_PI_32();
    uint ea = EA_AX_AI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ai_pd(void)
{
    uint res = OPER_AY_PD_32();
    uint ea = EA_AX_AI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ai_di(void)
{
    uint res = OPER_AY_DI_32();
    uint ea = EA_AX_AI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ai_ix(void)
{
    uint res = OPER_AY_IX_32();
    uint ea = EA_AX_AI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ai_aw(void)
{
    uint res = OPER_AW_32();
    uint ea = EA_AX_AI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ai_al(void)
{
    uint res = OPER_AL_32();
    uint ea = EA_AX_AI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ai_pcdi(void)
{
    uint res = OPER_PCDI_32();
    uint ea = EA_AX_AI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ai_pcix(void)
{
    uint res = OPER_PCIX_32();
    uint ea = EA_AX_AI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ai_i(void)
{
    uint res = OPER_I_32();
    uint ea = EA_AX_AI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pi_d(void)
{
    uint res = DY;
    uint ea = EA_AX_PI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pi_a(void)
{
    uint res = AY;
    uint ea = EA_AX_PI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pi_ai(void)
{
    uint res = OPER_AY_AI_32();
    uint ea = EA_AX_PI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pi_pi(void)
{
    uint res = OPER_AY_PI_32();
    uint ea = EA_AX_PI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pi_pd(void)
{
    uint res = OPER_AY_PD_32();
    uint ea = EA_AX_PI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pi_di(void)
{
    uint res = OPER_AY_DI_32();
    uint ea = EA_AX_PI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pi_ix(void)
{
    uint res = OPER_AY_IX_32();
    uint ea = EA_AX_PI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pi_aw(void)
{
    uint res = OPER_AW_32();
    uint ea = EA_AX_PI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pi_al(void)
{
    uint res = OPER_AL_32();
    uint ea = EA_AX_PI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pi_pcdi(void)
{
    uint res = OPER_PCDI_32();
    uint ea = EA_AX_PI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pi_pcix(void)
{
    uint res = OPER_PCIX_32();
    uint ea = EA_AX_PI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pi_i(void)
{
    uint res = OPER_I_32();
    uint ea = EA_AX_PI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pd_d(void)
{
    uint res = DY;
    uint ea = EA_AX_PD_32();

    m68ki_write_16(ea + 2, res & 0xFFFF);
    m68ki_write_16(ea, (res >> 16) & 0xFFFF);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pd_a(void)
{
    uint res = AY;
    uint ea = EA_AX_PD_32();

    m68ki_write_16(ea + 2, res & 0xFFFF);
    m68ki_write_16(ea, (res >> 16) & 0xFFFF);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pd_ai(void)
{
    uint res = OPER_AY_AI_32();
    uint ea = EA_AX_PD_32();

    m68ki_write_16(ea + 2, res & 0xFFFF);
    m68ki_write_16(ea, (res >> 16) & 0xFFFF);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pd_pi(void)
{
    uint res = OPER_AY_PI_32();
    uint ea = EA_AX_PD_32();

    m68ki_write_16(ea + 2, res & 0xFFFF);
    m68ki_write_16(ea, (res >> 16) & 0xFFFF);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pd_pd(void)
{
    uint res = OPER_AY_PD_32();
    uint ea = EA_AX_PD_32();

    m68ki_write_16(ea + 2, res & 0xFFFF);
    m68ki_write_16(ea, (res >> 16) & 0xFFFF);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pd_di(void)
{
    uint res = OPER_AY_DI_32();
    uint ea = EA_AX_PD_32();

    m68ki_write_16(ea + 2, res & 0xFFFF);
    m68ki_write_16(ea, (res >> 16) & 0xFFFF);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pd_ix(void)
{
    uint res = OPER_AY_IX_32();
    uint ea = EA_AX_PD_32();

    m68ki_write_16(ea + 2, res & 0xFFFF);
    m68ki_write_16(ea, (res >> 16) & 0xFFFF);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pd_aw(void)
{
    uint res = OPER_AW_32();
    uint ea = EA_AX_PD_32();

    m68ki_write_16(ea + 2, res & 0xFFFF);
    m68ki_write_16(ea, (res >> 16) & 0xFFFF);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pd_al(void)
{
    uint res = OPER_AL_32();
    uint ea = EA_AX_PD_32();

    m68ki_write_16(ea + 2, res & 0xFFFF);
    m68ki_write_16(ea, (res >> 16) & 0xFFFF);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pd_pcdi(void)
{
    uint res = OPER_PCDI_32();
    uint ea = EA_AX_PD_32();

    m68ki_write_16(ea + 2, res & 0xFFFF);
    m68ki_write_16(ea, (res >> 16) & 0xFFFF);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pd_pcix(void)
{
    uint res = OPER_PCIX_32();
    uint ea = EA_AX_PD_32();

    m68ki_write_16(ea + 2, res & 0xFFFF);
    m68ki_write_16(ea, (res >> 16) & 0xFFFF);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_pd_i(void)
{
    uint res = OPER_I_32();
    uint ea = EA_AX_PD_32();

    m68ki_write_16(ea + 2, res & 0xFFFF);
    m68ki_write_16(ea, (res >> 16) & 0xFFFF);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_di_d(void)
{
    uint res = DY;
    uint ea = EA_AX_DI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_di_a(void)
{
    uint res = AY;
    uint ea = EA_AX_DI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_di_ai(void)
{
    uint res = OPER_AY_AI_32();
    uint ea = EA_AX_DI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_di_pi(void)
{
    uint res = OPER_AY_PI_32();
    uint ea = EA_AX_DI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_di_pd(void)
{
    uint res = OPER_AY_PD_32();
    uint ea = EA_AX_DI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_di_di(void)
{
    uint res = OPER_AY_DI_32();
    uint ea = EA_AX_DI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_di_ix(void)
{
    uint res = OPER_AY_IX_32();
    uint ea = EA_AX_DI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_di_aw(void)
{
    uint res = OPER_AW_32();
    uint ea = EA_AX_DI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_di_al(void)
{
    uint res = OPER_AL_32();
    uint ea = EA_AX_DI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_di_pcdi(void)
{
    uint res = OPER_PCDI_32();
    uint ea = EA_AX_DI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_di_pcix(void)
{
    uint res = OPER_PCIX_32();
    uint ea = EA_AX_DI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_di_i(void)
{
    uint res = OPER_I_32();
    uint ea = EA_AX_DI_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ix_d(void)
{
    uint res = DY;
    uint ea = EA_AX_IX_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ix_a(void)
{
    uint res = AY;
    uint ea = EA_AX_IX_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ix_ai(void)
{
    uint res = OPER_AY_AI_32();
    uint ea = EA_AX_IX_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ix_pi(void)
{
    uint res = OPER_AY_PI_32();
    uint ea = EA_AX_IX_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ix_pd(void)
{
    uint res = OPER_AY_PD_32();
    uint ea = EA_AX_IX_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ix_di(void)
{
    uint res = OPER_AY_DI_32();
    uint ea = EA_AX_IX_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ix_ix(void)
{
    uint res = OPER_AY_IX_32();
    uint ea = EA_AX_IX_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ix_aw(void)
{
    uint res = OPER_AW_32();
    uint ea = EA_AX_IX_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ix_al(void)
{
    uint res = OPER_AL_32();
    uint ea = EA_AX_IX_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ix_pcdi(void)
{
    uint res = OPER_PCDI_32();
    uint ea = EA_AX_IX_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ix_pcix(void)
{
    uint res = OPER_PCIX_32();
    uint ea = EA_AX_IX_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_ix_i(void)
{
    uint res = OPER_I_32();
    uint ea = EA_AX_IX_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_aw_d(void)
{
    uint res = DY;
    uint ea = EA_AW_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_aw_a(void)
{
    uint res = AY;
    uint ea = EA_AW_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_aw_ai(void)
{
    uint res = OPER_AY_AI_32();
    uint ea = EA_AW_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_aw_pi(void)
{
    uint res = OPER_AY_PI_32();
    uint ea = EA_AW_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_aw_pd(void)
{
    uint res = OPER_AY_PD_32();
    uint ea = EA_AW_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_aw_di(void)
{
    uint res = OPER_AY_DI_32();
    uint ea = EA_AW_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_aw_ix(void)
{
    uint res = OPER_AY_IX_32();
    uint ea = EA_AW_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_aw_aw(void)
{
    uint res = OPER_AW_32();
    uint ea = EA_AW_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_aw_al(void)
{
    uint res = OPER_AL_32();
    uint ea = EA_AW_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_aw_pcdi(void)
{
    uint res = OPER_PCDI_32();
    uint ea = EA_AW_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_aw_pcix(void)
{
    uint res = OPER_PCIX_32();
    uint ea = EA_AW_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_aw_i(void)
{
    uint res = OPER_I_32();
    uint ea = EA_AW_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_al_d(void)
{
    uint res = DY;
    uint ea = EA_AL_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_al_a(void)
{
    uint res = AY;
    uint ea = EA_AL_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_al_ai(void)
{
    uint res = OPER_AY_AI_32();
    uint ea = EA_AL_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_al_pi(void)
{
    uint res = OPER_AY_PI_32();
    uint ea = EA_AL_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_al_pd(void)
{
    uint res = OPER_AY_PD_32();
    uint ea = EA_AL_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_al_di(void)
{
    uint res = OPER_AY_DI_32();
    uint ea = EA_AL_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_al_ix(void)
{
    uint res = OPER_AY_IX_32();
    uint ea = EA_AL_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_al_aw(void)
{
    uint res = OPER_AW_32();
    uint ea = EA_AL_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_al_al(void)
{
    uint res = OPER_AL_32();
    uint ea = EA_AL_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_al_pcdi(void)
{
    uint res = OPER_PCDI_32();
    uint ea = EA_AL_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_al_pcix(void)
{
    uint res = OPER_PCIX_32();
    uint ea = EA_AL_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move_32_al_i(void)
{
    uint res = OPER_I_32();
    uint ea = EA_AL_32();

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_movea_16_d(void)
{
    AX = MAKE_INT_16(DY);
}

static void m68k_op_movea_16_a(void)
{
    AX = MAKE_INT_16(AY);
}

static void m68k_op_movea_16_ai(void)
{
    AX = MAKE_INT_16(OPER_AY_AI_16());
}

static void m68k_op_movea_16_pi(void)
{
    AX = MAKE_INT_16(OPER_AY_PI_16());
}

static void m68k_op_movea_16_pd(void)
{
    AX = MAKE_INT_16(OPER_AY_PD_16());
}

static void m68k_op_movea_16_di(void)
{
    AX = MAKE_INT_16(OPER_AY_DI_16());
}

static void m68k_op_movea_16_ix(void)
{
    AX = MAKE_INT_16(OPER_AY_IX_16());
}

static void m68k_op_movea_16_aw(void)
{
    AX = MAKE_INT_16(OPER_AW_16());
}

static void m68k_op_movea_16_al(void)
{
    AX = MAKE_INT_16(OPER_AL_16());
}

static void m68k_op_movea_16_pcdi(void)
{
    AX = MAKE_INT_16(OPER_PCDI_16());
}

static void m68k_op_movea_16_pcix(void)
{
    AX = MAKE_INT_16(OPER_PCIX_16());
}

static void m68k_op_movea_16_i(void)
{
    AX = MAKE_INT_16(OPER_I_16());
}

static void m68k_op_movea_32_d(void)
{
    AX = DY;
}

static void m68k_op_movea_32_a(void)
{
    AX = AY;
}

static void m68k_op_movea_32_ai(void)
{
    AX = OPER_AY_AI_32();
}

static void m68k_op_movea_32_pi(void)
{
    AX = OPER_AY_PI_32();
}

static void m68k_op_movea_32_pd(void)
{
    AX = OPER_AY_PD_32();
}

static void m68k_op_movea_32_di(void)
{
    AX = OPER_AY_DI_32();
}

static void m68k_op_movea_32_ix(void)
{
    AX = OPER_AY_IX_32();
}

static void m68k_op_movea_32_aw(void)
{
    AX = OPER_AW_32();
}

static void m68k_op_movea_32_al(void)
{
    AX = OPER_AL_32();
}

static void m68k_op_movea_32_pcdi(void)
{
    AX = OPER_PCDI_32();
}

static void m68k_op_movea_32_pcix(void)
{
    AX = OPER_PCIX_32();
}

static void m68k_op_movea_32_i(void)
{
    AX = OPER_I_32();
}

static void m68k_op_move_16_frc_d(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        DY = MASK_OUT_BELOW_16(DY) | m68ki_get_ccr();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_move_16_frc_ai(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        m68ki_write_16(EA_AY_AI_16(), m68ki_get_ccr());
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_move_16_frc_pi(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        m68ki_write_16(EA_AY_PI_16(), m68ki_get_ccr());
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_move_16_frc_pd(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        m68ki_write_16(EA_AY_PD_16(), m68ki_get_ccr());
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_move_16_frc_di(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        m68ki_write_16(EA_AY_DI_16(), m68ki_get_ccr());
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_move_16_frc_ix(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        m68ki_write_16(EA_AY_IX_16(), m68ki_get_ccr());
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_move_16_frc_aw(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        m68ki_write_16(EA_AW_16(), m68ki_get_ccr());
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_move_16_frc_al(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        m68ki_write_16(EA_AL_16(), m68ki_get_ccr());
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_move_16_toc_d(void)
{
    m68ki_set_ccr(DY);
}

static void m68k_op_move_16_toc_ai(void)
{
    m68ki_set_ccr(OPER_AY_AI_16());
}

static void m68k_op_move_16_toc_pi(void)
{
    m68ki_set_ccr(OPER_AY_PI_16());
}

static void m68k_op_move_16_toc_pd(void)
{
    m68ki_set_ccr(OPER_AY_PD_16());
}

static void m68k_op_move_16_toc_di(void)
{
    m68ki_set_ccr(OPER_AY_DI_16());
}

static void m68k_op_move_16_toc_ix(void)
{
    m68ki_set_ccr(OPER_AY_IX_16());
}

static void m68k_op_move_16_toc_aw(void)
{
    m68ki_set_ccr(OPER_AW_16());
}

static void m68k_op_move_16_toc_al(void)
{
    m68ki_set_ccr(OPER_AL_16());
}

static void m68k_op_move_16_toc_pcdi(void)
{
    m68ki_set_ccr(OPER_PCDI_16());
}

static void m68k_op_move_16_toc_pcix(void)
{
    m68ki_set_ccr(OPER_PCIX_16());
}

static void m68k_op_move_16_toc_i(void)
{
    m68ki_set_ccr(OPER_I_16());
}

static void m68k_op_move_16_frs_d(void)
{
    if (CPU_TYPE_IS_000(CPU_TYPE) || FLAG_S) /* NS990408 */
    {
        DY = MASK_OUT_BELOW_16(DY) | m68ki_get_sr();
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_frs_ai(void)
{
    if (CPU_TYPE_IS_000(CPU_TYPE) || FLAG_S) /* NS990408 */
    {
        uint ea = EA_AY_AI_16();
        m68ki_write_16(ea, m68ki_get_sr());
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_frs_pi(void)
{
    if (CPU_TYPE_IS_000(CPU_TYPE) || FLAG_S) /* NS990408 */
    {
        uint ea = EA_AY_PI_16();
        m68ki_write_16(ea, m68ki_get_sr());
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_frs_pd(void)
{
    if (CPU_TYPE_IS_000(CPU_TYPE) || FLAG_S) /* NS990408 */
    {
        uint ea = EA_AY_PD_16();
        m68ki_write_16(ea, m68ki_get_sr());
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_frs_di(void)
{
    if (CPU_TYPE_IS_000(CPU_TYPE) || FLAG_S) /* NS990408 */
    {
        uint ea = EA_AY_DI_16();
        m68ki_write_16(ea, m68ki_get_sr());
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_frs_ix(void)
{
    if (CPU_TYPE_IS_000(CPU_TYPE) || FLAG_S) /* NS990408 */
    {
        uint ea = EA_AY_IX_16();
        m68ki_write_16(ea, m68ki_get_sr());
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_frs_aw(void)
{
    if (CPU_TYPE_IS_000(CPU_TYPE) || FLAG_S) /* NS990408 */
    {
        uint ea = EA_AW_16();
        m68ki_write_16(ea, m68ki_get_sr());
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_frs_al(void)
{
    if (CPU_TYPE_IS_000(CPU_TYPE) || FLAG_S) /* NS990408 */
    {
        uint ea = EA_AL_16();
        m68ki_write_16(ea, m68ki_get_sr());
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_tos_d(void)
{
    if (FLAG_S) {
        m68ki_set_sr(DY);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_tos_ai(void)
{
    if (FLAG_S) {
        uint new_sr = OPER_AY_AI_16();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_set_sr(new_sr);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_tos_pi(void)
{
    if (FLAG_S) {
        uint new_sr = OPER_AY_PI_16();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_set_sr(new_sr);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_tos_pd(void)
{
    if (FLAG_S) {
        uint new_sr = OPER_AY_PD_16();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_set_sr(new_sr);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_tos_di(void)
{
    if (FLAG_S) {
        uint new_sr = OPER_AY_DI_16();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_set_sr(new_sr);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_tos_ix(void)
{
    if (FLAG_S) {
        uint new_sr = OPER_AY_IX_16();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_set_sr(new_sr);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_tos_aw(void)
{
    if (FLAG_S) {
        uint new_sr = OPER_AW_16();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_set_sr(new_sr);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_tos_al(void)
{
    if (FLAG_S) {
        uint new_sr = OPER_AL_16();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_set_sr(new_sr);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_tos_pcdi(void)
{
    if (FLAG_S) {
        uint new_sr = OPER_PCDI_16();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_set_sr(new_sr);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_tos_pcix(void)
{
    if (FLAG_S) {
        uint new_sr = OPER_PCIX_16();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_set_sr(new_sr);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_16_tos_i(void)
{
    if (FLAG_S) {
        uint new_sr = OPER_I_16();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_set_sr(new_sr);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_32_fru(void)
{
    if (FLAG_S) {
        AY = REG_USP;
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_move_32_tou(void)
{
    if (FLAG_S) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        REG_USP = AY;
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_movec_32_cr(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            switch (word2 & 0xfff) {
                case 0x000: /* SFC */
                    REG_DA[(word2 >> 12) & 15] = REG_SFC;
                    return;
                case 0x001: /* DFC */
                    REG_DA[(word2 >> 12) & 15] = REG_DFC;
                    return;
                case 0x002: /* CACR */
                    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
                        REG_DA[(word2 >> 12) & 15] = REG_CACR;
                        return;
                    }
                    return;
                case 0x800: /* USP */
                    REG_DA[(word2 >> 12) & 15] = REG_USP;
                    return;
                case 0x801: /* VBR */
                    REG_DA[(word2 >> 12) & 15] = REG_VBR;
                    return;
                case 0x802: /* CAAR */
                    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
                        REG_DA[(word2 >> 12) & 15] = REG_CAAR;
                        return;
                    }
                    m68ki_exception_illegal();
                    break;
                case 0x803: /* MSP */
                    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
                        REG_DA[(word2 >> 12) & 15] = FLAG_M ? REG_SP : REG_MSP;
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x804: /* ISP */
                    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
                        REG_DA[(word2 >> 12) & 15] = FLAG_M ? REG_ISP : REG_SP;
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x003: /* TC */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x004: /* ITT0 */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x005: /* ITT1 */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x006: /* DTT0 */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x007: /* DTT1 */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x805: /* MMUSR */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x806: /* URP */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x807: /* SRP */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                default:
                    m68ki_exception_illegal();
                    return;
            }
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_movec_32_rc(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            switch (word2 & 0xfff) {
                case 0x000: /* SFC */
                    REG_SFC = REG_DA[(word2 >> 12) & 15] & 7;
                    return;
                case 0x001: /* DFC */
                    REG_DFC = REG_DA[(word2 >> 12) & 15] & 7;
                    return;
                case 0x002: /* CACR */
                    /* Only EC020 and later have CACR */
                    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
                        /* 68030 can write all bits except 5-7, 040 can write all */
                        if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                            REG_CACR = REG_DA[(word2 >> 12) & 15];
                        } else if (CPU_TYPE_IS_030_PLUS(CPU_TYPE)) {
                            REG_CACR = REG_DA[(word2 >> 12) & 15] & 0xff1f;
                        } else {
                            REG_CACR = REG_DA[(word2 >> 12) & 15] & 0x0f;
                        }
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x800: /* USP */
                    REG_USP = REG_DA[(word2 >> 12) & 15];
                    return;
                case 0x801: /* VBR */
                    REG_VBR = REG_DA[(word2 >> 12) & 15];
                    return;
                case 0x802: /* CAAR */
                    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
                        REG_CAAR = REG_DA[(word2 >> 12) & 15];
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x803: /* MSP */
                    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
                        /* we are in supervisor mode so just check for M flag */
                        if (!FLAG_M) {
                            REG_MSP = REG_DA[(word2 >> 12) & 15];
                            return;
                        }
                        REG_SP = REG_DA[(word2 >> 12) & 15];
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x804: /* ISP */
                    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
                        if (!FLAG_M) {
                            REG_SP = REG_DA[(word2 >> 12) & 15];
                            return;
                        }
                        REG_ISP = REG_DA[(word2 >> 12) & 15];
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x003: /* TC */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x004: /* ITT0 */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x005: /* ITT1 */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x006: /* DTT0 */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x007: /* DTT1 */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x805: /* MMUSR */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x806: /* URP */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                case 0x807: /* SRP */
                    if (CPU_TYPE_IS_040_PLUS(CPU_TYPE)) {
                        /* TODO */
                        return;
                    }
                    m68ki_exception_illegal();
                    return;
                default:
                    m68ki_exception_illegal();
                    return;
            }
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_movem_16_re_pd(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = AY;
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            ea -= 2;
            m68ki_write_16(ea, MASK_OUT_ABOVE_16(REG_DA[15 - i]));
            count++;
        }
    }
    AY = ea;

    USE_CYCLES(count << CYC_MOVEM_W);
}

static void m68k_op_movem_16_re_ai(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AY_AI_16();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            m68ki_write_16(ea, MASK_OUT_ABOVE_16(REG_DA[i]));
            ea += 2;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_W);
}

static void m68k_op_movem_16_re_di(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AY_DI_16();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            m68ki_write_16(ea, MASK_OUT_ABOVE_16(REG_DA[i]));
            ea += 2;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_W);
}

static void m68k_op_movem_16_re_ix(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AY_IX_16();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            m68ki_write_16(ea, MASK_OUT_ABOVE_16(REG_DA[i]));
            ea += 2;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_W);
}

static void m68k_op_movem_16_re_aw(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AW_16();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            m68ki_write_16(ea, MASK_OUT_ABOVE_16(REG_DA[i]));
            ea += 2;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_W);
}

static void m68k_op_movem_16_re_al(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AL_16();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            m68ki_write_16(ea, MASK_OUT_ABOVE_16(REG_DA[i]));
            ea += 2;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_W);
}

static void m68k_op_movem_32_re_pd(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = AY;
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            ea -= 4;
            m68ki_write_16(ea + 2, REG_DA[15 - i] & 0xFFFF);
            m68ki_write_16(ea, (REG_DA[15 - i] >> 16) & 0xFFFF);
            count++;
        }
    }
    AY = ea;

    USE_CYCLES(count << CYC_MOVEM_L);
}

static void m68k_op_movem_32_re_ai(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AY_AI_32();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            m68ki_write_32(ea, REG_DA[i]);
            ea += 4;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_L);
}

static void m68k_op_movem_32_re_di(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AY_DI_32();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            m68ki_write_32(ea, REG_DA[i]);
            ea += 4;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_L);
}

static void m68k_op_movem_32_re_ix(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AY_IX_32();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            m68ki_write_32(ea, REG_DA[i]);
            ea += 4;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_L);
}

static void m68k_op_movem_32_re_aw(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AW_32();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            m68ki_write_32(ea, REG_DA[i]);
            ea += 4;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_L);
}

static void m68k_op_movem_32_re_al(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AL_32();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            m68ki_write_32(ea, REG_DA[i]);
            ea += 4;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_L);
}

static void m68k_op_movem_16_er_pi(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = AY;
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = MAKE_INT_16(MASK_OUT_ABOVE_16(m68ki_read_16(ea)));
            ea += 2;
            count++;
        }
    }
    AY = ea;

    USE_CYCLES(count << CYC_MOVEM_W);
}

static void m68k_op_movem_16_er_pcdi(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_PCDI_16();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = MAKE_INT_16(MASK_OUT_ABOVE_16(m68ki_read_pcrel_16(ea)));
            ea += 2;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_W);
}

static void m68k_op_movem_16_er_pcix(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_PCIX_16();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = MAKE_INT_16(MASK_OUT_ABOVE_16(m68ki_read_pcrel_16(ea)));
            ea += 2;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_W);
}

static void m68k_op_movem_16_er_ai(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AY_AI_16();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = MAKE_INT_16(MASK_OUT_ABOVE_16(m68ki_read_16(ea)));
            ea += 2;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_W);
}

static void m68k_op_movem_16_er_di(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AY_DI_16();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = MAKE_INT_16(MASK_OUT_ABOVE_16(m68ki_read_16(ea)));
            ea += 2;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_W);
}

static void m68k_op_movem_16_er_ix(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AY_IX_16();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = MAKE_INT_16(MASK_OUT_ABOVE_16(m68ki_read_16(ea)));
            ea += 2;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_W);
}

static void m68k_op_movem_16_er_aw(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AW_16();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = MAKE_INT_16(MASK_OUT_ABOVE_16(m68ki_read_16(ea)));
            ea += 2;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_W);
}

static void m68k_op_movem_16_er_al(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AL_16();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = MAKE_INT_16(MASK_OUT_ABOVE_16(m68ki_read_16(ea)));
            ea += 2;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_W);
}

static void m68k_op_movem_32_er_pi(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = AY;
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = m68ki_read_32(ea);
            ea += 4;
            count++;
        }
    }
    AY = ea;

    USE_CYCLES(count << CYC_MOVEM_L);
}

static void m68k_op_movem_32_er_pcdi(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_PCDI_32();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = m68ki_read_pcrel_32(ea);
            ea += 4;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_L);
}

static void m68k_op_movem_32_er_pcix(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_PCIX_32();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = m68ki_read_pcrel_32(ea);
            ea += 4;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_L);
}

static void m68k_op_movem_32_er_ai(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AY_AI_32();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = m68ki_read_32(ea);
            ea += 4;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_L);
}

static void m68k_op_movem_32_er_di(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AY_DI_32();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = m68ki_read_32(ea);
            ea += 4;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_L);
}

static void m68k_op_movem_32_er_ix(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AY_IX_32();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = m68ki_read_32(ea);
            ea += 4;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_L);
}

static void m68k_op_movem_32_er_aw(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AW_32();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = m68ki_read_32(ea);
            ea += 4;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_L);
}

static void m68k_op_movem_32_er_al(void)
{
    uint i = 0;
    uint register_list = OPER_I_16();
    uint ea = EA_AL_32();
    uint count = 0;

    for (; i < 16; i++) {
        if (register_list & (1 << i)) {
            REG_DA[i] = m68ki_read_32(ea);
            ea += 4;
            count++;
        }
    }

    USE_CYCLES(count << CYC_MOVEM_L);
}

static void m68k_op_movep_16_re(void)
{
    uint ea = EA_AY_DI_16();
    uint src = DX;

    m68ki_write_8(ea, MASK_OUT_ABOVE_8(src >> 8));
    m68ki_write_8(ea += 2, MASK_OUT_ABOVE_8(src));
}

static void m68k_op_movep_32_re(void)
{
    uint ea = EA_AY_DI_32();
    uint src = DX;

    m68ki_write_8(ea, MASK_OUT_ABOVE_8(src >> 24));
    m68ki_write_8(ea += 2, MASK_OUT_ABOVE_8(src >> 16));
    m68ki_write_8(ea += 2, MASK_OUT_ABOVE_8(src >> 8));
    m68ki_write_8(ea += 2, MASK_OUT_ABOVE_8(src));
}

static void m68k_op_movep_16_er(void)
{
    uint ea = EA_AY_DI_16();
    uint* r_dst = &DX;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | ((m68ki_read_8(ea) << 8) + m68ki_read_8(ea + 2));
}

static void m68k_op_movep_32_er(void)
{
    uint ea = EA_AY_DI_32();

    DX = (m68ki_read_8(ea) << 24) + (m68ki_read_8(ea + 2) << 16) + (m68ki_read_8(ea + 4) << 8) + m68ki_read_8(ea + 6);
}

static void m68k_op_moves_8_ai(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_AI_8();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_8_fc(ea, REG_DFC, MASK_OUT_ABOVE_8(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_8(m68ki_read_8_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_8(REG_D[(word2 >> 12) & 7]) | m68ki_read_8_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_8_pi(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_PI_8();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_8_fc(ea, REG_DFC, MASK_OUT_ABOVE_8(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_8(m68ki_read_8_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_8(REG_D[(word2 >> 12) & 7]) | m68ki_read_8_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_8_pi7(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_A7_PI_8();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_8_fc(ea, REG_DFC, MASK_OUT_ABOVE_8(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_8(m68ki_read_8_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_8(REG_D[(word2 >> 12) & 7]) | m68ki_read_8_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_8_pd(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_PD_8();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_8_fc(ea, REG_DFC, MASK_OUT_ABOVE_8(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_8(m68ki_read_8_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_8(REG_D[(word2 >> 12) & 7]) | m68ki_read_8_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_8_pd7(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_A7_PD_8();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_8_fc(ea, REG_DFC, MASK_OUT_ABOVE_8(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_8(m68ki_read_8_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_8(REG_D[(word2 >> 12) & 7]) | m68ki_read_8_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_8_di(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_DI_8();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_8_fc(ea, REG_DFC, MASK_OUT_ABOVE_8(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_8(m68ki_read_8_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_8(REG_D[(word2 >> 12) & 7]) | m68ki_read_8_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_8_ix(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_IX_8();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_8_fc(ea, REG_DFC, MASK_OUT_ABOVE_8(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_8(m68ki_read_8_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_8(REG_D[(word2 >> 12) & 7]) | m68ki_read_8_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_8_aw(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AW_8();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_8_fc(ea, REG_DFC, MASK_OUT_ABOVE_8(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_8(m68ki_read_8_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_8(REG_D[(word2 >> 12) & 7]) | m68ki_read_8_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_8_al(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AL_8();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_8_fc(ea, REG_DFC, MASK_OUT_ABOVE_8(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_8(m68ki_read_8_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_8(REG_D[(word2 >> 12) & 7]) | m68ki_read_8_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_16_ai(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_AI_16();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_16_fc(ea, REG_DFC, MASK_OUT_ABOVE_16(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_16(m68ki_read_16_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_16(REG_D[(word2 >> 12) & 7]) | m68ki_read_16_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_16_pi(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_PI_16();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_16_fc(ea, REG_DFC, MASK_OUT_ABOVE_16(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_16(m68ki_read_16_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_16(REG_D[(word2 >> 12) & 7]) | m68ki_read_16_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_16_pd(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_PD_16();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_16_fc(ea, REG_DFC, MASK_OUT_ABOVE_16(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_16(m68ki_read_16_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_16(REG_D[(word2 >> 12) & 7]) | m68ki_read_16_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_16_di(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_DI_16();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_16_fc(ea, REG_DFC, MASK_OUT_ABOVE_16(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_16(m68ki_read_16_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_16(REG_D[(word2 >> 12) & 7]) | m68ki_read_16_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_16_ix(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_IX_16();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_16_fc(ea, REG_DFC, MASK_OUT_ABOVE_16(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_16(m68ki_read_16_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_16(REG_D[(word2 >> 12) & 7]) | m68ki_read_16_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_16_aw(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AW_16();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_16_fc(ea, REG_DFC, MASK_OUT_ABOVE_16(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_16(m68ki_read_16_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_16(REG_D[(word2 >> 12) & 7]) | m68ki_read_16_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_16_al(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AL_16();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_16_fc(ea, REG_DFC, MASK_OUT_ABOVE_16(REG_DA[(word2 >> 12) & 15]));
                return;
            }
            if (BIT_F(word2)) /* Memory to address register */
            {
                REG_A[(word2 >> 12) & 7] = MAKE_INT_16(m68ki_read_16_fc(ea, REG_SFC));
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to data register */
            REG_D[(word2 >> 12) & 7] = MASK_OUT_BELOW_16(REG_D[(word2 >> 12) & 7]) | m68ki_read_16_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_32_ai(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_AI_32();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_32_fc(ea, REG_DFC, REG_DA[(word2 >> 12) & 15]);
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to register */
            REG_DA[(word2 >> 12) & 15] = m68ki_read_32_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_32_pi(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_PI_32();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_32_fc(ea, REG_DFC, REG_DA[(word2 >> 12) & 15]);
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to register */
            REG_DA[(word2 >> 12) & 15] = m68ki_read_32_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_32_pd(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_PD_32();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_32_fc(ea, REG_DFC, REG_DA[(word2 >> 12) & 15]);
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to register */
            REG_DA[(word2 >> 12) & 15] = m68ki_read_32_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_32_di(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_DI_32();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_32_fc(ea, REG_DFC, REG_DA[(word2 >> 12) & 15]);
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to register */
            REG_DA[(word2 >> 12) & 15] = m68ki_read_32_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_32_ix(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AY_IX_32();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_32_fc(ea, REG_DFC, REG_DA[(word2 >> 12) & 15]);
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to register */
            REG_DA[(word2 >> 12) & 15] = m68ki_read_32_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_32_aw(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AW_32();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_32_fc(ea, REG_DFC, REG_DA[(word2 >> 12) & 15]);
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to register */
            REG_DA[(word2 >> 12) & 15] = m68ki_read_32_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moves_32_al(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        if (FLAG_S) {
            uint word2 = OPER_I_16();
            uint ea = EA_AL_32();

            m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
            if (BIT_B(word2)) /* Register to memory */
            {
                m68ki_write_32_fc(ea, REG_DFC, REG_DA[(word2 >> 12) & 15]);
                if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                    USE_CYCLES(2);
                }
                return;
            }
            /* Memory to register */
            REG_DA[(word2 >> 12) & 15] = m68ki_read_32_fc(ea, REG_SFC);
            if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
                USE_CYCLES(2);
            }
            return;
        }
        m68ki_exception_privilege_violation();
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_moveq_32(void)
{
    uint res = DX = MAKE_INT_8(MASK_OUT_ABOVE_8(REG_IR));

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_move16_32(void)
{
    uint16 w2 = OPER_I_16();
    int ax = REG_IR & 7;
    int ay = (w2 >> 12) & 7;

    m68ki_write_32(REG_A[ay], m68ki_read_32(REG_A[ax]));
    m68ki_write_32(REG_A[ay] + 4, m68ki_read_32(REG_A[ax] + 4));
    m68ki_write_32(REG_A[ay] + 8, m68ki_read_32(REG_A[ax] + 8));
    m68ki_write_32(REG_A[ay] + 12, m68ki_read_32(REG_A[ax] + 12));

    REG_A[ax] += 16;
    REG_A[ay] += 16;
}

static void m68k_op_muls_16_d(void)
{
    uint* r_dst = &DX;
    uint x = MAKE_INT_16(DY);
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x, f = 0; y; y >>= 1) {
            if ((y & 1) != f) {
                c += 2;
                f = 1 - f;
            }
        }
        USE_CYCLES(c);
    }

    uint res = MASK_OUT_ABOVE_32(x * MAKE_INT_16(MASK_OUT_ABOVE_16(*r_dst)));

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_muls_16_ai(void)
{
    uint* r_dst = &DX;
    uint x = MAKE_INT_16(OPER_AY_AI_16());
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x, f = 0; y; y >>= 1) {
            if ((y & 1) != f) {
                c += 2;
                f = 1 - f;
            }
        }
        USE_CYCLES(c);
    }
    uint res = MASK_OUT_ABOVE_32(x * MAKE_INT_16(MASK_OUT_ABOVE_16(*r_dst)));

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_muls_16_pi(void)
{
    uint* r_dst = &DX;
    uint x = MAKE_INT_16(OPER_AY_PI_16());
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x, f = 0; y; y >>= 1) {
            if ((y & 1) != f) {
                c += 2;
                f = 1 - f;
            }
        }
        USE_CYCLES(c);
    }
    uint res = MASK_OUT_ABOVE_32(x * MAKE_INT_16(MASK_OUT_ABOVE_16(*r_dst)));

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_muls_16_pd(void)
{
    uint* r_dst = &DX;
    uint x = MAKE_INT_16(OPER_AY_PD_16());
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x, f = 0; y; y >>= 1) {
            if ((y & 1) != f) {
                c += 2;
                f = 1 - f;
            }
        }
        USE_CYCLES(c);
    }
    uint res = MASK_OUT_ABOVE_32(x * MAKE_INT_16(MASK_OUT_ABOVE_16(*r_dst)));

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_muls_16_di(void)
{
    uint* r_dst = &DX;
    uint x = MAKE_INT_16(OPER_AY_DI_16());
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x, f = 0; y; y >>= 1) {
            if ((y & 1) != f) {
                c += 2;
                f = 1 - f;
            }
        }
        USE_CYCLES(c);
    }
    uint res = MASK_OUT_ABOVE_32(x * MAKE_INT_16(MASK_OUT_ABOVE_16(*r_dst)));

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_muls_16_ix(void)
{
    uint* r_dst = &DX;
    uint x = MAKE_INT_16(OPER_AY_IX_16());
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x, f = 0; y; y >>= 1) {
            if ((y & 1) != f) {
                c += 2;
                f = 1 - f;
            }
        }
        USE_CYCLES(c);
    }
    uint res = MASK_OUT_ABOVE_32(x * MAKE_INT_16(MASK_OUT_ABOVE_16(*r_dst)));

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_muls_16_aw(void)
{
    uint* r_dst = &DX;
    uint x = MAKE_INT_16(OPER_AW_16());
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x, f = 0; y; y >>= 1) {
            if ((y & 1) != f) {
                c += 2;
                f = 1 - f;
            }
        }
        USE_CYCLES(c);
    }
    uint res = MASK_OUT_ABOVE_32(x * MAKE_INT_16(MASK_OUT_ABOVE_16(*r_dst)));

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_muls_16_al(void)
{
    uint* r_dst = &DX;
    uint x = MAKE_INT_16(OPER_AL_16());
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x, f = 0; y; y >>= 1) {
            if ((y & 1) != f) {
                c += 2;
                f = 1 - f;
            }
        }
        USE_CYCLES(c);
    }
    uint res = MASK_OUT_ABOVE_32(x * MAKE_INT_16(MASK_OUT_ABOVE_16(*r_dst)));

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_muls_16_pcdi(void)
{
    uint* r_dst = &DX;
    uint x = MAKE_INT_16(OPER_PCDI_16());
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x, f = 0; y; y >>= 1) {
            if ((y & 1) != f) {
                c += 2;
                f = 1 - f;
            }
        }
        USE_CYCLES(c);
    }
    uint res = MASK_OUT_ABOVE_32(x * MAKE_INT_16(MASK_OUT_ABOVE_16(*r_dst)));

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_muls_16_pcix(void)
{
    uint* r_dst = &DX;
    uint x = MAKE_INT_16(OPER_PCIX_16());
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x, f = 0; y; y >>= 1) {
            if ((y & 1) != f) {
                c += 2;
                f = 1 - f;
            }
        }
        USE_CYCLES(c);
    }
    uint res = MASK_OUT_ABOVE_32(x * MAKE_INT_16(MASK_OUT_ABOVE_16(*r_dst)));

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_muls_16_i(void)
{
    uint* r_dst = &DX;
    uint x = MAKE_INT_16(OPER_I_16());
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x, f = 0; y; y >>= 1) {
            if ((y & 1) != f) {
                c += 2;
                f = 1 - f;
            }
        }
        USE_CYCLES(c);
    }
    uint res = MASK_OUT_ABOVE_32(x * MAKE_INT_16(MASK_OUT_ABOVE_16(*r_dst)));

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_mulu_16_d(void)
{
    uint* r_dst = &DX;
    uint x = MASK_OUT_ABOVE_16(DY);
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x; y; y >>= 1) {
            if ((y & 1)) {
                c += 2;
            }
        }
        USE_CYCLES(c);
    }
    uint res = x * MASK_OUT_ABOVE_16(*r_dst);

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_mulu_16_ai(void)
{
    uint* r_dst = &DX;
    uint x = OPER_AY_AI_16();
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x; y; y >>= 1) {
            if ((y & 1)) {
                c += 2;
            }
        }
        USE_CYCLES(c);
    }

    uint res = x * MASK_OUT_ABOVE_16(*r_dst);

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_mulu_16_pi(void)
{
    uint* r_dst = &DX;
    uint x = OPER_AY_PI_16();
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x; y; y >>= 1) {
            if ((y & 1)) {
                c += 2;
            }
        }
        USE_CYCLES(c);
    }

    uint res = x * MASK_OUT_ABOVE_16(*r_dst);

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_mulu_16_pd(void)
{
    uint* r_dst = &DX;
    uint x = OPER_AY_PD_16();
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x; y; y >>= 1) {
            if ((y & 1)) {
                c += 2;
            }
        }
        USE_CYCLES(c);
    }

    uint res = x * MASK_OUT_ABOVE_16(*r_dst);

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_mulu_16_di(void)
{
    uint* r_dst = &DX;
    uint x = OPER_AY_DI_16();
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x; y; y >>= 1) {
            if ((y & 1)) {
                c += 2;
            }
        }
        USE_CYCLES(c);
    }

    uint res = x * MASK_OUT_ABOVE_16(*r_dst);

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_mulu_16_ix(void)
{
    uint* r_dst = &DX;
    uint x = OPER_AY_IX_16();
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x; y; y >>= 1) {
            if ((y & 1)) {
                c += 2;
            }
        }
        USE_CYCLES(c);
    }

    uint res = x * MASK_OUT_ABOVE_16(*r_dst);

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_mulu_16_aw(void)
{
    uint* r_dst = &DX;
    uint x = OPER_AW_16();
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x; y; y >>= 1) {
            if ((y & 1)) {
                c += 2;
            }
        }
        USE_CYCLES(c);
    }

    uint res = x * MASK_OUT_ABOVE_16(*r_dst);

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_mulu_16_al(void)
{
    uint* r_dst = &DX;
    uint x = OPER_AL_16();
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x; y; y >>= 1) {
            if ((y & 1)) {
                c += 2;
            }
        }
        USE_CYCLES(c);
    }

    uint res = x * MASK_OUT_ABOVE_16(*r_dst);

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_mulu_16_pcdi(void)
{
    uint* r_dst = &DX;
    uint x = OPER_PCDI_16();
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x; y; y >>= 1) {
            if ((y & 1)) {
                c += 2;
            }
        }
        USE_CYCLES(c);
    }

    uint res = x * MASK_OUT_ABOVE_16(*r_dst);

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_mulu_16_pcix(void)
{
    uint* r_dst = &DX;
    uint x = OPER_PCIX_16();
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x; y; y >>= 1) {
            if ((y & 1)) {
                c += 2;
            }
        }
        USE_CYCLES(c);
    }

    uint res = x * MASK_OUT_ABOVE_16(*r_dst);

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_mulu_16_i(void)
{
    uint* r_dst = &DX;
    uint x = OPER_I_16();
    if (CPU_TYPE_IS_010_LESS(CPU_TYPE)) {
        uint c = 0;
        for (uint y = x; y; y >>= 1) {
            if ((y & 1)) {
                c += 2;
            }
        }
        USE_CYCLES(c);
    }

    uint res = x * MASK_OUT_ABOVE_16(*r_dst);

    *r_dst = res;

    FLAG_Z = res;
    FLAG_N = NFLAG_32(res);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_mull_32_d(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 src = DY;
        uint64 dst = REG_D[(word2 >> 12) & 7];
        uint64 res;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            res = (sint64)((sint32)src) * (sint64)((sint32)dst);
            if (!BIT_A(word2)) {
                FLAG_Z = MASK_OUT_ABOVE_32(res);
                FLAG_N = NFLAG_32(res);
                FLAG_V = ((sint64)res != (sint32)res) << 7;
                REG_D[(word2 >> 12) & 7] = FLAG_Z;
                return;
            }
            FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
            FLAG_N = NFLAG_64(res);
            FLAG_V = VFLAG_CLEAR;
            REG_D[word2 & 7] = (res >> 32);
            REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
            return;
        }

        res = src * dst;
        if (!BIT_A(word2)) {
            FLAG_Z = MASK_OUT_ABOVE_32(res);
            FLAG_N = NFLAG_32(res);
            FLAG_V = (res > 0xffffffff) << 7;
            REG_D[(word2 >> 12) & 7] = FLAG_Z;
            return;
        }
        FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
        FLAG_N = NFLAG_64(res);
        FLAG_V = VFLAG_CLEAR;
        REG_D[word2 & 7] = (res >> 32);
        REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint src = DY;
        uint dst = REG_D[(word2 >> 12) & 7];
        uint neg = GET_MSB_32(src ^ dst);
        uint src1;
        uint src2;
        uint dst1;
        uint dst2;
        uint r1;
        uint r2;
        uint r3;
        uint r4;
        uint lo;
        uint hi;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            if (GET_MSB_32(src)) {
                src = (uint)MASK_OUT_ABOVE_32(-(sint)src);
            }
            if (GET_MSB_32(dst)) {
                dst = (uint)MASK_OUT_ABOVE_32(-(sint)dst);
            }
        }

        src1 = MASK_OUT_ABOVE_16(src);
        src2 = src >> 16;
        dst1 = MASK_OUT_ABOVE_16(dst);
        dst2 = dst >> 16;

        r1 = src1 * dst1;
        r2 = src1 * dst2;
        r3 = src2 * dst1;
        r4 = src2 * dst2;

        lo = r1 + (MASK_OUT_ABOVE_16(r2) << 16) + (MASK_OUT_ABOVE_16(r3) << 16);
        hi = r4 + (r2 >> 16) + (r3 >> 16) + (((r1 >> 16) + MASK_OUT_ABOVE_16(r2) + MASK_OUT_ABOVE_16(r3)) >> 16);

        if (BIT_B(word2) && neg) {
            hi = (uint)MASK_OUT_ABOVE_32((-(sint)hi) - (lo != 0));
            lo = (uint)MASK_OUT_ABOVE_32(-(sint)lo);
        }

        if (BIT_A(word2)) {
            REG_D[word2 & 7] = hi;
            REG_D[(word2 >> 12) & 7] = lo;
            FLAG_N = NFLAG_32(hi);
            FLAG_Z = hi | lo;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        REG_D[(word2 >> 12) & 7] = lo;
        FLAG_N = NFLAG_32(lo);
        FLAG_Z = lo;
        if (BIT_B(word2)) {
            FLAG_V = (!((GET_MSB_32(lo) && hi == 0xffffffff) || (!GET_MSB_32(lo) && !hi))) << 7;
        } else {
            FLAG_V = (hi != 0) << 7;
        }
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_mull_32_ai(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 src = OPER_AY_AI_32();
        uint64 dst = REG_D[(word2 >> 12) & 7];
        uint64 res;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            res = (sint64)((sint32)src) * (sint64)((sint32)dst);
            if (!BIT_A(word2)) {
                FLAG_Z = MASK_OUT_ABOVE_32(res);
                FLAG_N = NFLAG_32(res);
                FLAG_V = ((sint64)res != (sint32)res) << 7;
                REG_D[(word2 >> 12) & 7] = FLAG_Z;
                return;
            }
            FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
            FLAG_N = NFLAG_64(res);
            FLAG_V = VFLAG_CLEAR;
            REG_D[word2 & 7] = (res >> 32);
            REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
            return;
        }

        res = src * dst;
        if (!BIT_A(word2)) {
            FLAG_Z = MASK_OUT_ABOVE_32(res);
            FLAG_N = NFLAG_32(res);
            FLAG_V = (res > 0xffffffff) << 7;
            REG_D[(word2 >> 12) & 7] = FLAG_Z;
            return;
        }
        FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
        FLAG_N = NFLAG_64(res);
        FLAG_V = VFLAG_CLEAR;
        REG_D[word2 & 7] = (res >> 32);
        REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint src = OPER_AY_AI_32();
        uint dst = REG_D[(word2 >> 12) & 7];
        uint neg = GET_MSB_32(src ^ dst);
        uint src1;
        uint src2;
        uint dst1;
        uint dst2;
        uint r1;
        uint r2;
        uint r3;
        uint r4;
        uint lo;
        uint hi;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            if (GET_MSB_32(src)) {
                src = (uint)MASK_OUT_ABOVE_32(-(sint)src);
            }
            if (GET_MSB_32(dst)) {
                dst = (uint)MASK_OUT_ABOVE_32(-(sint)dst);
            }
        }

        src1 = MASK_OUT_ABOVE_16(src);
        src2 = src >> 16;
        dst1 = MASK_OUT_ABOVE_16(dst);
        dst2 = dst >> 16;

        r1 = src1 * dst1;
        r2 = src1 * dst2;
        r3 = src2 * dst1;
        r4 = src2 * dst2;

        lo = r1 + (MASK_OUT_ABOVE_16(r2) << 16) + (MASK_OUT_ABOVE_16(r3) << 16);
        hi = r4 + (r2 >> 16) + (r3 >> 16) + (((r1 >> 16) + MASK_OUT_ABOVE_16(r2) + MASK_OUT_ABOVE_16(r3)) >> 16);

        if (BIT_B(word2) && neg) {
            hi = (uint)MASK_OUT_ABOVE_32((-(sint)hi) - (lo != 0));
            lo = (uint)MASK_OUT_ABOVE_32(-(sint)lo);
        }

        if (BIT_A(word2)) {
            REG_D[word2 & 7] = hi;
            REG_D[(word2 >> 12) & 7] = lo;
            FLAG_N = NFLAG_32(hi);
            FLAG_Z = hi | lo;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        REG_D[(word2 >> 12) & 7] = lo;
        FLAG_N = NFLAG_32(lo);
        FLAG_Z = lo;
        if (BIT_B(word2)) {
            FLAG_V = (!((GET_MSB_32(lo) && hi == 0xffffffff) || (!GET_MSB_32(lo) && !hi))) << 7;
        } else {
            FLAG_V = (hi != 0) << 7;
        }
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_mull_32_pi(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 src = OPER_AY_PI_32();
        uint64 dst = REG_D[(word2 >> 12) & 7];
        uint64 res;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            res = (sint64)((sint32)src) * (sint64)((sint32)dst);
            if (!BIT_A(word2)) {
                FLAG_Z = MASK_OUT_ABOVE_32(res);
                FLAG_N = NFLAG_32(res);
                FLAG_V = ((sint64)res != (sint32)res) << 7;
                REG_D[(word2 >> 12) & 7] = FLAG_Z;
                return;
            }
            FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
            FLAG_N = NFLAG_64(res);
            FLAG_V = VFLAG_CLEAR;
            REG_D[word2 & 7] = (res >> 32);
            REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
            return;
        }

        res = src * dst;
        if (!BIT_A(word2)) {
            FLAG_Z = MASK_OUT_ABOVE_32(res);
            FLAG_N = NFLAG_32(res);
            FLAG_V = (res > 0xffffffff) << 7;
            REG_D[(word2 >> 12) & 7] = FLAG_Z;
            return;
        }
        FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
        FLAG_N = NFLAG_64(res);
        FLAG_V = VFLAG_CLEAR;
        REG_D[word2 & 7] = (res >> 32);
        REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint src = OPER_AY_PI_32();
        uint dst = REG_D[(word2 >> 12) & 7];
        uint neg = GET_MSB_32(src ^ dst);
        uint src1;
        uint src2;
        uint dst1;
        uint dst2;
        uint r1;
        uint r2;
        uint r3;
        uint r4;
        uint lo;
        uint hi;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            if (GET_MSB_32(src)) {
                src = (uint)MASK_OUT_ABOVE_32(-(sint)src);
            }
            if (GET_MSB_32(dst)) {
                dst = (uint)MASK_OUT_ABOVE_32(-(sint)dst);
            }
        }

        src1 = MASK_OUT_ABOVE_16(src);
        src2 = src >> 16;
        dst1 = MASK_OUT_ABOVE_16(dst);
        dst2 = dst >> 16;

        r1 = src1 * dst1;
        r2 = src1 * dst2;
        r3 = src2 * dst1;
        r4 = src2 * dst2;

        lo = r1 + (MASK_OUT_ABOVE_16(r2) << 16) + (MASK_OUT_ABOVE_16(r3) << 16);
        hi = r4 + (r2 >> 16) + (r3 >> 16) + (((r1 >> 16) + MASK_OUT_ABOVE_16(r2) + MASK_OUT_ABOVE_16(r3)) >> 16);

        if (BIT_B(word2) && neg) {
            hi = (uint)MASK_OUT_ABOVE_32((-(sint)hi) - (lo != 0));
            lo = (uint)MASK_OUT_ABOVE_32(-(sint)lo);
        }

        if (BIT_A(word2)) {
            REG_D[word2 & 7] = hi;
            REG_D[(word2 >> 12) & 7] = lo;
            FLAG_N = NFLAG_32(hi);
            FLAG_Z = hi | lo;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        REG_D[(word2 >> 12) & 7] = lo;
        FLAG_N = NFLAG_32(lo);
        FLAG_Z = lo;
        if (BIT_B(word2)) {
            FLAG_V = (!((GET_MSB_32(lo) && hi == 0xffffffff) || (!GET_MSB_32(lo) && !hi))) << 7;
        } else {
            FLAG_V = (hi != 0) << 7;
        }
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_mull_32_pd(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 src = OPER_AY_PD_32();
        uint64 dst = REG_D[(word2 >> 12) & 7];
        uint64 res;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            res = (sint64)((sint32)src) * (sint64)((sint32)dst);
            if (!BIT_A(word2)) {
                FLAG_Z = MASK_OUT_ABOVE_32(res);
                FLAG_N = NFLAG_32(res);
                FLAG_V = ((sint64)res != (sint32)res) << 7;
                REG_D[(word2 >> 12) & 7] = FLAG_Z;
                return;
            }
            FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
            FLAG_N = NFLAG_64(res);
            FLAG_V = VFLAG_CLEAR;
            REG_D[word2 & 7] = (res >> 32);
            REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
            return;
        }

        res = src * dst;
        if (!BIT_A(word2)) {
            FLAG_Z = MASK_OUT_ABOVE_32(res);
            FLAG_N = NFLAG_32(res);
            FLAG_V = (res > 0xffffffff) << 7;
            REG_D[(word2 >> 12) & 7] = FLAG_Z;
            return;
        }
        FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
        FLAG_N = NFLAG_64(res);
        FLAG_V = VFLAG_CLEAR;
        REG_D[word2 & 7] = (res >> 32);
        REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint src = OPER_AY_PD_32();
        uint dst = REG_D[(word2 >> 12) & 7];
        uint neg = GET_MSB_32(src ^ dst);
        uint src1;
        uint src2;
        uint dst1;
        uint dst2;
        uint r1;
        uint r2;
        uint r3;
        uint r4;
        uint lo;
        uint hi;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            if (GET_MSB_32(src)) {
                src = (uint)MASK_OUT_ABOVE_32(-(sint)src);
            }
            if (GET_MSB_32(dst)) {
                dst = (uint)MASK_OUT_ABOVE_32(-(sint)dst);
            }
        }

        src1 = MASK_OUT_ABOVE_16(src);
        src2 = src >> 16;
        dst1 = MASK_OUT_ABOVE_16(dst);
        dst2 = dst >> 16;

        r1 = src1 * dst1;
        r2 = src1 * dst2;
        r3 = src2 * dst1;
        r4 = src2 * dst2;

        lo = r1 + (MASK_OUT_ABOVE_16(r2) << 16) + (MASK_OUT_ABOVE_16(r3) << 16);
        hi = r4 + (r2 >> 16) + (r3 >> 16) + (((r1 >> 16) + MASK_OUT_ABOVE_16(r2) + MASK_OUT_ABOVE_16(r3)) >> 16);

        if (BIT_B(word2) && neg) {
            hi = (uint)MASK_OUT_ABOVE_32((-(sint)hi) - (lo != 0));
            lo = (uint)MASK_OUT_ABOVE_32(-(sint)lo);
        }

        if (BIT_A(word2)) {
            REG_D[word2 & 7] = hi;
            REG_D[(word2 >> 12) & 7] = lo;
            FLAG_N = NFLAG_32(hi);
            FLAG_Z = hi | lo;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        REG_D[(word2 >> 12) & 7] = lo;
        FLAG_N = NFLAG_32(lo);
        FLAG_Z = lo;
        if (BIT_B(word2)) {
            FLAG_V = (!((GET_MSB_32(lo) && hi == 0xffffffff) || (!GET_MSB_32(lo) && !hi))) << 7;
        } else {
            FLAG_V = (hi != 0) << 7;
        }
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_mull_32_di(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 src = OPER_AY_DI_32();
        uint64 dst = REG_D[(word2 >> 12) & 7];
        uint64 res;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            res = (sint64)((sint32)src) * (sint64)((sint32)dst);
            if (!BIT_A(word2)) {
                FLAG_Z = MASK_OUT_ABOVE_32(res);
                FLAG_N = NFLAG_32(res);
                FLAG_V = ((sint64)res != (sint32)res) << 7;
                REG_D[(word2 >> 12) & 7] = FLAG_Z;
                return;
            }
            FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
            FLAG_N = NFLAG_64(res);
            FLAG_V = VFLAG_CLEAR;
            REG_D[word2 & 7] = (res >> 32);
            REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
            return;
        }

        res = src * dst;
        if (!BIT_A(word2)) {
            FLAG_Z = MASK_OUT_ABOVE_32(res);
            FLAG_N = NFLAG_32(res);
            FLAG_V = (res > 0xffffffff) << 7;
            REG_D[(word2 >> 12) & 7] = FLAG_Z;
            return;
        }
        FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
        FLAG_N = NFLAG_64(res);
        FLAG_V = VFLAG_CLEAR;
        REG_D[word2 & 7] = (res >> 32);
        REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint src = OPER_AY_DI_32();
        uint dst = REG_D[(word2 >> 12) & 7];
        uint neg = GET_MSB_32(src ^ dst);
        uint src1;
        uint src2;
        uint dst1;
        uint dst2;
        uint r1;
        uint r2;
        uint r3;
        uint r4;
        uint lo;
        uint hi;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            if (GET_MSB_32(src)) {
                src = (uint)MASK_OUT_ABOVE_32(-(sint)src);
            }
            if (GET_MSB_32(dst)) {
                dst = (uint)MASK_OUT_ABOVE_32(-(sint)dst);
            }
        }

        src1 = MASK_OUT_ABOVE_16(src);
        src2 = src >> 16;
        dst1 = MASK_OUT_ABOVE_16(dst);
        dst2 = dst >> 16;

        r1 = src1 * dst1;
        r2 = src1 * dst2;
        r3 = src2 * dst1;
        r4 = src2 * dst2;

        lo = r1 + (MASK_OUT_ABOVE_16(r2) << 16) + (MASK_OUT_ABOVE_16(r3) << 16);
        hi = r4 + (r2 >> 16) + (r3 >> 16) + (((r1 >> 16) + MASK_OUT_ABOVE_16(r2) + MASK_OUT_ABOVE_16(r3)) >> 16);

        if (BIT_B(word2) && neg) {
            hi = (uint)MASK_OUT_ABOVE_32((-(sint)hi) - (lo != 0));
            lo = (uint)MASK_OUT_ABOVE_32(-(sint)lo);
        }

        if (BIT_A(word2)) {
            REG_D[word2 & 7] = hi;
            REG_D[(word2 >> 12) & 7] = lo;
            FLAG_N = NFLAG_32(hi);
            FLAG_Z = hi | lo;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        REG_D[(word2 >> 12) & 7] = lo;
        FLAG_N = NFLAG_32(lo);
        FLAG_Z = lo;
        if (BIT_B(word2)) {
            FLAG_V = (!((GET_MSB_32(lo) && hi == 0xffffffff) || (!GET_MSB_32(lo) && !hi))) << 7;
        } else {
            FLAG_V = (hi != 0) << 7;
        }
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_mull_32_ix(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 src = OPER_AY_IX_32();
        uint64 dst = REG_D[(word2 >> 12) & 7];
        uint64 res;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            res = (sint64)((sint32)src) * (sint64)((sint32)dst);
            if (!BIT_A(word2)) {
                FLAG_Z = MASK_OUT_ABOVE_32(res);
                FLAG_N = NFLAG_32(res);
                FLAG_V = ((sint64)res != (sint32)res) << 7;
                REG_D[(word2 >> 12) & 7] = FLAG_Z;
                return;
            }
            FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
            FLAG_N = NFLAG_64(res);
            FLAG_V = VFLAG_CLEAR;
            REG_D[word2 & 7] = (res >> 32);
            REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
            return;
        }

        res = src * dst;
        if (!BIT_A(word2)) {
            FLAG_Z = MASK_OUT_ABOVE_32(res);
            FLAG_N = NFLAG_32(res);
            FLAG_V = (res > 0xffffffff) << 7;
            REG_D[(word2 >> 12) & 7] = FLAG_Z;
            return;
        }
        FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
        FLAG_N = NFLAG_64(res);
        FLAG_V = VFLAG_CLEAR;
        REG_D[word2 & 7] = (res >> 32);
        REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint src = OPER_AY_IX_32();
        uint dst = REG_D[(word2 >> 12) & 7];
        uint neg = GET_MSB_32(src ^ dst);
        uint src1;
        uint src2;
        uint dst1;
        uint dst2;
        uint r1;
        uint r2;
        uint r3;
        uint r4;
        uint lo;
        uint hi;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            if (GET_MSB_32(src)) {
                src = (uint)MASK_OUT_ABOVE_32(-(sint)src);
            }
            if (GET_MSB_32(dst)) {
                dst = (uint)MASK_OUT_ABOVE_32(-(sint)dst);
            }
        }

        src1 = MASK_OUT_ABOVE_16(src);
        src2 = src >> 16;
        dst1 = MASK_OUT_ABOVE_16(dst);
        dst2 = dst >> 16;

        r1 = src1 * dst1;
        r2 = src1 * dst2;
        r3 = src2 * dst1;
        r4 = src2 * dst2;

        lo = r1 + (MASK_OUT_ABOVE_16(r2) << 16) + (MASK_OUT_ABOVE_16(r3) << 16);
        hi = r4 + (r2 >> 16) + (r3 >> 16) + (((r1 >> 16) + MASK_OUT_ABOVE_16(r2) + MASK_OUT_ABOVE_16(r3)) >> 16);

        if (BIT_B(word2) && neg) {
            hi = (uint)MASK_OUT_ABOVE_32((-(sint)hi) - (lo != 0));
            lo = (uint)MASK_OUT_ABOVE_32(-(sint)lo);
        }

        if (BIT_A(word2)) {
            REG_D[word2 & 7] = hi;
            REG_D[(word2 >> 12) & 7] = lo;
            FLAG_N = NFLAG_32(hi);
            FLAG_Z = hi | lo;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        REG_D[(word2 >> 12) & 7] = lo;
        FLAG_N = NFLAG_32(lo);
        FLAG_Z = lo;
        if (BIT_B(word2)) {
            FLAG_V = (!((GET_MSB_32(lo) && hi == 0xffffffff) || (!GET_MSB_32(lo) && !hi))) << 7;
        } else {
            FLAG_V = (hi != 0) << 7;
        }
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_mull_32_aw(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 src = OPER_AW_32();
        uint64 dst = REG_D[(word2 >> 12) & 7];
        uint64 res;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            res = (sint64)((sint32)src) * (sint64)((sint32)dst);
            if (!BIT_A(word2)) {
                FLAG_Z = MASK_OUT_ABOVE_32(res);
                FLAG_N = NFLAG_32(res);
                FLAG_V = ((sint64)res != (sint32)res) << 7;
                REG_D[(word2 >> 12) & 7] = FLAG_Z;
                return;
            }
            FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
            FLAG_N = NFLAG_64(res);
            FLAG_V = VFLAG_CLEAR;
            REG_D[word2 & 7] = (res >> 32);
            REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
            return;
        }

        res = src * dst;
        if (!BIT_A(word2)) {
            FLAG_Z = MASK_OUT_ABOVE_32(res);
            FLAG_N = NFLAG_32(res);
            FLAG_V = (res > 0xffffffff) << 7;
            REG_D[(word2 >> 12) & 7] = FLAG_Z;
            return;
        }
        FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
        FLAG_N = NFLAG_64(res);
        FLAG_V = VFLAG_CLEAR;
        REG_D[word2 & 7] = (res >> 32);
        REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint src = OPER_AW_32();
        uint dst = REG_D[(word2 >> 12) & 7];
        uint neg = GET_MSB_32(src ^ dst);
        uint src1;
        uint src2;
        uint dst1;
        uint dst2;
        uint r1;
        uint r2;
        uint r3;
        uint r4;
        uint lo;
        uint hi;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            if (GET_MSB_32(src)) {
                src = (uint)MASK_OUT_ABOVE_32(-(sint)src);
            }
            if (GET_MSB_32(dst)) {
                dst = (uint)MASK_OUT_ABOVE_32(-(sint)dst);
            }
        }

        src1 = MASK_OUT_ABOVE_16(src);
        src2 = src >> 16;
        dst1 = MASK_OUT_ABOVE_16(dst);
        dst2 = dst >> 16;

        r1 = src1 * dst1;
        r2 = src1 * dst2;
        r3 = src2 * dst1;
        r4 = src2 * dst2;

        lo = r1 + (MASK_OUT_ABOVE_16(r2) << 16) + (MASK_OUT_ABOVE_16(r3) << 16);
        hi = r4 + (r2 >> 16) + (r3 >> 16) + (((r1 >> 16) + MASK_OUT_ABOVE_16(r2) + MASK_OUT_ABOVE_16(r3)) >> 16);

        if (BIT_B(word2) && neg) {
            hi = (uint)MASK_OUT_ABOVE_32((-(sint)hi) - (lo != 0));
            lo = (uint)MASK_OUT_ABOVE_32(-(sint)lo);
        }

        if (BIT_A(word2)) {
            REG_D[word2 & 7] = hi;
            REG_D[(word2 >> 12) & 7] = lo;
            FLAG_N = NFLAG_32(hi);
            FLAG_Z = hi | lo;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        REG_D[(word2 >> 12) & 7] = lo;
        FLAG_N = NFLAG_32(lo);
        FLAG_Z = lo;
        if (BIT_B(word2)) {
            FLAG_V = (!((GET_MSB_32(lo) && hi == 0xffffffff) || (!GET_MSB_32(lo) && !hi))) << 7;
        } else {
            FLAG_V = (hi != 0) << 7;
        }
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_mull_32_al(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 src = OPER_AL_32();
        uint64 dst = REG_D[(word2 >> 12) & 7];
        uint64 res;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            res = (sint64)((sint32)src) * (sint64)((sint32)dst);
            if (!BIT_A(word2)) {
                FLAG_Z = MASK_OUT_ABOVE_32(res);
                FLAG_N = NFLAG_32(res);
                FLAG_V = ((sint64)res != (sint32)res) << 7;
                REG_D[(word2 >> 12) & 7] = FLAG_Z;
                return;
            }
            FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
            FLAG_N = NFLAG_64(res);
            FLAG_V = VFLAG_CLEAR;
            REG_D[word2 & 7] = (res >> 32);
            REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
            return;
        }

        res = src * dst;
        if (!BIT_A(word2)) {
            FLAG_Z = MASK_OUT_ABOVE_32(res);
            FLAG_N = NFLAG_32(res);
            FLAG_V = (res > 0xffffffff) << 7;
            REG_D[(word2 >> 12) & 7] = FLAG_Z;
            return;
        }
        FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
        FLAG_N = NFLAG_64(res);
        FLAG_V = VFLAG_CLEAR;
        REG_D[word2 & 7] = (res >> 32);
        REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint src = OPER_AL_32();
        uint dst = REG_D[(word2 >> 12) & 7];
        uint neg = GET_MSB_32(src ^ dst);
        uint src1;
        uint src2;
        uint dst1;
        uint dst2;
        uint r1;
        uint r2;
        uint r3;
        uint r4;
        uint lo;
        uint hi;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            if (GET_MSB_32(src)) {
                src = (uint)MASK_OUT_ABOVE_32(-(sint)src);
            }
            if (GET_MSB_32(dst)) {
                dst = (uint)MASK_OUT_ABOVE_32(-(sint)dst);
            }
        }

        src1 = MASK_OUT_ABOVE_16(src);
        src2 = src >> 16;
        dst1 = MASK_OUT_ABOVE_16(dst);
        dst2 = dst >> 16;

        r1 = src1 * dst1;
        r2 = src1 * dst2;
        r3 = src2 * dst1;
        r4 = src2 * dst2;

        lo = r1 + (MASK_OUT_ABOVE_16(r2) << 16) + (MASK_OUT_ABOVE_16(r3) << 16);
        hi = r4 + (r2 >> 16) + (r3 >> 16) + (((r1 >> 16) + MASK_OUT_ABOVE_16(r2) + MASK_OUT_ABOVE_16(r3)) >> 16);

        if (BIT_B(word2) && neg) {
            hi = (uint)MASK_OUT_ABOVE_32((-(sint)hi) - (lo != 0));
            lo = (uint)MASK_OUT_ABOVE_32(-(sint)lo);
        }

        if (BIT_A(word2)) {
            REG_D[word2 & 7] = hi;
            REG_D[(word2 >> 12) & 7] = lo;
            FLAG_N = NFLAG_32(hi);
            FLAG_Z = hi | lo;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        REG_D[(word2 >> 12) & 7] = lo;
        FLAG_N = NFLAG_32(lo);
        FLAG_Z = lo;
        if (BIT_B(word2)) {
            FLAG_V = (!((GET_MSB_32(lo) && hi == 0xffffffff) || (!GET_MSB_32(lo) && !hi))) << 7;
        } else {
            FLAG_V = (hi != 0) << 7;
        }
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_mull_32_pcdi(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 src = OPER_PCDI_32();
        uint64 dst = REG_D[(word2 >> 12) & 7];
        uint64 res;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            res = (sint64)((sint32)src) * (sint64)((sint32)dst);
            if (!BIT_A(word2)) {
                FLAG_Z = MASK_OUT_ABOVE_32(res);
                FLAG_N = NFLAG_32(res);
                FLAG_V = ((sint64)res != (sint32)res) << 7;
                REG_D[(word2 >> 12) & 7] = FLAG_Z;
                return;
            }
            FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
            FLAG_N = NFLAG_64(res);
            FLAG_V = VFLAG_CLEAR;
            REG_D[word2 & 7] = (res >> 32);
            REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
            return;
        }

        res = src * dst;
        if (!BIT_A(word2)) {
            FLAG_Z = MASK_OUT_ABOVE_32(res);
            FLAG_N = NFLAG_32(res);
            FLAG_V = (res > 0xffffffff) << 7;
            REG_D[(word2 >> 12) & 7] = FLAG_Z;
            return;
        }
        FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
        FLAG_N = NFLAG_64(res);
        FLAG_V = VFLAG_CLEAR;
        REG_D[word2 & 7] = (res >> 32);
        REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint src = OPER_PCDI_32();
        uint dst = REG_D[(word2 >> 12) & 7];
        uint neg = GET_MSB_32(src ^ dst);
        uint src1;
        uint src2;
        uint dst1;
        uint dst2;
        uint r1;
        uint r2;
        uint r3;
        uint r4;
        uint lo;
        uint hi;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            if (GET_MSB_32(src)) {
                src = (uint)MASK_OUT_ABOVE_32(-(sint)src);
            }
            if (GET_MSB_32(dst)) {
                dst = (uint)MASK_OUT_ABOVE_32(-(sint)dst);
            }
        }

        src1 = MASK_OUT_ABOVE_16(src);
        src2 = src >> 16;
        dst1 = MASK_OUT_ABOVE_16(dst);
        dst2 = dst >> 16;

        r1 = src1 * dst1;
        r2 = src1 * dst2;
        r3 = src2 * dst1;
        r4 = src2 * dst2;

        lo = r1 + (MASK_OUT_ABOVE_16(r2) << 16) + (MASK_OUT_ABOVE_16(r3) << 16);
        hi = r4 + (r2 >> 16) + (r3 >> 16) + (((r1 >> 16) + MASK_OUT_ABOVE_16(r2) + MASK_OUT_ABOVE_16(r3)) >> 16);

        if (BIT_B(word2) && neg) {
            hi = (uint)MASK_OUT_ABOVE_32((-(sint)hi) - (lo != 0));
            lo = (uint)MASK_OUT_ABOVE_32(-(sint)lo);
        }

        if (BIT_A(word2)) {
            REG_D[word2 & 7] = hi;
            REG_D[(word2 >> 12) & 7] = lo;
            FLAG_N = NFLAG_32(hi);
            FLAG_Z = hi | lo;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        REG_D[(word2 >> 12) & 7] = lo;
        FLAG_N = NFLAG_32(lo);
        FLAG_Z = lo;
        if (BIT_B(word2)) {
            FLAG_V = (!((GET_MSB_32(lo) && hi == 0xffffffff) || (!GET_MSB_32(lo) && !hi))) << 7;
        } else {
            FLAG_V = (hi != 0) << 7;
        }
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_mull_32_pcix(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 src = OPER_PCIX_32();
        uint64 dst = REG_D[(word2 >> 12) & 7];
        uint64 res;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            res = (sint64)((sint32)src) * (sint64)((sint32)dst);
            if (!BIT_A(word2)) {
                FLAG_Z = MASK_OUT_ABOVE_32(res);
                FLAG_N = NFLAG_32(res);
                FLAG_V = ((sint64)res != (sint32)res) << 7;
                REG_D[(word2 >> 12) & 7] = FLAG_Z;
                return;
            }
            FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
            FLAG_N = NFLAG_64(res);
            FLAG_V = VFLAG_CLEAR;
            REG_D[word2 & 7] = (res >> 32);
            REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
            return;
        }

        res = src * dst;
        if (!BIT_A(word2)) {
            FLAG_Z = MASK_OUT_ABOVE_32(res);
            FLAG_N = NFLAG_32(res);
            FLAG_V = (res > 0xffffffff) << 7;
            REG_D[(word2 >> 12) & 7] = FLAG_Z;
            return;
        }
        FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
        FLAG_N = NFLAG_64(res);
        FLAG_V = VFLAG_CLEAR;
        REG_D[word2 & 7] = (res >> 32);
        REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint src = OPER_PCIX_32();
        uint dst = REG_D[(word2 >> 12) & 7];
        uint neg = GET_MSB_32(src ^ dst);
        uint src1;
        uint src2;
        uint dst1;
        uint dst2;
        uint r1;
        uint r2;
        uint r3;
        uint r4;
        uint lo;
        uint hi;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            if (GET_MSB_32(src)) {
                src = (uint)MASK_OUT_ABOVE_32(-(sint)src);
            }
            if (GET_MSB_32(dst)) {
                dst = (uint)MASK_OUT_ABOVE_32(-(sint)dst);
            }
        }

        src1 = MASK_OUT_ABOVE_16(src);
        src2 = src >> 16;
        dst1 = MASK_OUT_ABOVE_16(dst);
        dst2 = dst >> 16;

        r1 = src1 * dst1;
        r2 = src1 * dst2;
        r3 = src2 * dst1;
        r4 = src2 * dst2;

        lo = r1 + (MASK_OUT_ABOVE_16(r2) << 16) + (MASK_OUT_ABOVE_16(r3) << 16);
        hi = r4 + (r2 >> 16) + (r3 >> 16) + (((r1 >> 16) + MASK_OUT_ABOVE_16(r2) + MASK_OUT_ABOVE_16(r3)) >> 16);

        if (BIT_B(word2) && neg) {
            hi = (uint)MASK_OUT_ABOVE_32((-(sint)hi) - (lo != 0));
            lo = (uint)MASK_OUT_ABOVE_32(-(sint)lo);
        }

        if (BIT_A(word2)) {
            REG_D[word2 & 7] = hi;
            REG_D[(word2 >> 12) & 7] = lo;
            FLAG_N = NFLAG_32(hi);
            FLAG_Z = hi | lo;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        REG_D[(word2 >> 12) & 7] = lo;
        FLAG_N = NFLAG_32(lo);
        FLAG_Z = lo;
        if (BIT_B(word2)) {
            FLAG_V = (!((GET_MSB_32(lo) && hi == 0xffffffff) || (!GET_MSB_32(lo) && !hi))) << 7;
        } else {
            FLAG_V = (hi != 0) << 7;
        }
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_mull_32_i(void)
{
#if M68K_USE_64_BIT

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint64 src = OPER_I_32();
        uint64 dst = REG_D[(word2 >> 12) & 7];
        uint64 res;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            res = (sint64)((sint32)src) * (sint64)((sint32)dst);
            if (!BIT_A(word2)) {
                FLAG_Z = MASK_OUT_ABOVE_32(res);
                FLAG_N = NFLAG_32(res);
                FLAG_V = ((sint64)res != (sint32)res) << 7;
                REG_D[(word2 >> 12) & 7] = FLAG_Z;
                return;
            }
            FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
            FLAG_N = NFLAG_64(res);
            FLAG_V = VFLAG_CLEAR;
            REG_D[word2 & 7] = (res >> 32);
            REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
            return;
        }

        res = src * dst;
        if (!BIT_A(word2)) {
            FLAG_Z = MASK_OUT_ABOVE_32(res);
            FLAG_N = NFLAG_32(res);
            FLAG_V = (res > 0xffffffff) << 7;
            REG_D[(word2 >> 12) & 7] = FLAG_Z;
            return;
        }
        FLAG_Z = MASK_OUT_ABOVE_32(res) | (res >> 32);
        FLAG_N = NFLAG_64(res);
        FLAG_V = VFLAG_CLEAR;
        REG_D[word2 & 7] = (res >> 32);
        REG_D[(word2 >> 12) & 7] = MASK_OUT_ABOVE_32(res);
        return;
    }
    m68ki_exception_illegal();

#else

    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint word2 = OPER_I_16();
        uint src = OPER_I_32();
        uint dst = REG_D[(word2 >> 12) & 7];
        uint neg = GET_MSB_32(src ^ dst);
        uint src1;
        uint src2;
        uint dst1;
        uint dst2;
        uint r1;
        uint r2;
        uint r3;
        uint r4;
        uint lo;
        uint hi;

        FLAG_C = CFLAG_CLEAR;

        if (BIT_B(word2)) /* signed */
        {
            if (GET_MSB_32(src)) {
                src = (uint)MASK_OUT_ABOVE_32(-(sint)src);
            }
            if (GET_MSB_32(dst)) {
                dst = (uint)MASK_OUT_ABOVE_32(-(sint)dst);
            }
        }

        src1 = MASK_OUT_ABOVE_16(src);
        src2 = src >> 16;
        dst1 = MASK_OUT_ABOVE_16(dst);
        dst2 = dst >> 16;

        r1 = src1 * dst1;
        r2 = src1 * dst2;
        r3 = src2 * dst1;
        r4 = src2 * dst2;

        lo = r1 + (MASK_OUT_ABOVE_16(r2) << 16) + (MASK_OUT_ABOVE_16(r3) << 16);
        hi = r4 + (r2 >> 16) + (r3 >> 16) + (((r1 >> 16) + MASK_OUT_ABOVE_16(r2) + MASK_OUT_ABOVE_16(r3)) >> 16);

        if (BIT_B(word2) && neg) {
            hi = (uint)MASK_OUT_ABOVE_32((-(sint)hi) - (lo != 0));
            lo = (uint)MASK_OUT_ABOVE_32(-(sint)lo);
        }

        if (BIT_A(word2)) {
            REG_D[word2 & 7] = hi;
            REG_D[(word2 >> 12) & 7] = lo;
            FLAG_N = NFLAG_32(hi);
            FLAG_Z = hi | lo;
            FLAG_V = VFLAG_CLEAR;
            return;
        }

        REG_D[(word2 >> 12) & 7] = lo;
        FLAG_N = NFLAG_32(lo);
        FLAG_Z = lo;
        if (BIT_B(word2)) {
            FLAG_V = (!((GET_MSB_32(lo) && hi == 0xffffffff) || (!GET_MSB_32(lo) && !hi))) << 7;
        } else {
            FLAG_V = (hi != 0) << 7;
        }
        return;
    }
    m68ki_exception_illegal();

#endif
}

static void m68k_op_nbcd_8_d(void)
{
    uint* r_dst = &DY;
    uint dst = *r_dst;
    uint res = MASK_OUT_ABOVE_8(0x9a - dst - XFLAG_AS_1());

    if (res != 0x9a) {
        FLAG_V = ~res; /* Undefined V behavior */

        if ((res & 0x0f) == 0xa) {
            res = (res & 0xf0) + 0x10;
        }

        res = MASK_OUT_ABOVE_8(res);

        FLAG_V &= res; /* Undefined V behavior part II */

        *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

        FLAG_Z |= res;
        FLAG_C = CFLAG_SET;
        FLAG_X = XFLAG_SET;
    } else {
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        FLAG_X = XFLAG_CLEAR;
    }
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
}

static void m68k_op_nbcd_8_ai(void)
{
    uint ea = EA_AY_AI_8();
    uint dst = m68ki_read_8(ea);
    uint res = MASK_OUT_ABOVE_8(0x9a - dst - XFLAG_AS_1());

    if (res != 0x9a) {
        FLAG_V = ~res; /* Undefined V behavior */

        if ((res & 0x0f) == 0xa) {
            res = (res & 0xf0) + 0x10;
        }

        res = MASK_OUT_ABOVE_8(res);

        FLAG_V &= res; /* Undefined V behavior part II */

        m68ki_write_8(ea, MASK_OUT_ABOVE_8(res));

        FLAG_Z |= res;
        FLAG_C = CFLAG_SET;
        FLAG_X = XFLAG_SET;
    } else {
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        FLAG_X = XFLAG_CLEAR;
    }
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
}

static void m68k_op_nbcd_8_pi(void)
{
    uint ea = EA_AY_PI_8();
    uint dst = m68ki_read_8(ea);
    uint res = MASK_OUT_ABOVE_8(0x9a - dst - XFLAG_AS_1());

    if (res != 0x9a) {
        FLAG_V = ~res; /* Undefined V behavior */

        if ((res & 0x0f) == 0xa) {
            res = (res & 0xf0) + 0x10;
        }

        res = MASK_OUT_ABOVE_8(res);

        FLAG_V &= res; /* Undefined V behavior part II */

        m68ki_write_8(ea, MASK_OUT_ABOVE_8(res));

        FLAG_Z |= res;
        FLAG_C = CFLAG_SET;
        FLAG_X = XFLAG_SET;
    } else {
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        FLAG_X = XFLAG_CLEAR;
    }
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
}

static void m68k_op_nbcd_8_pi7(void)
{
    uint ea = EA_A7_PI_8();
    uint dst = m68ki_read_8(ea);
    uint res = MASK_OUT_ABOVE_8(0x9a - dst - XFLAG_AS_1());

    if (res != 0x9a) {
        FLAG_V = ~res; /* Undefined V behavior */

        if ((res & 0x0f) == 0xa) {
            res = (res & 0xf0) + 0x10;
        }

        res = MASK_OUT_ABOVE_8(res);

        FLAG_V &= res; /* Undefined V behavior part II */

        m68ki_write_8(ea, MASK_OUT_ABOVE_8(res));

        FLAG_Z |= res;
        FLAG_C = CFLAG_SET;
        FLAG_X = XFLAG_SET;
    } else {
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        FLAG_X = XFLAG_CLEAR;
    }
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
}

static void m68k_op_nbcd_8_pd(void)
{
    uint ea = EA_AY_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = MASK_OUT_ABOVE_8(0x9a - dst - XFLAG_AS_1());

    if (res != 0x9a) {
        FLAG_V = ~res; /* Undefined V behavior */

        if ((res & 0x0f) == 0xa) {
            res = (res & 0xf0) + 0x10;
        }

        res = MASK_OUT_ABOVE_8(res);

        FLAG_V &= res; /* Undefined V behavior part II */

        m68ki_write_8(ea, MASK_OUT_ABOVE_8(res));

        FLAG_Z |= res;
        FLAG_C = CFLAG_SET;
        FLAG_X = XFLAG_SET;
    } else {
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        FLAG_X = XFLAG_CLEAR;
    }
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
}

static void m68k_op_nbcd_8_pd7(void)
{
    uint ea = EA_A7_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = MASK_OUT_ABOVE_8(0x9a - dst - XFLAG_AS_1());

    if (res != 0x9a) {
        FLAG_V = ~res; /* Undefined V behavior */

        if ((res & 0x0f) == 0xa) {
            res = (res & 0xf0) + 0x10;
        }

        res = MASK_OUT_ABOVE_8(res);

        FLAG_V &= res; /* Undefined V behavior part II */

        m68ki_write_8(ea, MASK_OUT_ABOVE_8(res));

        FLAG_Z |= res;
        FLAG_C = CFLAG_SET;
        FLAG_X = XFLAG_SET;
    } else {
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        FLAG_X = XFLAG_CLEAR;
    }
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
}

static void m68k_op_nbcd_8_di(void)
{
    uint ea = EA_AY_DI_8();
    uint dst = m68ki_read_8(ea);
    uint res = MASK_OUT_ABOVE_8(0x9a - dst - XFLAG_AS_1());

    if (res != 0x9a) {
        FLAG_V = ~res; /* Undefined V behavior */

        if ((res & 0x0f) == 0xa) {
            res = (res & 0xf0) + 0x10;
        }

        res = MASK_OUT_ABOVE_8(res);

        FLAG_V &= res; /* Undefined V behavior part II */

        m68ki_write_8(ea, MASK_OUT_ABOVE_8(res));

        FLAG_Z |= res;
        FLAG_C = CFLAG_SET;
        FLAG_X = XFLAG_SET;
    } else {
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        FLAG_X = XFLAG_CLEAR;
    }
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
}

static void m68k_op_nbcd_8_ix(void)
{
    uint ea = EA_AY_IX_8();
    uint dst = m68ki_read_8(ea);
    uint res = MASK_OUT_ABOVE_8(0x9a - dst - XFLAG_AS_1());

    if (res != 0x9a) {
        FLAG_V = ~res; /* Undefined V behavior */

        if ((res & 0x0f) == 0xa) {
            res = (res & 0xf0) + 0x10;
        }

        res = MASK_OUT_ABOVE_8(res);

        FLAG_V &= res; /* Undefined V behavior part II */

        m68ki_write_8(ea, MASK_OUT_ABOVE_8(res));

        FLAG_Z |= res;
        FLAG_C = CFLAG_SET;
        FLAG_X = XFLAG_SET;
    } else {
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        FLAG_X = XFLAG_CLEAR;
    }
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
}

static void m68k_op_nbcd_8_aw(void)
{
    uint ea = EA_AW_8();
    uint dst = m68ki_read_8(ea);
    uint res = MASK_OUT_ABOVE_8(0x9a - dst - XFLAG_AS_1());

    if (res != 0x9a) {
        FLAG_V = ~res; /* Undefined V behavior */

        if ((res & 0x0f) == 0xa) {
            res = (res & 0xf0) + 0x10;
        }

        res = MASK_OUT_ABOVE_8(res);

        FLAG_V &= res; /* Undefined V behavior part II */

        m68ki_write_8(ea, MASK_OUT_ABOVE_8(res));

        FLAG_Z |= res;
        FLAG_C = CFLAG_SET;
        FLAG_X = XFLAG_SET;
    } else {
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        FLAG_X = XFLAG_CLEAR;
    }
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
}

static void m68k_op_nbcd_8_al(void)
{
    uint ea = EA_AL_8();
    uint dst = m68ki_read_8(ea);
    uint res = MASK_OUT_ABOVE_8(0x9a - dst - XFLAG_AS_1());

    if (res != 0x9a) {
        FLAG_V = ~res; /* Undefined V behavior */

        if ((res & 0x0f) == 0xa) {
            res = (res & 0xf0) + 0x10;
        }

        res = MASK_OUT_ABOVE_8(res);

        FLAG_V &= res; /* Undefined V behavior part II */

        m68ki_write_8(ea, MASK_OUT_ABOVE_8(res));

        FLAG_Z |= res;
        FLAG_C = CFLAG_SET;
        FLAG_X = XFLAG_SET;
    } else {
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        FLAG_X = XFLAG_CLEAR;
    }
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
}

static void m68k_op_neg_8_d(void)
{
    uint* r_dst = &DY;
    uint res = 0 - MASK_OUT_ABOVE_8(*r_dst);

    FLAG_N = NFLAG_8(res);
    FLAG_C = FLAG_X = CFLAG_8(res);
    FLAG_V = *r_dst & res;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_neg_8_ai(void)
{
    uint ea = EA_AY_AI_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_8(res);
    FLAG_C = FLAG_X = CFLAG_8(res);
    FLAG_V = src & res;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_neg_8_pi(void)
{
    uint ea = EA_AY_PI_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_8(res);
    FLAG_C = FLAG_X = CFLAG_8(res);
    FLAG_V = src & res;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_neg_8_pi7(void)
{
    uint ea = EA_A7_PI_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_8(res);
    FLAG_C = FLAG_X = CFLAG_8(res);
    FLAG_V = src & res;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_neg_8_pd(void)
{
    uint ea = EA_AY_PD_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_8(res);
    FLAG_C = FLAG_X = CFLAG_8(res);
    FLAG_V = src & res;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_neg_8_pd7(void)
{
    uint ea = EA_A7_PD_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_8(res);
    FLAG_C = FLAG_X = CFLAG_8(res);
    FLAG_V = src & res;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_neg_8_di(void)
{
    uint ea = EA_AY_DI_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_8(res);
    FLAG_C = FLAG_X = CFLAG_8(res);
    FLAG_V = src & res;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_neg_8_ix(void)
{
    uint ea = EA_AY_IX_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_8(res);
    FLAG_C = FLAG_X = CFLAG_8(res);
    FLAG_V = src & res;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_neg_8_aw(void)
{
    uint ea = EA_AW_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_8(res);
    FLAG_C = FLAG_X = CFLAG_8(res);
    FLAG_V = src & res;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_neg_8_al(void)
{
    uint ea = EA_AL_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_8(res);
    FLAG_C = FLAG_X = CFLAG_8(res);
    FLAG_V = src & res;
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_neg_16_d(void)
{
    uint* r_dst = &DY;
    uint res = 0 - MASK_OUT_ABOVE_16(*r_dst);

    FLAG_N = NFLAG_16(res);
    FLAG_C = FLAG_X = CFLAG_16(res);
    FLAG_V = (*r_dst & res) >> 8;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_neg_16_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint src = m68ki_read_16(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_16(res);
    FLAG_C = FLAG_X = CFLAG_16(res);
    FLAG_V = (src & res) >> 8;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_neg_16_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint src = m68ki_read_16(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_16(res);
    FLAG_C = FLAG_X = CFLAG_16(res);
    FLAG_V = (src & res) >> 8;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_neg_16_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint src = m68ki_read_16(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_16(res);
    FLAG_C = FLAG_X = CFLAG_16(res);
    FLAG_V = (src & res) >> 8;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_neg_16_di(void)
{
    uint ea = EA_AY_DI_16();
    uint src = m68ki_read_16(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_16(res);
    FLAG_C = FLAG_X = CFLAG_16(res);
    FLAG_V = (src & res) >> 8;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_neg_16_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint src = m68ki_read_16(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_16(res);
    FLAG_C = FLAG_X = CFLAG_16(res);
    FLAG_V = (src & res) >> 8;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_neg_16_aw(void)
{
    uint ea = EA_AW_16();
    uint src = m68ki_read_16(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_16(res);
    FLAG_C = FLAG_X = CFLAG_16(res);
    FLAG_V = (src & res) >> 8;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_neg_16_al(void)
{
    uint ea = EA_AL_16();
    uint src = m68ki_read_16(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_16(res);
    FLAG_C = FLAG_X = CFLAG_16(res);
    FLAG_V = (src & res) >> 8;
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_neg_32_d(void)
{
    uint* r_dst = &DY;
    uint res = 0 - *r_dst;

    FLAG_N = NFLAG_32(res);
    FLAG_C = FLAG_X = CFLAG_SUB_32(*r_dst, 0, res);
    FLAG_V = (*r_dst & res) >> 24;
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_neg_32_ai(void)
{
    uint ea = EA_AY_AI_32();
    uint src = m68ki_read_32(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_32(res);
    FLAG_C = FLAG_X = CFLAG_SUB_32(src, 0, res);
    FLAG_V = (src & res) >> 24;
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_neg_32_pi(void)
{
    uint ea = EA_AY_PI_32();
    uint src = m68ki_read_32(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_32(res);
    FLAG_C = FLAG_X = CFLAG_SUB_32(src, 0, res);
    FLAG_V = (src & res) >> 24;
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_neg_32_pd(void)
{
    uint ea = EA_AY_PD_32();
    uint src = m68ki_read_32(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_32(res);
    FLAG_C = FLAG_X = CFLAG_SUB_32(src, 0, res);
    FLAG_V = (src & res) >> 24;
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_neg_32_di(void)
{
    uint ea = EA_AY_DI_32();
    uint src = m68ki_read_32(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_32(res);
    FLAG_C = FLAG_X = CFLAG_SUB_32(src, 0, res);
    FLAG_V = (src & res) >> 24;
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_neg_32_ix(void)
{
    uint ea = EA_AY_IX_32();
    uint src = m68ki_read_32(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_32(res);
    FLAG_C = FLAG_X = CFLAG_SUB_32(src, 0, res);
    FLAG_V = (src & res) >> 24;
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_neg_32_aw(void)
{
    uint ea = EA_AW_32();
    uint src = m68ki_read_32(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_32(res);
    FLAG_C = FLAG_X = CFLAG_SUB_32(src, 0, res);
    FLAG_V = (src & res) >> 24;
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_neg_32_al(void)
{
    uint ea = EA_AL_32();
    uint src = m68ki_read_32(ea);
    uint res = 0 - src;

    FLAG_N = NFLAG_32(res);
    FLAG_C = FLAG_X = CFLAG_SUB_32(src, 0, res);
    FLAG_V = (src & res) >> 24;
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_negx_8_d(void)
{
    uint* r_dst = &DY;
    uint res = 0 - MASK_OUT_ABOVE_8(*r_dst) - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = *r_dst & res;

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;
}

static void m68k_op_negx_8_ai(void)
{
    uint ea = EA_AY_AI_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = src & res;

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_negx_8_pi(void)
{
    uint ea = EA_AY_PI_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = src & res;

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_negx_8_pi7(void)
{
    uint ea = EA_A7_PI_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = src & res;

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_negx_8_pd(void)
{
    uint ea = EA_AY_PD_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = src & res;

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_negx_8_pd7(void)
{
    uint ea = EA_A7_PD_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = src & res;

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_negx_8_di(void)
{
    uint ea = EA_AY_DI_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = src & res;

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_negx_8_ix(void)
{
    uint ea = EA_AY_IX_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = src & res;

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_negx_8_aw(void)
{
    uint ea = EA_AW_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = src & res;

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_negx_8_al(void)
{
    uint ea = EA_AL_8();
    uint src = m68ki_read_8(ea);
    uint res = 0 - src - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = src & res;

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_negx_16_d(void)
{
    uint* r_dst = &DY;
    uint res = 0 - MASK_OUT_ABOVE_16(*r_dst) - XFLAG_AS_1();

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = (*r_dst & res) >> 8;

    res = MASK_OUT_ABOVE_16(res);
    FLAG_Z |= res;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
}

static void m68k_op_negx_16_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint src = m68ki_read_16(ea);
    uint res = 0 - MASK_OUT_ABOVE_16(src) - XFLAG_AS_1();

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = (src & res) >> 8;

    res = MASK_OUT_ABOVE_16(res);
    FLAG_Z |= res;

    m68ki_write_16(ea, res);
}

static void m68k_op_negx_16_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint src = m68ki_read_16(ea);
    uint res = 0 - MASK_OUT_ABOVE_16(src) - XFLAG_AS_1();

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = (src & res) >> 8;

    res = MASK_OUT_ABOVE_16(res);
    FLAG_Z |= res;

    m68ki_write_16(ea, res);
}

static void m68k_op_negx_16_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint src = m68ki_read_16(ea);
    uint res = 0 - MASK_OUT_ABOVE_16(src) - XFLAG_AS_1();

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = (src & res) >> 8;

    res = MASK_OUT_ABOVE_16(res);
    FLAG_Z |= res;

    m68ki_write_16(ea, res);
}

static void m68k_op_negx_16_di(void)
{
    uint ea = EA_AY_DI_16();
    uint src = m68ki_read_16(ea);
    uint res = 0 - MASK_OUT_ABOVE_16(src) - XFLAG_AS_1();

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = (src & res) >> 8;

    res = MASK_OUT_ABOVE_16(res);
    FLAG_Z |= res;

    m68ki_write_16(ea, res);
}

static void m68k_op_negx_16_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint src = m68ki_read_16(ea);
    uint res = 0 - MASK_OUT_ABOVE_16(src) - XFLAG_AS_1();

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = (src & res) >> 8;

    res = MASK_OUT_ABOVE_16(res);
    FLAG_Z |= res;

    m68ki_write_16(ea, res);
}

static void m68k_op_negx_16_aw(void)
{
    uint ea = EA_AW_16();
    uint src = m68ki_read_16(ea);
    uint res = 0 - MASK_OUT_ABOVE_16(src) - XFLAG_AS_1();

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = (src & res) >> 8;

    res = MASK_OUT_ABOVE_16(res);
    FLAG_Z |= res;

    m68ki_write_16(ea, res);
}

static void m68k_op_negx_16_al(void)
{
    uint ea = EA_AL_16();
    uint src = m68ki_read_16(ea);
    uint res = 0 - MASK_OUT_ABOVE_16(src) - XFLAG_AS_1();

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = (src & res) >> 8;

    res = MASK_OUT_ABOVE_16(res);
    FLAG_Z |= res;

    m68ki_write_16(ea, res);
}

static void m68k_op_negx_32_d(void)
{
    uint* r_dst = &DY;
    uint res = 0 - MASK_OUT_ABOVE_32(*r_dst) - XFLAG_AS_1();

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(*r_dst, 0, res);
    FLAG_V = (*r_dst & res) >> 24;

    res = MASK_OUT_ABOVE_32(res);
    FLAG_Z |= res;

    *r_dst = res;
}

static void m68k_op_negx_32_ai(void)
{
    uint ea = EA_AY_AI_32();
    uint src = m68ki_read_32(ea);
    uint res = 0 - MASK_OUT_ABOVE_32(src) - XFLAG_AS_1();

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, 0, res);
    FLAG_V = (src & res) >> 24;

    res = MASK_OUT_ABOVE_32(res);
    FLAG_Z |= res;

    m68ki_write_32(ea, res);
}

static void m68k_op_negx_32_pi(void)
{
    uint ea = EA_AY_PI_32();
    uint src = m68ki_read_32(ea);
    uint res = 0 - MASK_OUT_ABOVE_32(src) - XFLAG_AS_1();

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, 0, res);
    FLAG_V = (src & res) >> 24;

    res = MASK_OUT_ABOVE_32(res);
    FLAG_Z |= res;

    m68ki_write_32(ea, res);
}

static void m68k_op_negx_32_pd(void)
{
    uint ea = EA_AY_PD_32();
    uint src = m68ki_read_32(ea);
    uint res = 0 - MASK_OUT_ABOVE_32(src) - XFLAG_AS_1();

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, 0, res);
    FLAG_V = (src & res) >> 24;

    res = MASK_OUT_ABOVE_32(res);
    FLAG_Z |= res;

    m68ki_write_32(ea, res);
}

static void m68k_op_negx_32_di(void)
{
    uint ea = EA_AY_DI_32();
    uint src = m68ki_read_32(ea);
    uint res = 0 - MASK_OUT_ABOVE_32(src) - XFLAG_AS_1();

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, 0, res);
    FLAG_V = (src & res) >> 24;

    res = MASK_OUT_ABOVE_32(res);
    FLAG_Z |= res;

    m68ki_write_32(ea, res);
}

static void m68k_op_negx_32_ix(void)
{
    uint ea = EA_AY_IX_32();
    uint src = m68ki_read_32(ea);
    uint res = 0 - MASK_OUT_ABOVE_32(src) - XFLAG_AS_1();

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, 0, res);
    FLAG_V = (src & res) >> 24;

    res = MASK_OUT_ABOVE_32(res);
    FLAG_Z |= res;

    m68ki_write_32(ea, res);
}

static void m68k_op_negx_32_aw(void)
{
    uint ea = EA_AW_32();
    uint src = m68ki_read_32(ea);
    uint res = 0 - MASK_OUT_ABOVE_32(src) - XFLAG_AS_1();

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, 0, res);
    FLAG_V = (src & res) >> 24;

    res = MASK_OUT_ABOVE_32(res);
    FLAG_Z |= res;

    m68ki_write_32(ea, res);
}

static void m68k_op_negx_32_al(void)
{
    uint ea = EA_AL_32();
    uint src = m68ki_read_32(ea);
    uint res = 0 - MASK_OUT_ABOVE_32(src) - XFLAG_AS_1();

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, 0, res);
    FLAG_V = (src & res) >> 24;

    res = MASK_OUT_ABOVE_32(res);
    FLAG_Z |= res;

    m68ki_write_32(ea, res);
}

static void m68k_op_nop(void)
{
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
}

static void m68k_op_not_8_d(void)
{
    uint* r_dst = &DY;
    uint res = MASK_OUT_ABOVE_8(~*r_dst);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_8_ai(void)
{
    uint ea = EA_AY_AI_8();
    uint res = MASK_OUT_ABOVE_8(~m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_8_pi(void)
{
    uint ea = EA_AY_PI_8();
    uint res = MASK_OUT_ABOVE_8(~m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_8_pi7(void)
{
    uint ea = EA_A7_PI_8();
    uint res = MASK_OUT_ABOVE_8(~m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_8_pd(void)
{
    uint ea = EA_AY_PD_8();
    uint res = MASK_OUT_ABOVE_8(~m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_8_pd7(void)
{
    uint ea = EA_A7_PD_8();
    uint res = MASK_OUT_ABOVE_8(~m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_8_di(void)
{
    uint ea = EA_AY_DI_8();
    uint res = MASK_OUT_ABOVE_8(~m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_8_ix(void)
{
    uint ea = EA_AY_IX_8();
    uint res = MASK_OUT_ABOVE_8(~m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_8_aw(void)
{
    uint ea = EA_AW_8();
    uint res = MASK_OUT_ABOVE_8(~m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_8_al(void)
{
    uint ea = EA_AL_8();
    uint res = MASK_OUT_ABOVE_8(~m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_16_d(void)
{
    uint* r_dst = &DY;
    uint res = MASK_OUT_ABOVE_16(~*r_dst);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_16_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint res = MASK_OUT_ABOVE_16(~m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_16_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint res = MASK_OUT_ABOVE_16(~m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_16_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint res = MASK_OUT_ABOVE_16(~m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_16_di(void)
{
    uint ea = EA_AY_DI_16();
    uint res = MASK_OUT_ABOVE_16(~m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_16_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint res = MASK_OUT_ABOVE_16(~m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_16_aw(void)
{
    uint ea = EA_AW_16();
    uint res = MASK_OUT_ABOVE_16(~m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_16_al(void)
{
    uint ea = EA_AL_16();
    uint res = MASK_OUT_ABOVE_16(~m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_32_d(void)
{
    uint* r_dst = &DY;
    uint res = *r_dst = MASK_OUT_ABOVE_32(~*r_dst);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_32_ai(void)
{
    uint ea = EA_AY_AI_32();
    uint res = MASK_OUT_ABOVE_32(~m68ki_read_32(ea));

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_32_pi(void)
{
    uint ea = EA_AY_PI_32();
    uint res = MASK_OUT_ABOVE_32(~m68ki_read_32(ea));

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_32_pd(void)
{
    uint ea = EA_AY_PD_32();
    uint res = MASK_OUT_ABOVE_32(~m68ki_read_32(ea));

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_32_di(void)
{
    uint ea = EA_AY_DI_32();
    uint res = MASK_OUT_ABOVE_32(~m68ki_read_32(ea));

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_32_ix(void)
{
    uint ea = EA_AY_IX_32();
    uint res = MASK_OUT_ABOVE_32(~m68ki_read_32(ea));

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_32_aw(void)
{
    uint ea = EA_AW_32();
    uint res = MASK_OUT_ABOVE_32(~m68ki_read_32(ea));

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_not_32_al(void)
{
    uint ea = EA_AL_32();
    uint res = MASK_OUT_ABOVE_32(~m68ki_read_32(ea));

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_er_d(void)
{
    uint res = MASK_OUT_ABOVE_8((DX |= MASK_OUT_ABOVE_8(DY)));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_er_ai(void)
{
    uint res = MASK_OUT_ABOVE_8((DX |= OPER_AY_AI_8()));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_er_pi(void)
{
    uint res = MASK_OUT_ABOVE_8((DX |= OPER_AY_PI_8()));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_er_pi7(void)
{
    uint res = MASK_OUT_ABOVE_8((DX |= OPER_A7_PI_8()));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_er_pd(void)
{
    uint res = MASK_OUT_ABOVE_8((DX |= OPER_AY_PD_8()));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_er_pd7(void)
{
    uint res = MASK_OUT_ABOVE_8((DX |= OPER_A7_PD_8()));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_er_di(void)
{
    uint res = MASK_OUT_ABOVE_8((DX |= OPER_AY_DI_8()));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_er_ix(void)
{
    uint res = MASK_OUT_ABOVE_8((DX |= OPER_AY_IX_8()));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_er_aw(void)
{
    uint res = MASK_OUT_ABOVE_8((DX |= OPER_AW_8()));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_er_al(void)
{
    uint res = MASK_OUT_ABOVE_8((DX |= OPER_AL_8()));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_er_pcdi(void)
{
    uint res = MASK_OUT_ABOVE_8((DX |= OPER_PCDI_8()));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_er_pcix(void)
{
    uint res = MASK_OUT_ABOVE_8((DX |= OPER_PCIX_8()));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_er_i(void)
{
    uint res = MASK_OUT_ABOVE_8((DX |= OPER_I_8()));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_er_d(void)
{
    uint res = MASK_OUT_ABOVE_16((DX |= MASK_OUT_ABOVE_16(DY)));

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_er_ai(void)
{
    uint res = MASK_OUT_ABOVE_16((DX |= OPER_AY_AI_16()));

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_er_pi(void)
{
    uint res = MASK_OUT_ABOVE_16((DX |= OPER_AY_PI_16()));

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_er_pd(void)
{
    uint res = MASK_OUT_ABOVE_16((DX |= OPER_AY_PD_16()));

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_er_di(void)
{
    uint res = MASK_OUT_ABOVE_16((DX |= OPER_AY_DI_16()));

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_er_ix(void)
{
    uint res = MASK_OUT_ABOVE_16((DX |= OPER_AY_IX_16()));

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_er_aw(void)
{
    uint res = MASK_OUT_ABOVE_16((DX |= OPER_AW_16()));

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_er_al(void)
{
    uint res = MASK_OUT_ABOVE_16((DX |= OPER_AL_16()));

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_er_pcdi(void)
{
    uint res = MASK_OUT_ABOVE_16((DX |= OPER_PCDI_16()));

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_er_pcix(void)
{
    uint res = MASK_OUT_ABOVE_16((DX |= OPER_PCIX_16()));

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_er_i(void)
{
    uint res = MASK_OUT_ABOVE_16((DX |= OPER_I_16()));

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_er_d(void)
{
    uint res = DX |= DY;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_er_ai(void)
{
    uint res = DX |= OPER_AY_AI_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_er_pi(void)
{
    uint res = DX |= OPER_AY_PI_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_er_pd(void)
{
    uint res = DX |= OPER_AY_PD_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_er_di(void)
{
    uint res = DX |= OPER_AY_DI_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_er_ix(void)
{
    uint res = DX |= OPER_AY_IX_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_er_aw(void)
{
    uint res = DX |= OPER_AW_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_er_al(void)
{
    uint res = DX |= OPER_AL_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_er_pcdi(void)
{
    uint res = DX |= OPER_PCDI_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_er_pcix(void)
{
    uint res = DX |= OPER_PCIX_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_er_i(void)
{
    uint res = DX |= OPER_I_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_re_ai(void)
{
    uint ea = EA_AY_AI_8();
    uint res = MASK_OUT_ABOVE_8(DX | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_re_pi(void)
{
    uint ea = EA_AY_PI_8();
    uint res = MASK_OUT_ABOVE_8(DX | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_re_pi7(void)
{
    uint ea = EA_A7_PI_8();
    uint res = MASK_OUT_ABOVE_8(DX | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_re_pd(void)
{
    uint ea = EA_AY_PD_8();
    uint res = MASK_OUT_ABOVE_8(DX | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_re_pd7(void)
{
    uint ea = EA_A7_PD_8();
    uint res = MASK_OUT_ABOVE_8(DX | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_re_di(void)
{
    uint ea = EA_AY_DI_8();
    uint res = MASK_OUT_ABOVE_8(DX | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_re_ix(void)
{
    uint ea = EA_AY_IX_8();
    uint res = MASK_OUT_ABOVE_8(DX | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_re_aw(void)
{
    uint ea = EA_AW_8();
    uint res = MASK_OUT_ABOVE_8(DX | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_8_re_al(void)
{
    uint ea = EA_AL_8();
    uint res = MASK_OUT_ABOVE_8(DX | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_re_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint res = MASK_OUT_ABOVE_16(DX | m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_re_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint res = MASK_OUT_ABOVE_16(DX | m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_re_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint res = MASK_OUT_ABOVE_16(DX | m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_re_di(void)
{
    uint ea = EA_AY_DI_16();
    uint res = MASK_OUT_ABOVE_16(DX | m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_re_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint res = MASK_OUT_ABOVE_16(DX | m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_re_aw(void)
{
    uint ea = EA_AW_16();
    uint res = MASK_OUT_ABOVE_16(DX | m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_16_re_al(void)
{
    uint ea = EA_AL_16();
    uint res = MASK_OUT_ABOVE_16(DX | m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_re_ai(void)
{
    uint ea = EA_AY_AI_32();
    uint res = DX | m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_re_pi(void)
{
    uint ea = EA_AY_PI_32();
    uint res = DX | m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_re_pd(void)
{
    uint ea = EA_AY_PD_32();
    uint res = DX | m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_re_di(void)
{
    uint ea = EA_AY_DI_32();
    uint res = DX | m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_re_ix(void)
{
    uint ea = EA_AY_IX_32();
    uint res = DX | m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_re_aw(void)
{
    uint ea = EA_AW_32();
    uint res = DX | m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_or_32_re_al(void)
{
    uint ea = EA_AL_32();
    uint res = DX | m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_8_d(void)
{
    uint res = MASK_OUT_ABOVE_8((DY |= OPER_I_8()));

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_8_ai(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_AI_8();
    uint res = MASK_OUT_ABOVE_8(src | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_8_pi(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_PI_8();
    uint res = MASK_OUT_ABOVE_8(src | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_8_pi7(void)
{
    uint src = OPER_I_8();
    uint ea = EA_A7_PI_8();
    uint res = MASK_OUT_ABOVE_8(src | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_8_pd(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_PD_8();
    uint res = MASK_OUT_ABOVE_8(src | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_8_pd7(void)
{
    uint src = OPER_I_8();
    uint ea = EA_A7_PD_8();
    uint res = MASK_OUT_ABOVE_8(src | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_8_di(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_DI_8();
    uint res = MASK_OUT_ABOVE_8(src | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_8_ix(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_IX_8();
    uint res = MASK_OUT_ABOVE_8(src | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_8_aw(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AW_8();
    uint res = MASK_OUT_ABOVE_8(src | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_8_al(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AL_8();
    uint res = MASK_OUT_ABOVE_8(src | m68ki_read_8(ea));

    m68ki_write_8(ea, res);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_16_d(void)
{
    uint res = MASK_OUT_ABOVE_16(DY |= OPER_I_16());

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_16_ai(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_AI_16();
    uint res = MASK_OUT_ABOVE_16(src | m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_16_pi(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_PI_16();
    uint res = MASK_OUT_ABOVE_16(src | m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_16_pd(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_PD_16();
    uint res = MASK_OUT_ABOVE_16(src | m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_16_di(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_DI_16();
    uint res = MASK_OUT_ABOVE_16(src | m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_16_ix(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_IX_16();
    uint res = MASK_OUT_ABOVE_16(src | m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_16_aw(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AW_16();
    uint res = MASK_OUT_ABOVE_16(src | m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_16_al(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AL_16();
    uint res = MASK_OUT_ABOVE_16(src | m68ki_read_16(ea));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_32_d(void)
{
    uint res = DY |= OPER_I_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_32_ai(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_AI_32();
    uint res = src | m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_32_pi(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_PI_32();
    uint res = src | m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_32_pd(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_PD_32();
    uint res = src | m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_32_di(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_DI_32();
    uint res = src | m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_32_ix(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_IX_32();
    uint res = src | m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_32_aw(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AW_32();
    uint res = src | m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_32_al(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AL_32();
    uint res = src | m68ki_read_32(ea);

    m68ki_write_32(ea, res);

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ori_16_toc(void)
{
    m68ki_set_ccr(m68ki_get_ccr() | OPER_I_8());
}

static void m68k_op_ori_16_tos(void)
{
    if (FLAG_S) {
        uint src = OPER_I_16();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        m68ki_set_sr(m68ki_get_sr() | src);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_pack_16_rr(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        /* Note: DX and DY are reversed in Motorola's docs */
        uint src = DY + OPER_I_16();
        uint* r_dst = &DX;

        *r_dst = MASK_OUT_BELOW_8(*r_dst) | ((src >> 4) & 0x00f0) | (src & 0x000f);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_pack_16_mm_ax7(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        /* Note: AX and AY are reversed in Motorola's docs */
        uint ea_src = EA_AY_PD_8();
        uint src = m68ki_read_8(ea_src);
        ea_src = EA_AY_PD_8();
        src = ((src << 8) | m68ki_read_8(ea_src)) + OPER_I_16();

        m68ki_write_8(EA_A7_PD_8(), ((src >> 4) & 0x00f0) | (src & 0x000f));
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_pack_16_mm_ay7(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        /* Note: AX and AY are reversed in Motorola's docs */
        uint ea_src = EA_A7_PD_8();
        uint src = m68ki_read_8(ea_src);
        ea_src = EA_A7_PD_8();
        src = ((src << 8) | m68ki_read_8(ea_src)) + OPER_I_16();

        m68ki_write_8(EA_AX_PD_8(), ((src >> 4) & 0x00f0) | (src & 0x000f));
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_pack_16_mm_axy7(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint ea_src = EA_A7_PD_8();
        uint src = m68ki_read_8(ea_src);
        ea_src = EA_A7_PD_8();
        src = ((src << 8) | m68ki_read_8(ea_src)) + OPER_I_16();

        m68ki_write_8(EA_A7_PD_8(), ((src >> 4) & 0x00f0) | (src & 0x000f));
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_pack_16_mm(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        /* Note: AX and AY are reversed in Motorola's docs */
        uint ea_src = EA_AY_PD_8();
        uint src = m68ki_read_8(ea_src);
        ea_src = EA_AY_PD_8();
        src = ((src << 8) | m68ki_read_8(ea_src)) + OPER_I_16();

        m68ki_write_8(EA_AX_PD_8(), ((src >> 4) & 0x00f0) | (src & 0x000f));
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_pea_32_ai(void)
{
    uint ea = EA_AY_AI_32();

    m68ki_push_32(ea);
}

static void m68k_op_pea_32_di(void)
{
    uint ea = EA_AY_DI_32();

    m68ki_push_32(ea);
}

static void m68k_op_pea_32_ix(void)
{
    uint ea = EA_AY_IX_32();

    m68ki_push_32(ea);
}

static void m68k_op_pea_32_aw(void)
{
    uint ea = EA_AW_32();

    m68ki_push_32(ea);
}

static void m68k_op_pea_32_al(void)
{
    uint ea = EA_AL_32();

    m68ki_push_32(ea);
}

static void m68k_op_pea_32_pcdi(void)
{
    uint ea = EA_PCDI_32();

    m68ki_push_32(ea);
}

static void m68k_op_pea_32_pcix(void)
{
    uint ea = EA_PCIX_32();

    m68ki_push_32(ea);
}

static void m68k_op_pflush_32(void)
{
    if ((CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) && (HAS_PMMU)) {
        fprintf(stderr, "68040: unhandled PFLUSH\n");
        return;
    }
    m68ki_exception_1111();
}

static void m68k_op_pmmu_32(void)
{
    if ((CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) && (HAS_PMMU)) {
        m68881_mmu_ops();
    } else {
        m68ki_exception_1111();
    }
}

static void m68k_op_reset(void)
{
    if (FLAG_S) {
        m68ki_output_reset(); /* auto-disable (see m68kcpu.h) */
        USE_CYCLES(CYC_RESET);
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_ror_8_s(void)
{
    uint* r_dst = &DY;
    uint orig_shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint shift = orig_shift & 7;
    uint src = MASK_OUT_ABOVE_8(*r_dst);
    uint res = ROR_8(src, shift);

    if (orig_shift != 0) {
        USE_CYCLES(orig_shift << CYC_SHIFT);
    }

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = src << (9 - orig_shift);
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ror_16_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = MASK_OUT_ABOVE_16(*r_dst);
    uint res = ROR_16(src, shift);

    if (shift != 0) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src << (9 - shift);
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ror_32_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint64 src = *r_dst;
    uint res = ROR_32(src, shift);

    if (shift != 0) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = src << (9 - shift);
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ror_8_r(void)
{
    uint* r_dst = &DY;
    uint orig_shift = DX & 0x3f;
    uint shift = orig_shift & 7;
    uint src = MASK_OUT_ABOVE_8(*r_dst);
    uint res = ROR_8(src, shift);

    if (orig_shift != 0) {
        USE_CYCLES(orig_shift << CYC_SHIFT);

        *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;
        FLAG_C = src << (8 - ((shift - 1) & 7));
        FLAG_N = NFLAG_8(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_8(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ror_16_r(void)
{
    uint* r_dst = &DY;
    uint orig_shift = DX & 0x3f;
    uint shift = orig_shift & 15;
    uint src = MASK_OUT_ABOVE_16(*r_dst);
    uint res = ROR_16(src, shift);

    if (orig_shift != 0) {
        USE_CYCLES(orig_shift << CYC_SHIFT);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        FLAG_C = (src >> ((shift - 1) & 15)) << 8;
        FLAG_N = NFLAG_16(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_16(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ror_32_r(void)
{
    uint* r_dst = &DY;
    uint orig_shift = DX & 0x3f;
    uint shift = orig_shift & 31;
    uint64 src = *r_dst;
    uint res = ROR_32(src, shift);

    if (orig_shift != 0) {
        USE_CYCLES(orig_shift << CYC_SHIFT);

        *r_dst = res;
        FLAG_C = (src >> ((shift - 1) & 31)) << 8;
        FLAG_N = NFLAG_32(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_32(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ror_16_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint src = m68ki_read_16(ea);
    uint res = ROR_16(src, 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src << 8;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ror_16_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint src = m68ki_read_16(ea);
    uint res = ROR_16(src, 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src << 8;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ror_16_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint src = m68ki_read_16(ea);
    uint res = ROR_16(src, 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src << 8;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ror_16_di(void)
{
    uint ea = EA_AY_DI_16();
    uint src = m68ki_read_16(ea);
    uint res = ROR_16(src, 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src << 8;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ror_16_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint src = m68ki_read_16(ea);
    uint res = ROR_16(src, 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src << 8;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ror_16_aw(void)
{
    uint ea = EA_AW_16();
    uint src = m68ki_read_16(ea);
    uint res = ROR_16(src, 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src << 8;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_ror_16_al(void)
{
    uint ea = EA_AL_16();
    uint src = m68ki_read_16(ea);
    uint res = ROR_16(src, 1);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src << 8;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_rol_8_s(void)
{
    uint* r_dst = &DY;
    uint orig_shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint shift = orig_shift & 7;
    uint src = MASK_OUT_ABOVE_8(*r_dst);
    uint res = ROL_8(src, shift);

    if (orig_shift != 0) {
        USE_CYCLES(orig_shift << CYC_SHIFT);
    }

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_C = src << orig_shift;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_rol_16_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = MASK_OUT_ABOVE_16(*r_dst);
    uint res = ROL_16(src, shift);

    if (shift != 0) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src >> (8 - shift);
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_rol_32_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint64 src = *r_dst;
    uint res = ROL_32(src, shift);

    if (shift != 0) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_C = src >> (24 - shift);
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_rol_8_r(void)
{
    uint* r_dst = &DY;
    uint orig_shift = DX & 0x3f;
    uint shift = orig_shift & 7;
    uint src = MASK_OUT_ABOVE_8(*r_dst);
    uint res = ROL_8(src, shift);

    if (orig_shift != 0) {
        USE_CYCLES(orig_shift << CYC_SHIFT);

        if (shift != 0) {
            *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;
            FLAG_C = src << shift;
            FLAG_N = NFLAG_8(res);
            FLAG_Z = res;
            FLAG_V = VFLAG_CLEAR;
            return;
        }
        FLAG_C = (src & 1) << 8;
        FLAG_N = NFLAG_8(src);
        FLAG_Z = src;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_8(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_rol_16_r(void)
{
    uint* r_dst = &DY;
    uint orig_shift = DX & 0x3f;
    uint shift = orig_shift & 15;
    uint src = MASK_OUT_ABOVE_16(*r_dst);
    uint res = MASK_OUT_ABOVE_16(ROL_16(src, shift));

    if (orig_shift != 0) {
        USE_CYCLES(orig_shift << CYC_SHIFT);

        if (shift != 0) {
            *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
            FLAG_C = (src << shift) >> 8;
            FLAG_N = NFLAG_16(res);
            FLAG_Z = res;
            FLAG_V = VFLAG_CLEAR;
            return;
        }
        FLAG_C = (src & 1) << 8;
        FLAG_N = NFLAG_16(src);
        FLAG_Z = src;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_16(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_rol_32_r(void)
{
    uint* r_dst = &DY;
    uint orig_shift = DX & 0x3f;
    uint shift = orig_shift & 31;
    uint64 src = *r_dst;
    uint res = ROL_32(src, shift);

    if (orig_shift != 0) {
        USE_CYCLES(orig_shift << CYC_SHIFT);

        *r_dst = res;

        FLAG_C = (src >> ((32 - shift) & 0x1f)) << 8;
        FLAG_N = NFLAG_32(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = CFLAG_CLEAR;
    FLAG_N = NFLAG_32(src);
    FLAG_Z = src;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_rol_16_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(ROL_16(src, 1));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src >> 7;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_rol_16_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(ROL_16(src, 1));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src >> 7;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_rol_16_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(ROL_16(src, 1));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src >> 7;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_rol_16_di(void)
{
    uint ea = EA_AY_DI_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(ROL_16(src, 1));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src >> 7;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_rol_16_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(ROL_16(src, 1));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src >> 7;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_rol_16_aw(void)
{
    uint ea = EA_AW_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(ROL_16(src, 1));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src >> 7;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_rol_16_al(void)
{
    uint ea = EA_AL_16();
    uint src = m68ki_read_16(ea);
    uint res = MASK_OUT_ABOVE_16(ROL_16(src, 1));

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_C = src >> 7;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxr_8_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = MASK_OUT_ABOVE_8(*r_dst);
    uint res = ROR_9(src | (XFLAG_AS_1() << 8), shift);

    if (shift != 0) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    FLAG_C = FLAG_X = res;
    res = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxr_16_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = MASK_OUT_ABOVE_16(*r_dst);
    uint res = ROR_17(src | (XFLAG_AS_1() << 16), shift);

    if (shift != 0) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxr_32_s(void)
{
#if M68K_USE_64_BIT

    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint64 src = *r_dst;
    uint64 res = src | (((uint64)XFLAG_AS_1()) << 32);

    if (shift != 0) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    res = ROR_33_64(res, shift);

    FLAG_C = FLAG_X = res >> 24;
    res = MASK_OUT_ABOVE_32(res);

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;

#else

    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = *r_dst;
    uint res = MASK_OUT_ABOVE_32((ROR_33(src, shift) & ~(1 << (32 - shift))) | (XFLAG_AS_1() << (32 - shift)));
    uint new_x_flag = src & (1 << (shift - 1));

    if (shift != 0) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = res;

    FLAG_C = FLAG_X = (new_x_flag != 0) << 8;
    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;

#endif
}

static void m68k_op_roxr_8_r(void)
{
    uint* r_dst = &DY;
    uint orig_shift = DX & 0x3f;

    if (orig_shift != 0) {
        uint shift = orig_shift % 9;
        uint src = MASK_OUT_ABOVE_8(*r_dst);
        uint res = ROR_9(src | (XFLAG_AS_1() << 8), shift);

        USE_CYCLES(orig_shift << CYC_SHIFT);

        FLAG_C = FLAG_X = res;
        res = MASK_OUT_ABOVE_8(res);

        *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;
        FLAG_N = NFLAG_8(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = FLAG_X;
    FLAG_N = NFLAG_8(*r_dst);
    FLAG_Z = MASK_OUT_ABOVE_8(*r_dst);
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxr_16_r(void)
{
    uint* r_dst = &DY;
    uint orig_shift = DX & 0x3f;

    if (orig_shift != 0) {
        uint shift = orig_shift % 17;
        uint src = MASK_OUT_ABOVE_16(*r_dst);
        uint res = ROR_17(src | (XFLAG_AS_1() << 16), shift);

        USE_CYCLES(orig_shift << CYC_SHIFT);

        FLAG_C = FLAG_X = res >> 8;
        res = MASK_OUT_ABOVE_16(res);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        FLAG_N = NFLAG_16(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = FLAG_X;
    FLAG_N = NFLAG_16(*r_dst);
    FLAG_Z = MASK_OUT_ABOVE_16(*r_dst);
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxr_32_r(void)
{
#if M68K_USE_64_BIT

    uint* r_dst = &DY;
    uint orig_shift = DX & 0x3f;

    if (orig_shift != 0) {
        uint shift = orig_shift % 33;
        uint64 src = *r_dst;
        uint64 res = src | (((uint64)XFLAG_AS_1()) << 32);

        res = ROR_33_64(res, shift);

        USE_CYCLES(orig_shift << CYC_SHIFT);

        FLAG_C = FLAG_X = res >> 24;
        res = MASK_OUT_ABOVE_32(res);

        *r_dst = res;
        FLAG_N = NFLAG_32(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = FLAG_X;
    FLAG_N = NFLAG_32(*r_dst);
    FLAG_Z = *r_dst;
    FLAG_V = VFLAG_CLEAR;

#else

    uint* r_dst = &DY;
    uint orig_shift = DX & 0x3f;
    uint shift = orig_shift % 33;
    uint src = *r_dst;
    uint res = MASK_OUT_ABOVE_32((ROR_33(src, shift) & ~(1 << (32 - shift))) | (XFLAG_AS_1() << (32 - shift)));
    uint new_x_flag = src & (1 << (shift - 1));

    if (orig_shift != 0) {
        USE_CYCLES(orig_shift << CYC_SHIFT);
    }

    if (shift != 0) {
        *r_dst = res;
        FLAG_X = (new_x_flag != 0) << 8;
    } else {
        res = src;
    }
    FLAG_C = FLAG_X;
    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;

#endif
}

static void m68k_op_roxr_16_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint src = m68ki_read_16(ea);
    uint res = ROR_17(src | (XFLAG_AS_1() << 16), 1);

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxr_16_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint src = m68ki_read_16(ea);
    uint res = ROR_17(src | (XFLAG_AS_1() << 16), 1);

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxr_16_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint src = m68ki_read_16(ea);
    uint res = ROR_17(src | (XFLAG_AS_1() << 16), 1);

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxr_16_di(void)
{
    uint ea = EA_AY_DI_16();
    uint src = m68ki_read_16(ea);
    uint res = ROR_17(src | (XFLAG_AS_1() << 16), 1);

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxr_16_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint src = m68ki_read_16(ea);
    uint res = ROR_17(src | (XFLAG_AS_1() << 16), 1);

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxr_16_aw(void)
{
    uint ea = EA_AW_16();
    uint src = m68ki_read_16(ea);
    uint res = ROR_17(src | (XFLAG_AS_1() << 16), 1);

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxr_16_al(void)
{
    uint ea = EA_AL_16();
    uint src = m68ki_read_16(ea);
    uint res = ROR_17(src | (XFLAG_AS_1() << 16), 1);

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxl_8_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = MASK_OUT_ABOVE_8(*r_dst);
    uint res = ROL_9(src | (XFLAG_AS_1() << 8), shift);

    if (shift != 0) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    FLAG_C = FLAG_X = res;
    res = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxl_16_s(void)
{
    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = MASK_OUT_ABOVE_16(*r_dst);
    uint res = ROL_17(src | (XFLAG_AS_1() << 16), shift);

    if (shift != 0) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxl_32_s(void)
{
#if M68K_USE_64_BIT

    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint64 src = *r_dst;
    uint64 res = src | (((uint64)XFLAG_AS_1()) << 32);

    if (shift != 0) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    res = ROL_33_64(res, shift);

    FLAG_C = FLAG_X = res >> 24;
    res = MASK_OUT_ABOVE_32(res);

    *r_dst = res;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;

#else

    uint* r_dst = &DY;
    uint shift = (((REG_IR >> 9) - 1) & 7) + 1;
    uint src = *r_dst;
    uint res = MASK_OUT_ABOVE_32((ROL_33(src, shift) & ~(1 << (shift - 1))) | (XFLAG_AS_1() << (shift - 1)));
    uint new_x_flag = src & (1 << (32 - shift));

    if (shift != 0) {
        USE_CYCLES(shift << CYC_SHIFT);
    }

    *r_dst = res;

    FLAG_C = FLAG_X = (new_x_flag != 0) << 8;
    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;

#endif
}

static void m68k_op_roxl_8_r(void)
{
    uint* r_dst = &DY;
    uint orig_shift = DX & 0x3f;

    if (orig_shift != 0) {
        uint shift = orig_shift % 9;
        uint src = MASK_OUT_ABOVE_8(*r_dst);
        uint res = ROL_9(src | (XFLAG_AS_1() << 8), shift);

        USE_CYCLES(orig_shift << CYC_SHIFT);

        FLAG_C = FLAG_X = res;
        res = MASK_OUT_ABOVE_8(res);

        *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;
        FLAG_N = NFLAG_8(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = FLAG_X;
    FLAG_N = NFLAG_8(*r_dst);
    FLAG_Z = MASK_OUT_ABOVE_8(*r_dst);
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxl_16_r(void)
{
    uint* r_dst = &DY;
    uint orig_shift = DX & 0x3f;

    if (orig_shift != 0) {
        uint shift = orig_shift % 17;
        uint src = MASK_OUT_ABOVE_16(*r_dst);
        uint res = ROL_17(src | (XFLAG_AS_1() << 16), shift);

        USE_CYCLES(orig_shift << CYC_SHIFT);

        FLAG_C = FLAG_X = res >> 8;
        res = MASK_OUT_ABOVE_16(res);

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
        FLAG_N = NFLAG_16(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = FLAG_X;
    FLAG_N = NFLAG_16(*r_dst);
    FLAG_Z = MASK_OUT_ABOVE_16(*r_dst);
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxl_32_r(void)
{
#if M68K_USE_64_BIT

    uint* r_dst = &DY;
    uint orig_shift = DX & 0x3f;

    if (orig_shift != 0) {
        uint shift = orig_shift % 33;
        uint64 src = *r_dst;
        uint64 res = src | (((uint64)XFLAG_AS_1()) << 32);

        res = ROL_33_64(res, shift);

        USE_CYCLES(orig_shift << CYC_SHIFT);

        FLAG_C = FLAG_X = res >> 24;
        res = MASK_OUT_ABOVE_32(res);

        *r_dst = res;
        FLAG_N = NFLAG_32(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        return;
    }

    FLAG_C = FLAG_X;
    FLAG_N = NFLAG_32(*r_dst);
    FLAG_Z = *r_dst;
    FLAG_V = VFLAG_CLEAR;

#else

    uint* r_dst = &DY;
    uint orig_shift = DX & 0x3f;
    uint shift = orig_shift % 33;
    uint src = *r_dst;
    uint res = MASK_OUT_ABOVE_32((ROL_33(src, shift) & ~(1 << (shift - 1))) | (XFLAG_AS_1() << (shift - 1)));
    uint new_x_flag = src & (1 << (32 - shift));

    if (orig_shift != 0) {
        USE_CYCLES(orig_shift << CYC_SHIFT);
    }

    if (shift != 0) {
        *r_dst = res;
        FLAG_X = (new_x_flag != 0) << 8;
    } else {
        res = src;
    }
    FLAG_C = FLAG_X;
    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;

#endif
}

static void m68k_op_roxl_16_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint src = m68ki_read_16(ea);
    uint res = ROL_17(src | (XFLAG_AS_1() << 16), 1);

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxl_16_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint src = m68ki_read_16(ea);
    uint res = ROL_17(src | (XFLAG_AS_1() << 16), 1);

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxl_16_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint src = m68ki_read_16(ea);
    uint res = ROL_17(src | (XFLAG_AS_1() << 16), 1);

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxl_16_di(void)
{
    uint ea = EA_AY_DI_16();
    uint src = m68ki_read_16(ea);
    uint res = ROL_17(src | (XFLAG_AS_1() << 16), 1);

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxl_16_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint src = m68ki_read_16(ea);
    uint res = ROL_17(src | (XFLAG_AS_1() << 16), 1);

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxl_16_aw(void)
{
    uint ea = EA_AW_16();
    uint src = m68ki_read_16(ea);
    uint res = ROL_17(src | (XFLAG_AS_1() << 16), 1);

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_roxl_16_al(void)
{
    uint ea = EA_AL_16();
    uint src = m68ki_read_16(ea);
    uint res = ROL_17(src | (XFLAG_AS_1() << 16), 1);

    FLAG_C = FLAG_X = res >> 8;
    res = MASK_OUT_ABOVE_16(res);

    m68ki_write_16(ea, res);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_rtd_32(void)
{
    if (CPU_TYPE_IS_010_PLUS(CPU_TYPE)) {
        uint new_pc = m68ki_pull_32();

        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        REG_A[7] = MASK_OUT_ABOVE_32(REG_A[7] + MAKE_INT_16(OPER_I_16()));
        m68ki_jump(new_pc);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_rte_32(void)
{
    if (FLAG_S) {
        uint new_sr;
        uint new_pc;
        uint format_word;

        m68ki_rte_callback(); /* auto-disable (see m68kcpu.h) */
        m68ki_trace_t0();     /* auto-disable (see m68kcpu.h) */

        if (CPU_TYPE_IS_000(CPU_TYPE)) {
            new_sr = m68ki_pull_16();
            new_pc = m68ki_pull_32();
            m68ki_jump(new_pc);
            m68ki_set_sr(new_sr);

            CPU_INSTR_MODE = INSTRUCTION_YES;
            CPU_RUN_MODE = RUN_MODE_NORMAL;

            return;
        }

        if (CPU_TYPE_IS_010(CPU_TYPE)) {
            format_word = m68ki_read_16(REG_A[7] + 6) >> 12;
            if (format_word == 0) {
                new_sr = m68ki_pull_16();
                new_pc = m68ki_pull_32();
                m68ki_fake_pull_16(); /* format word */
                m68ki_jump(new_pc);
                m68ki_set_sr(new_sr);
                CPU_INSTR_MODE = INSTRUCTION_YES;
                CPU_RUN_MODE = RUN_MODE_NORMAL;
                return;
            } else if (format_word == 8) {
                /* Format 8 stack frame -- 68010 only. 29 word bus/address error */
                new_sr = m68ki_pull_16();
                new_pc = m68ki_pull_32();
                m68ki_fake_pull_16(); /* format word */
                m68ki_fake_pull_16(); /* special status word */
                m68ki_fake_pull_32(); /* fault address */
                m68ki_fake_pull_16(); /* unused/reserved */
                m68ki_fake_pull_16(); /* data output buffer */
                m68ki_fake_pull_16(); /* unused/reserved */
                m68ki_fake_pull_16(); /* data input buffer */
                m68ki_fake_pull_16(); /* unused/reserved */
                m68ki_fake_pull_16(); /* instruction input buffer */
                m68ki_fake_pull_32(); /* internal information, 16 words */
                m68ki_fake_pull_32(); /* (actually, we use 8 DWORDs) */
                m68ki_fake_pull_32();
                m68ki_fake_pull_32();
                m68ki_fake_pull_32();
                m68ki_fake_pull_32();
                m68ki_fake_pull_32();
                m68ki_fake_pull_32();
                m68ki_jump(new_pc);
                m68ki_set_sr(new_sr);
                CPU_INSTR_MODE = INSTRUCTION_YES;
                CPU_RUN_MODE = RUN_MODE_NORMAL;
                return;
            }
            CPU_INSTR_MODE = INSTRUCTION_YES;
            CPU_RUN_MODE = RUN_MODE_NORMAL;
            /* Not handling other exception types (9) */
            m68ki_exception_format_error();
            return;
        }

        /* Otherwise it's 020 */
    rte_loop:
        format_word = m68ki_read_16(REG_A[7] + 6) >> 12;
        switch (format_word) {
            case 0: /* Normal */
                new_sr = m68ki_pull_16();
                new_pc = m68ki_pull_32();
                m68ki_fake_pull_16(); /* format word */
                m68ki_jump(new_pc);
                m68ki_set_sr(new_sr);
                CPU_INSTR_MODE = INSTRUCTION_YES;
                CPU_RUN_MODE = RUN_MODE_NORMAL;
                return;
            case 1: /* Throwaway */
                new_sr = m68ki_pull_16();
                m68ki_fake_pull_32(); /* program counter */
                m68ki_fake_pull_16(); /* format word */
                m68ki_set_sr_noint(new_sr);
                goto rte_loop;
            case 2: /* Trap */
                new_sr = m68ki_pull_16();
                new_pc = m68ki_pull_32();
                m68ki_fake_pull_16(); /* format word */
                m68ki_fake_pull_32(); /* address */
                m68ki_jump(new_pc);
                m68ki_set_sr(new_sr);
                CPU_INSTR_MODE = INSTRUCTION_YES;
                CPU_RUN_MODE = RUN_MODE_NORMAL;
                return;
        }
        /* Not handling long or short bus fault */
        CPU_INSTR_MODE = INSTRUCTION_YES;
        CPU_RUN_MODE = RUN_MODE_NORMAL;
        m68ki_exception_format_error();
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_rtm_32(void)
{
    if (CPU_TYPE_IS_020_VARIANT(CPU_TYPE)) {
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        M68K_DO_LOG((M68K_LOG_FILEHANDLE "%s at %08x: called unimplemented instruction %04x (%s)\n",
                     m68ki_cpu_names[CPU_TYPE], ADDRESS_68K(REG_PC - 2), REG_IR,
                     m68k_disassemble_quick(ADDRESS_68K(REG_PC - 2))));
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_rtr_32(void)
{
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    m68ki_set_ccr(m68ki_pull_16());
    m68ki_jump(m68ki_pull_32());
}

static void m68k_op_rts_32(void)
{
    m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
    m68ki_jump(m68ki_pull_32());
}

static void m68k_op_sbcd_8_rr(void)
{
    uint* r_dst = &DX;
    uint src = DY;
    uint dst = *r_dst;
    uint res = LOW_NIBBLE(dst) - LOW_NIBBLE(src) - XFLAG_AS_1();

    FLAG_V = ~res; /* Undefined V behavior */

    if (res > 9) {
        res -= 6;
    }
    res += HIGH_NIBBLE(dst) - HIGH_NIBBLE(src);
    FLAG_X = FLAG_C = (res > 0x99) << 8;
    if (FLAG_C) {
        res += 0xa0;
    }

    res = MASK_OUT_ABOVE_8(res);

    FLAG_V &= res;         /* Undefined V behavior part II */
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
    FLAG_Z |= res;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;
}

static void m68k_op_sbcd_8_mm_ax7(void)
{
    uint src = OPER_AY_PD_8();
    uint ea = EA_A7_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = LOW_NIBBLE(dst) - LOW_NIBBLE(src) - XFLAG_AS_1();

    FLAG_V = ~res; /* Undefined V behavior */

    if (res > 9) {
        res -= 6;
    }
    res += HIGH_NIBBLE(dst) - HIGH_NIBBLE(src);
    FLAG_X = FLAG_C = (res > 0x99) << 8;
    if (FLAG_C) {
        res += 0xa0;
    }

    res = MASK_OUT_ABOVE_8(res);

    FLAG_V &= res;         /* Undefined V behavior part II */
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_sbcd_8_mm_ay7(void)
{
    uint src = OPER_A7_PD_8();
    uint ea = EA_AX_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = LOW_NIBBLE(dst) - LOW_NIBBLE(src) - XFLAG_AS_1();

    FLAG_V = ~res; /* Undefined V behavior */

    if (res > 9) {
        res -= 6;
    }
    res += HIGH_NIBBLE(dst) - HIGH_NIBBLE(src);
    FLAG_X = FLAG_C = (res > 0x99) << 8;
    if (FLAG_C) {
        res += 0xa0;
    }

    res = MASK_OUT_ABOVE_8(res);

    FLAG_V &= res;         /* Undefined V behavior part II */
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_sbcd_8_mm_axy7(void)
{
    uint src = OPER_A7_PD_8();
    uint ea = EA_A7_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = LOW_NIBBLE(dst) - LOW_NIBBLE(src) - XFLAG_AS_1();

    FLAG_V = ~res; /* Undefined V behavior */

    if (res > 9) {
        res -= 6;
    }
    res += HIGH_NIBBLE(dst) - HIGH_NIBBLE(src);
    FLAG_X = FLAG_C = (res > 0x99) << 8;
    if (FLAG_C) {
        res += 0xa0;
    }

    res = MASK_OUT_ABOVE_8(res);

    FLAG_V &= res;         /* Undefined V behavior part II */
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_sbcd_8_mm(void)
{
    uint src = OPER_AY_PD_8();
    uint ea = EA_AX_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = LOW_NIBBLE(dst) - LOW_NIBBLE(src) - XFLAG_AS_1();

    FLAG_V = ~res; /* Undefined V behavior */

    if (res > 9) {
        res -= 6;
    }
    res += HIGH_NIBBLE(dst) - HIGH_NIBBLE(src);
    FLAG_X = FLAG_C = (res > 0x99) << 8;
    if (FLAG_C) {
        res += 0xa0;
    }

    res = MASK_OUT_ABOVE_8(res);

    FLAG_V &= res;         /* Undefined V behavior part II */
    FLAG_N = NFLAG_8(res); /* Undefined N behavior */
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_st_8_d(void)
{
    DY |= 0xff;
}

static void m68k_op_st_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), 0xff);
}

static void m68k_op_st_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), 0xff);
}

static void m68k_op_st_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), 0xff);
}

static void m68k_op_st_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), 0xff);
}

static void m68k_op_st_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), 0xff);
}

static void m68k_op_st_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), 0xff);
}

static void m68k_op_st_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), 0xff);
}

static void m68k_op_st_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), 0xff);
}

static void m68k_op_st_8_al(void)
{
    m68ki_write_8(EA_AL_8(), 0xff);
}

static void m68k_op_sf_8_d(void)
{
    DY &= 0xffffff00;
}

static void m68k_op_sf_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), 0);
}

static void m68k_op_sf_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), 0);
}

static void m68k_op_sf_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), 0);
}

static void m68k_op_sf_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), 0);
}

static void m68k_op_sf_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), 0);
}

static void m68k_op_sf_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), 0);
}

static void m68k_op_sf_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), 0);
}

static void m68k_op_sf_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), 0);
}

static void m68k_op_sf_8_al(void)
{
    m68ki_write_8(EA_AL_8(), 0);
}

static void m68k_op_shi_8_d(void)
{
    if (COND_HI()) {
        DY |= 0xff;
        USE_CYCLES(CYC_SCC_R_TRUE);
        return;
    }
    DY &= 0xffffff00;
}

static void m68k_op_sls_8_d(void)
{
    if (COND_LS()) {
        DY |= 0xff;
        USE_CYCLES(CYC_SCC_R_TRUE);
        return;
    }
    DY &= 0xffffff00;
}

static void m68k_op_scc_8_d(void)
{
    if (COND_CC()) {
        DY |= 0xff;
        USE_CYCLES(CYC_SCC_R_TRUE);
        return;
    }
    DY &= 0xffffff00;
}

static void m68k_op_scs_8_d(void)
{
    if (COND_CS()) {
        DY |= 0xff;
        USE_CYCLES(CYC_SCC_R_TRUE);
        return;
    }
    DY &= 0xffffff00;
}

static void m68k_op_sne_8_d(void)
{
    if (COND_NE()) {
        DY |= 0xff;
        USE_CYCLES(CYC_SCC_R_TRUE);
        return;
    }
    DY &= 0xffffff00;
}

static void m68k_op_seq_8_d(void)
{
    if (COND_EQ()) {
        DY |= 0xff;
        USE_CYCLES(CYC_SCC_R_TRUE);
        return;
    }
    DY &= 0xffffff00;
}

static void m68k_op_svc_8_d(void)
{
    if (COND_VC()) {
        DY |= 0xff;
        USE_CYCLES(CYC_SCC_R_TRUE);
        return;
    }
    DY &= 0xffffff00;
}

static void m68k_op_svs_8_d(void)
{
    if (COND_VS()) {
        DY |= 0xff;
        USE_CYCLES(CYC_SCC_R_TRUE);
        return;
    }
    DY &= 0xffffff00;
}

static void m68k_op_spl_8_d(void)
{
    if (COND_PL()) {
        DY |= 0xff;
        USE_CYCLES(CYC_SCC_R_TRUE);
        return;
    }
    DY &= 0xffffff00;
}

static void m68k_op_smi_8_d(void)
{
    if (COND_MI()) {
        DY |= 0xff;
        USE_CYCLES(CYC_SCC_R_TRUE);
        return;
    }
    DY &= 0xffffff00;
}

static void m68k_op_sge_8_d(void)
{
    if (COND_GE()) {
        DY |= 0xff;
        USE_CYCLES(CYC_SCC_R_TRUE);
        return;
    }
    DY &= 0xffffff00;
}

static void m68k_op_slt_8_d(void)
{
    if (COND_LT()) {
        DY |= 0xff;
        USE_CYCLES(CYC_SCC_R_TRUE);
        return;
    }
    DY &= 0xffffff00;
}

static void m68k_op_sgt_8_d(void)
{
    if (COND_GT()) {
        DY |= 0xff;
        USE_CYCLES(CYC_SCC_R_TRUE);
        return;
    }
    DY &= 0xffffff00;
}

static void m68k_op_sle_8_d(void)
{
    if (COND_LE()) {
        DY |= 0xff;
        USE_CYCLES(CYC_SCC_R_TRUE);
        return;
    }
    DY &= 0xffffff00;
}

static void m68k_op_shi_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), COND_HI() ? 0xff : 0);
}

static void m68k_op_shi_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), COND_HI() ? 0xff : 0);
}

static void m68k_op_shi_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), COND_HI() ? 0xff : 0);
}

static void m68k_op_shi_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), COND_HI() ? 0xff : 0);
}

static void m68k_op_shi_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), COND_HI() ? 0xff : 0);
}

static void m68k_op_shi_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), COND_HI() ? 0xff : 0);
}

static void m68k_op_shi_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), COND_HI() ? 0xff : 0);
}

static void m68k_op_shi_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), COND_HI() ? 0xff : 0);
}

static void m68k_op_shi_8_al(void)
{
    m68ki_write_8(EA_AL_8(), COND_HI() ? 0xff : 0);
}

static void m68k_op_sls_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), COND_LS() ? 0xff : 0);
}

static void m68k_op_sls_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), COND_LS() ? 0xff : 0);
}

static void m68k_op_sls_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), COND_LS() ? 0xff : 0);
}

static void m68k_op_sls_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), COND_LS() ? 0xff : 0);
}

static void m68k_op_sls_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), COND_LS() ? 0xff : 0);
}

static void m68k_op_sls_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), COND_LS() ? 0xff : 0);
}

static void m68k_op_sls_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), COND_LS() ? 0xff : 0);
}

static void m68k_op_sls_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), COND_LS() ? 0xff : 0);
}

static void m68k_op_sls_8_al(void)
{
    m68ki_write_8(EA_AL_8(), COND_LS() ? 0xff : 0);
}

static void m68k_op_scc_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), COND_CC() ? 0xff : 0);
}

static void m68k_op_scc_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), COND_CC() ? 0xff : 0);
}

static void m68k_op_scc_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), COND_CC() ? 0xff : 0);
}

static void m68k_op_scc_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), COND_CC() ? 0xff : 0);
}

static void m68k_op_scc_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), COND_CC() ? 0xff : 0);
}

static void m68k_op_scc_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), COND_CC() ? 0xff : 0);
}

static void m68k_op_scc_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), COND_CC() ? 0xff : 0);
}

static void m68k_op_scc_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), COND_CC() ? 0xff : 0);
}

static void m68k_op_scc_8_al(void)
{
    m68ki_write_8(EA_AL_8(), COND_CC() ? 0xff : 0);
}

static void m68k_op_scs_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), COND_CS() ? 0xff : 0);
}

static void m68k_op_scs_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), COND_CS() ? 0xff : 0);
}

static void m68k_op_scs_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), COND_CS() ? 0xff : 0);
}

static void m68k_op_scs_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), COND_CS() ? 0xff : 0);
}

static void m68k_op_scs_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), COND_CS() ? 0xff : 0);
}

static void m68k_op_scs_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), COND_CS() ? 0xff : 0);
}

static void m68k_op_scs_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), COND_CS() ? 0xff : 0);
}

static void m68k_op_scs_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), COND_CS() ? 0xff : 0);
}

static void m68k_op_scs_8_al(void)
{
    m68ki_write_8(EA_AL_8(), COND_CS() ? 0xff : 0);
}

static void m68k_op_sne_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), COND_NE() ? 0xff : 0);
}

static void m68k_op_sne_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), COND_NE() ? 0xff : 0);
}

static void m68k_op_sne_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), COND_NE() ? 0xff : 0);
}

static void m68k_op_sne_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), COND_NE() ? 0xff : 0);
}

static void m68k_op_sne_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), COND_NE() ? 0xff : 0);
}

static void m68k_op_sne_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), COND_NE() ? 0xff : 0);
}

static void m68k_op_sne_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), COND_NE() ? 0xff : 0);
}

static void m68k_op_sne_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), COND_NE() ? 0xff : 0);
}

static void m68k_op_sne_8_al(void)
{
    m68ki_write_8(EA_AL_8(), COND_NE() ? 0xff : 0);
}

static void m68k_op_seq_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), COND_EQ() ? 0xff : 0);
}

static void m68k_op_seq_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), COND_EQ() ? 0xff : 0);
}

static void m68k_op_seq_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), COND_EQ() ? 0xff : 0);
}

static void m68k_op_seq_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), COND_EQ() ? 0xff : 0);
}

static void m68k_op_seq_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), COND_EQ() ? 0xff : 0);
}

static void m68k_op_seq_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), COND_EQ() ? 0xff : 0);
}

static void m68k_op_seq_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), COND_EQ() ? 0xff : 0);
}

static void m68k_op_seq_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), COND_EQ() ? 0xff : 0);
}

static void m68k_op_seq_8_al(void)
{
    m68ki_write_8(EA_AL_8(), COND_EQ() ? 0xff : 0);
}

static void m68k_op_svc_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), COND_VC() ? 0xff : 0);
}

static void m68k_op_svc_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), COND_VC() ? 0xff : 0);
}

static void m68k_op_svc_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), COND_VC() ? 0xff : 0);
}

static void m68k_op_svc_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), COND_VC() ? 0xff : 0);
}

static void m68k_op_svc_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), COND_VC() ? 0xff : 0);
}

static void m68k_op_svc_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), COND_VC() ? 0xff : 0);
}

static void m68k_op_svc_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), COND_VC() ? 0xff : 0);
}

static void m68k_op_svc_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), COND_VC() ? 0xff : 0);
}

static void m68k_op_svc_8_al(void)
{
    m68ki_write_8(EA_AL_8(), COND_VC() ? 0xff : 0);
}

static void m68k_op_svs_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), COND_VS() ? 0xff : 0);
}

static void m68k_op_svs_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), COND_VS() ? 0xff : 0);
}

static void m68k_op_svs_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), COND_VS() ? 0xff : 0);
}

static void m68k_op_svs_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), COND_VS() ? 0xff : 0);
}

static void m68k_op_svs_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), COND_VS() ? 0xff : 0);
}

static void m68k_op_svs_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), COND_VS() ? 0xff : 0);
}

static void m68k_op_svs_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), COND_VS() ? 0xff : 0);
}

static void m68k_op_svs_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), COND_VS() ? 0xff : 0);
}

static void m68k_op_svs_8_al(void)
{
    m68ki_write_8(EA_AL_8(), COND_VS() ? 0xff : 0);
}

static void m68k_op_spl_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), COND_PL() ? 0xff : 0);
}

static void m68k_op_spl_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), COND_PL() ? 0xff : 0);
}

static void m68k_op_spl_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), COND_PL() ? 0xff : 0);
}

static void m68k_op_spl_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), COND_PL() ? 0xff : 0);
}

static void m68k_op_spl_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), COND_PL() ? 0xff : 0);
}

static void m68k_op_spl_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), COND_PL() ? 0xff : 0);
}

static void m68k_op_spl_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), COND_PL() ? 0xff : 0);
}

static void m68k_op_spl_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), COND_PL() ? 0xff : 0);
}

static void m68k_op_spl_8_al(void)
{
    m68ki_write_8(EA_AL_8(), COND_PL() ? 0xff : 0);
}

static void m68k_op_smi_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), COND_MI() ? 0xff : 0);
}

static void m68k_op_smi_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), COND_MI() ? 0xff : 0);
}

static void m68k_op_smi_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), COND_MI() ? 0xff : 0);
}

static void m68k_op_smi_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), COND_MI() ? 0xff : 0);
}

static void m68k_op_smi_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), COND_MI() ? 0xff : 0);
}

static void m68k_op_smi_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), COND_MI() ? 0xff : 0);
}

static void m68k_op_smi_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), COND_MI() ? 0xff : 0);
}

static void m68k_op_smi_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), COND_MI() ? 0xff : 0);
}

static void m68k_op_smi_8_al(void)
{
    m68ki_write_8(EA_AL_8(), COND_MI() ? 0xff : 0);
}

static void m68k_op_sge_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), COND_GE() ? 0xff : 0);
}

static void m68k_op_sge_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), COND_GE() ? 0xff : 0);
}

static void m68k_op_sge_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), COND_GE() ? 0xff : 0);
}

static void m68k_op_sge_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), COND_GE() ? 0xff : 0);
}

static void m68k_op_sge_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), COND_GE() ? 0xff : 0);
}

static void m68k_op_sge_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), COND_GE() ? 0xff : 0);
}

static void m68k_op_sge_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), COND_GE() ? 0xff : 0);
}

static void m68k_op_sge_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), COND_GE() ? 0xff : 0);
}

static void m68k_op_sge_8_al(void)
{
    m68ki_write_8(EA_AL_8(), COND_GE() ? 0xff : 0);
}

static void m68k_op_slt_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), COND_LT() ? 0xff : 0);
}

static void m68k_op_slt_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), COND_LT() ? 0xff : 0);
}

static void m68k_op_slt_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), COND_LT() ? 0xff : 0);
}

static void m68k_op_slt_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), COND_LT() ? 0xff : 0);
}

static void m68k_op_slt_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), COND_LT() ? 0xff : 0);
}

static void m68k_op_slt_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), COND_LT() ? 0xff : 0);
}

static void m68k_op_slt_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), COND_LT() ? 0xff : 0);
}

static void m68k_op_slt_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), COND_LT() ? 0xff : 0);
}

static void m68k_op_slt_8_al(void)
{
    m68ki_write_8(EA_AL_8(), COND_LT() ? 0xff : 0);
}

static void m68k_op_sgt_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), COND_GT() ? 0xff : 0);
}

static void m68k_op_sgt_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), COND_GT() ? 0xff : 0);
}

static void m68k_op_sgt_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), COND_GT() ? 0xff : 0);
}

static void m68k_op_sgt_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), COND_GT() ? 0xff : 0);
}

static void m68k_op_sgt_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), COND_GT() ? 0xff : 0);
}

static void m68k_op_sgt_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), COND_GT() ? 0xff : 0);
}

static void m68k_op_sgt_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), COND_GT() ? 0xff : 0);
}

static void m68k_op_sgt_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), COND_GT() ? 0xff : 0);
}

static void m68k_op_sgt_8_al(void)
{
    m68ki_write_8(EA_AL_8(), COND_GT() ? 0xff : 0);
}

static void m68k_op_sle_8_ai(void)
{
    m68ki_write_8(EA_AY_AI_8(), COND_LE() ? 0xff : 0);
}

static void m68k_op_sle_8_pi(void)
{
    m68ki_write_8(EA_AY_PI_8(), COND_LE() ? 0xff : 0);
}

static void m68k_op_sle_8_pi7(void)
{
    m68ki_write_8(EA_A7_PI_8(), COND_LE() ? 0xff : 0);
}

static void m68k_op_sle_8_pd(void)
{
    m68ki_write_8(EA_AY_PD_8(), COND_LE() ? 0xff : 0);
}

static void m68k_op_sle_8_pd7(void)
{
    m68ki_write_8(EA_A7_PD_8(), COND_LE() ? 0xff : 0);
}

static void m68k_op_sle_8_di(void)
{
    m68ki_write_8(EA_AY_DI_8(), COND_LE() ? 0xff : 0);
}

static void m68k_op_sle_8_ix(void)
{
    m68ki_write_8(EA_AY_IX_8(), COND_LE() ? 0xff : 0);
}

static void m68k_op_sle_8_aw(void)
{
    m68ki_write_8(EA_AW_8(), COND_LE() ? 0xff : 0);
}

static void m68k_op_sle_8_al(void)
{
    m68ki_write_8(EA_AL_8(), COND_LE() ? 0xff : 0);
}

static void m68k_op_stop(void)
{
    if (FLAG_S) {
        uint new_sr = OPER_I_16();
        m68ki_trace_t0(); /* auto-disable (see m68kcpu.h) */
        CPU_STOPPED |= STOP_LEVEL_STOP;
        m68ki_set_sr(new_sr);
        if (m68ki_remaining_cycles >= CYC_INSTRUCTION[REG_IR]) {
            m68ki_remaining_cycles = CYC_INSTRUCTION[REG_IR];
        } else {
            USE_ALL_CYCLES();
        }
        return;
    }
    m68ki_exception_privilege_violation();
}

static void m68k_op_sub_8_er_d(void)
{
    uint* r_dst = &DX;
    uint src = MASK_OUT_ABOVE_8(DY);
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_8_er_ai(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_AI_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_8_er_pi(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_PI_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_8_er_pi7(void)
{
    uint* r_dst = &DX;
    uint src = OPER_A7_PI_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_8_er_pd(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_PD_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_8_er_pd7(void)
{
    uint* r_dst = &DX;
    uint src = OPER_A7_PD_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_8_er_di(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_DI_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_8_er_ix(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_IX_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_8_er_aw(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AW_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_8_er_al(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AL_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_8_er_pcdi(void)
{
    uint* r_dst = &DX;
    uint src = OPER_PCDI_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_8_er_pcix(void)
{
    uint* r_dst = &DX;
    uint src = OPER_PCIX_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_8_er_i(void)
{
    uint* r_dst = &DX;
    uint src = OPER_I_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_16_er_d(void)
{
    uint* r_dst = &DX;
    uint src = MASK_OUT_ABOVE_16(DY);
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_16_er_a(void)
{
    uint* r_dst = &DX;
    uint src = MASK_OUT_ABOVE_16(AY);
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_16_er_ai(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_AI_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_16_er_pi(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_PI_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_16_er_pd(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_PD_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_16_er_di(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_DI_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_16_er_ix(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_IX_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_16_er_aw(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AW_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_16_er_al(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AL_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_16_er_pcdi(void)
{
    uint* r_dst = &DX;
    uint src = OPER_PCDI_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_16_er_pcix(void)
{
    uint* r_dst = &DX;
    uint src = OPER_PCIX_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_16_er_i(void)
{
    uint* r_dst = &DX;
    uint src = OPER_I_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_sub_32_er_d(void)
{
    uint* r_dst = &DX;
    uint src = DY;
    uint dst = *r_dst;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_sub_32_er_a(void)
{
    uint* r_dst = &DX;
    uint src = AY;
    uint dst = *r_dst;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_sub_32_er_ai(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_AI_32();
    uint dst = *r_dst;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_sub_32_er_pi(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_PI_32();
    uint dst = *r_dst;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_sub_32_er_pd(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_PD_32();
    uint dst = *r_dst;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_sub_32_er_di(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_DI_32();
    uint dst = *r_dst;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_sub_32_er_ix(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AY_IX_32();
    uint dst = *r_dst;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_sub_32_er_aw(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AW_32();
    uint dst = *r_dst;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_sub_32_er_al(void)
{
    uint* r_dst = &DX;
    uint src = OPER_AL_32();
    uint dst = *r_dst;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_sub_32_er_pcdi(void)
{
    uint* r_dst = &DX;
    uint src = OPER_PCDI_32();
    uint dst = *r_dst;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_sub_32_er_pcix(void)
{
    uint* r_dst = &DX;
    uint src = OPER_PCIX_32();
    uint dst = *r_dst;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_sub_32_er_i(void)
{
    uint* r_dst = &DX;
    uint src = OPER_I_32();
    uint dst = *r_dst;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);

    *r_dst = FLAG_Z;
}

static void m68k_op_sub_8_re_ai(void)
{
    uint ea = EA_AY_AI_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_sub_8_re_pi(void)
{
    uint ea = EA_AY_PI_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_sub_8_re_pi7(void)
{
    uint ea = EA_A7_PI_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_sub_8_re_pd(void)
{
    uint ea = EA_AY_PD_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_sub_8_re_pd7(void)
{
    uint ea = EA_A7_PD_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_sub_8_re_di(void)
{
    uint ea = EA_AY_DI_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_sub_8_re_ix(void)
{
    uint ea = EA_AY_IX_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_sub_8_re_aw(void)
{
    uint ea = EA_AW_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_sub_8_re_al(void)
{
    uint ea = EA_AL_8();
    uint src = MASK_OUT_ABOVE_8(DX);
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_sub_16_re_ai(void)
{
    uint ea = EA_AY_AI_16();
    uint src = MASK_OUT_ABOVE_16(DX);
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_sub_16_re_pi(void)
{
    uint ea = EA_AY_PI_16();
    uint src = MASK_OUT_ABOVE_16(DX);
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_sub_16_re_pd(void)
{
    uint ea = EA_AY_PD_16();
    uint src = MASK_OUT_ABOVE_16(DX);
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_sub_16_re_di(void)
{
    uint ea = EA_AY_DI_16();
    uint src = MASK_OUT_ABOVE_16(DX);
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_sub_16_re_ix(void)
{
    uint ea = EA_AY_IX_16();
    uint src = MASK_OUT_ABOVE_16(DX);
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_sub_16_re_aw(void)
{
    uint ea = EA_AW_16();
    uint src = MASK_OUT_ABOVE_16(DX);
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_sub_16_re_al(void)
{
    uint ea = EA_AL_16();
    uint src = MASK_OUT_ABOVE_16(DX);
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_sub_32_re_ai(void)
{
    uint ea = EA_AY_AI_32();
    uint src = DX;
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_sub_32_re_pi(void)
{
    uint ea = EA_AY_PI_32();
    uint src = DX;
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_sub_32_re_pd(void)
{
    uint ea = EA_AY_PD_32();
    uint src = DX;
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_sub_32_re_di(void)
{
    uint ea = EA_AY_DI_32();
    uint src = DX;
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_sub_32_re_ix(void)
{
    uint ea = EA_AY_IX_32();
    uint src = DX;
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_sub_32_re_aw(void)
{
    uint ea = EA_AW_32();
    uint src = DX;
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_sub_32_re_al(void)
{
    uint ea = EA_AL_32();
    uint src = DX;
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_suba_16_d(void)
{
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - MAKE_INT_16(DY));
}

static void m68k_op_suba_16_a(void)
{
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - MAKE_INT_16(AY));
}

static void m68k_op_suba_16_ai(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_AY_AI_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_16_pi(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_AY_PI_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_16_pd(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_AY_PD_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_16_di(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_AY_DI_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_16_ix(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_AY_IX_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_16_aw(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_AW_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_16_al(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_AL_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_16_pcdi(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_PCDI_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_16_pcix(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_PCIX_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_16_i(void)
{
    uint* r_dst = &AX;
    uint src = MAKE_INT_16(OPER_I_16());

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_32_d(void)
{
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - DY);
}

static void m68k_op_suba_32_a(void)
{
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - AY);
}

static void m68k_op_suba_32_ai(void)
{
    uint src = OPER_AY_AI_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_32_pi(void)
{
    uint src = OPER_AY_PI_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_32_pd(void)
{
    uint src = OPER_AY_PD_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_32_di(void)
{
    uint src = OPER_AY_DI_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_32_ix(void)
{
    uint src = OPER_AY_IX_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_32_aw(void)
{
    uint src = OPER_AW_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_32_al(void)
{
    uint src = OPER_AL_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_32_pcdi(void)
{
    uint src = OPER_PCDI_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_32_pcix(void)
{
    uint src = OPER_PCIX_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_suba_32_i(void)
{
    uint src = OPER_I_32();
    uint* r_dst = &AX;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - src);
}

static void m68k_op_subi_8_d(void)
{
    uint* r_dst = &DY;
    uint src = OPER_I_8();
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_subi_8_ai(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_AI_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subi_8_pi(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_PI_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subi_8_pi7(void)
{
    uint src = OPER_I_8();
    uint ea = EA_A7_PI_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subi_8_pd(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subi_8_pd7(void)
{
    uint src = OPER_I_8();
    uint ea = EA_A7_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subi_8_di(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_DI_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subi_8_ix(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AY_IX_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subi_8_aw(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AW_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subi_8_al(void)
{
    uint src = OPER_I_8();
    uint ea = EA_AL_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subi_16_d(void)
{
    uint* r_dst = &DY;
    uint src = OPER_I_16();
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_subi_16_ai(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_AI_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_subi_16_pi(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_PI_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_subi_16_pd(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_PD_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_subi_16_di(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_DI_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_subi_16_ix(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AY_IX_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_subi_16_aw(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AW_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_subi_16_al(void)
{
    uint src = OPER_I_16();
    uint ea = EA_AL_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_subi_32_d(void)
{
    uint* r_dst = &DY;
    uint src = OPER_I_32();
    uint dst = *r_dst;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    *r_dst = FLAG_Z;
}

static void m68k_op_subi_32_ai(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_AI_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_subi_32_pi(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_PI_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_subi_32_pd(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_PD_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_subi_32_di(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_DI_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_subi_32_ix(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AY_IX_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_subi_32_aw(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AW_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_subi_32_al(void)
{
    uint src = OPER_I_32();
    uint ea = EA_AL_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_subq_8_d(void)
{
    uint* r_dst = &DY;
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | FLAG_Z;
}

static void m68k_op_subq_8_ai(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_AI_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subq_8_pi(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_PI_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subq_8_pi7(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_A7_PI_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subq_8_pd(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subq_8_pd7(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_A7_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subq_8_di(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_DI_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subq_8_ix(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_IX_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subq_8_aw(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AW_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subq_8_al(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AL_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_8(res);
    FLAG_Z = MASK_OUT_ABOVE_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    m68ki_write_8(ea, FLAG_Z);
}

static void m68k_op_subq_16_d(void)
{
    uint* r_dst = &DY;
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | FLAG_Z;
}

static void m68k_op_subq_16_a(void)
{
    uint* r_dst = &AY;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - ((((REG_IR >> 9) - 1) & 7) + 1));
}

static void m68k_op_subq_16_ai(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_AI_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_subq_16_pi(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_PI_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_subq_16_pd(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_PD_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_subq_16_di(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_DI_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_subq_16_ix(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_IX_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_subq_16_aw(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AW_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_subq_16_al(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AL_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_16(res);
    FLAG_Z = MASK_OUT_ABOVE_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    m68ki_write_16(ea, FLAG_Z);
}

static void m68k_op_subq_32_d(void)
{
    uint* r_dst = &DY;
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint dst = *r_dst;
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    *r_dst = FLAG_Z;
}

static void m68k_op_subq_32_a(void)
{
    uint* r_dst = &AY;

    *r_dst = MASK_OUT_ABOVE_32(*r_dst - ((((REG_IR >> 9) - 1) & 7) + 1));
}

static void m68k_op_subq_32_ai(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_AI_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_subq_32_pi(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_PI_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_subq_32_pd(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_PD_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_subq_32_di(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_DI_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_subq_32_ix(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AY_IX_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_subq_32_aw(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AW_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_subq_32_al(void)
{
    uint src = (((REG_IR >> 9) - 1) & 7) + 1;
    uint ea = EA_AL_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = MASK_OUT_ABOVE_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    m68ki_write_32(ea, FLAG_Z);
}

static void m68k_op_subx_8_rr(void)
{
    uint* r_dst = &DX;
    uint src = MASK_OUT_ABOVE_8(DY);
    uint dst = MASK_OUT_ABOVE_8(*r_dst);
    uint res = dst - src - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    *r_dst = MASK_OUT_BELOW_8(*r_dst) | res;
}

static void m68k_op_subx_16_rr(void)
{
    uint* r_dst = &DX;
    uint src = MASK_OUT_ABOVE_16(DY);
    uint dst = MASK_OUT_ABOVE_16(*r_dst);
    uint res = dst - src - XFLAG_AS_1();

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    res = MASK_OUT_ABOVE_16(res);
    FLAG_Z |= res;

    *r_dst = MASK_OUT_BELOW_16(*r_dst) | res;
}

static void m68k_op_subx_32_rr(void)
{
    uint* r_dst = &DX;
    uint src = DY;
    uint dst = *r_dst;
    uint res = dst - src - XFLAG_AS_1();

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    res = MASK_OUT_ABOVE_32(res);
    FLAG_Z |= res;

    *r_dst = res;
}

static void m68k_op_subx_8_mm_ax7(void)
{
    uint src = OPER_AY_PD_8();
    uint ea = EA_A7_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_subx_8_mm_ay7(void)
{
    uint src = OPER_A7_PD_8();
    uint ea = EA_AX_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_subx_8_mm_axy7(void)
{
    uint src = OPER_A7_PD_8();
    uint ea = EA_A7_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_subx_8_mm(void)
{
    uint src = OPER_AY_PD_8();
    uint ea = EA_AX_PD_8();
    uint dst = m68ki_read_8(ea);
    uint res = dst - src - XFLAG_AS_1();

    FLAG_N = NFLAG_8(res);
    FLAG_X = FLAG_C = CFLAG_8(res);
    FLAG_V = VFLAG_SUB_8(src, dst, res);

    res = MASK_OUT_ABOVE_8(res);
    FLAG_Z |= res;

    m68ki_write_8(ea, res);
}

static void m68k_op_subx_16_mm(void)
{
    uint src = OPER_AY_PD_16();
    uint ea = EA_AX_PD_16();
    uint dst = m68ki_read_16(ea);
    uint res = dst - src - XFLAG_AS_1();

    FLAG_N = NFLAG_16(res);
    FLAG_X = FLAG_C = CFLAG_16(res);
    FLAG_V = VFLAG_SUB_16(src, dst, res);

    res = MASK_OUT_ABOVE_16(res);
    FLAG_Z |= res;

    m68ki_write_16(ea, res);
}

static void m68k_op_subx_32_mm(void)
{
    uint src = OPER_AY_PD_32();
    uint ea = EA_AX_PD_32();
    uint dst = m68ki_read_32(ea);
    uint res = dst - src - XFLAG_AS_1();

    FLAG_N = NFLAG_32(res);
    FLAG_X = FLAG_C = CFLAG_SUB_32(src, dst, res);
    FLAG_V = VFLAG_SUB_32(src, dst, res);

    res = MASK_OUT_ABOVE_32(res);
    FLAG_Z |= res;

    m68ki_write_32(ea, res);
}

static void m68k_op_swap_32(void)
{
    uint* r_dst = &DY;

    FLAG_Z = MASK_OUT_ABOVE_32(*r_dst << 16);
    *r_dst = (*r_dst >> 16) | FLAG_Z;

    FLAG_Z = *r_dst;
    FLAG_N = NFLAG_32(*r_dst);
    FLAG_C = CFLAG_CLEAR;
    FLAG_V = VFLAG_CLEAR;
}

static void m68k_op_tas_8_d(void)
{
    uint* r_dst = &DY;

    FLAG_Z = MASK_OUT_ABOVE_8(*r_dst);
    FLAG_N = NFLAG_8(*r_dst);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
    *r_dst |= 0x80;
}

static void m68k_op_tas_8_ai(void)
{
    uint ea = EA_AY_AI_8();
    uint dst = m68ki_read_8(ea);
    uint allow_writeback;

    FLAG_Z = dst;
    FLAG_N = NFLAG_8(dst);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;

    /* The Genesis/Megadrive games Gargoyles and Ex-Mutants need the TAS writeback
       disabled in order to function properly.  Some Amiga software may also rely
       on this, but only when accessing specific addresses so additional functionality
       will be needed. */
    allow_writeback = m68ki_tas_callback();

    if (allow_writeback == 1) {
        m68ki_write_8(ea, dst | 0x80);
    }
}

static void m68k_op_tas_8_pi(void)
{
    uint ea = EA_AY_PI_8();
    uint dst = m68ki_read_8(ea);
    uint allow_writeback;

    FLAG_Z = dst;
    FLAG_N = NFLAG_8(dst);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;

    /* The Genesis/Megadrive games Gargoyles and Ex-Mutants need the TAS writeback
       disabled in order to function properly.  Some Amiga software may also rely
       on this, but only when accessing specific addresses so additional functionality
       will be needed. */
    allow_writeback = m68ki_tas_callback();

    if (allow_writeback == 1) {
        m68ki_write_8(ea, dst | 0x80);
    }
}

static void m68k_op_tas_8_pi7(void)
{
    uint ea = EA_A7_PI_8();
    uint dst = m68ki_read_8(ea);
    uint allow_writeback;

    FLAG_Z = dst;
    FLAG_N = NFLAG_8(dst);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;

    /* The Genesis/Megadrive games Gargoyles and Ex-Mutants need the TAS writeback
       disabled in order to function properly.  Some Amiga software may also rely
       on this, but only when accessing specific addresses so additional functionality
       will be needed. */
    allow_writeback = m68ki_tas_callback();

    if (allow_writeback == 1) {
        m68ki_write_8(ea, dst | 0x80);
    }
}

static void m68k_op_tas_8_pd(void)
{
    uint ea = EA_AY_PD_8();
    uint dst = m68ki_read_8(ea);
    uint allow_writeback;

    FLAG_Z = dst;
    FLAG_N = NFLAG_8(dst);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;

    /* The Genesis/Megadrive games Gargoyles and Ex-Mutants need the TAS writeback
       disabled in order to function properly.  Some Amiga software may also rely
       on this, but only when accessing specific addresses so additional functionality
       will be needed. */
    allow_writeback = m68ki_tas_callback();

    if (allow_writeback == 1) {
        m68ki_write_8(ea, dst | 0x80);
    }
}

static void m68k_op_tas_8_pd7(void)
{
    uint ea = EA_A7_PD_8();
    uint dst = m68ki_read_8(ea);
    uint allow_writeback;

    FLAG_Z = dst;
    FLAG_N = NFLAG_8(dst);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;

    /* The Genesis/Megadrive games Gargoyles and Ex-Mutants need the TAS writeback
       disabled in order to function properly.  Some Amiga software may also rely
       on this, but only when accessing specific addresses so additional functionality
       will be needed. */
    allow_writeback = m68ki_tas_callback();

    if (allow_writeback == 1) {
        m68ki_write_8(ea, dst | 0x80);
    }
}

static void m68k_op_tas_8_di(void)
{
    uint ea = EA_AY_DI_8();
    uint dst = m68ki_read_8(ea);
    uint allow_writeback;

    FLAG_Z = dst;
    FLAG_N = NFLAG_8(dst);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;

    /* The Genesis/Megadrive games Gargoyles and Ex-Mutants need the TAS writeback
       disabled in order to function properly.  Some Amiga software may also rely
       on this, but only when accessing specific addresses so additional functionality
       will be needed. */
    allow_writeback = m68ki_tas_callback();

    if (allow_writeback == 1) {
        m68ki_write_8(ea, dst | 0x80);
    }
}

static void m68k_op_tas_8_ix(void)
{
    uint ea = EA_AY_IX_8();
    uint dst = m68ki_read_8(ea);
    uint allow_writeback;

    FLAG_Z = dst;
    FLAG_N = NFLAG_8(dst);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;

    /* The Genesis/Megadrive games Gargoyles and Ex-Mutants need the TAS writeback
       disabled in order to function properly.  Some Amiga software may also rely
       on this, but only when accessing specific addresses so additional functionality
       will be needed. */
    allow_writeback = m68ki_tas_callback();

    if (allow_writeback == 1) {
        m68ki_write_8(ea, dst | 0x80);
    }
}

static void m68k_op_tas_8_aw(void)
{
    uint ea = EA_AW_8();
    uint dst = m68ki_read_8(ea);
    uint allow_writeback;

    FLAG_Z = dst;
    FLAG_N = NFLAG_8(dst);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;

    /* The Genesis/Megadrive games Gargoyles and Ex-Mutants need the TAS writeback
       disabled in order to function properly.  Some Amiga software may also rely
       on this, but only when accessing specific addresses so additional functionality
       will be needed. */
    allow_writeback = m68ki_tas_callback();

    if (allow_writeback == 1) {
        m68ki_write_8(ea, dst | 0x80);
    }
}

static void m68k_op_tas_8_al(void)
{
    uint ea = EA_AL_8();
    uint dst = m68ki_read_8(ea);
    uint allow_writeback;

    FLAG_Z = dst;
    FLAG_N = NFLAG_8(dst);
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;

    /* The Genesis/Megadrive games Gargoyles and Ex-Mutants need the TAS writeback
       disabled in order to function properly.  Some Amiga software may also rely
       on this, but only when accessing specific addresses so additional functionality
       will be needed. */
    allow_writeback = m68ki_tas_callback();

    if (allow_writeback == 1) {
        m68ki_write_8(ea, dst | 0x80);
    }
}

static void m68k_op_trap(void)
{
    /* Trap#n stacks exception frame type 0 */
    m68ki_exception_trapN(EXCEPTION_TRAP_BASE + (REG_IR & 0xf)); /* HJB 990403 */
}

static void m68k_op_trapt(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapt_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2;                           // JFF else stackframe & return addresses are incorrect
        m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapt_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4;                           // JFF else stackframe & return addresses are incorrect
        m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapf(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapf_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapf_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_traphi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_HI()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapls(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_LS()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapcc(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_CC()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapcs(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_CS()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapne(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_NE()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapeq(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_EQ()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapvc(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_VC()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapvs(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_VS()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trappl(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_PL()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapmi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_MI()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapge(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_GE()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_traplt(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_LT()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapgt(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_GT()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_traple(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        if (COND_LE()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_traphi_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_HI()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapls_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_LS()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapcc_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_CC()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapcs_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_CS()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapne_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_NE()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapeq_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_EQ()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapvc_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_VC()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapvs_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_VS()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trappl_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_PL()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapmi_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_MI()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapge_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_GE()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_traplt_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_LT()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapgt_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_GT()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_traple_16(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 2; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_LE()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }

        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_traphi_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_HI()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapls_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_LS()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapcc_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_CC()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapcs_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_CS()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapne_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_NE()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapeq_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_EQ()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapvc_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_VC()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapvs_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_VS()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trappl_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_PL()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapmi_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_MI()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapge_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_GE()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_traplt_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_LT()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapgt_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_GT()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_traple_32(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        REG_PC += 4; /* JFF increase before or 1) stackframe is incorrect 2) RTE address is wrong if trap is taken */
        if (COND_LE()) {
            m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
            return;
        }
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_trapv(void)
{
    if (COND_VC()) {
        return;
    }
    m68ki_exception_trap(EXCEPTION_TRAPV); /* HJB 990403 */
}

static void m68k_op_tst_8_d(void)
{
    uint res = MASK_OUT_ABOVE_8(DY);

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_8_ai(void)
{
    uint res = OPER_AY_AI_8();

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_8_pi(void)
{
    uint res = OPER_AY_PI_8();

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_8_pi7(void)
{
    uint res = OPER_A7_PI_8();

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_8_pd(void)
{
    uint res = OPER_AY_PD_8();

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_8_pd7(void)
{
    uint res = OPER_A7_PD_8();

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_8_di(void)
{
    uint res = OPER_AY_DI_8();

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_8_ix(void)
{
    uint res = OPER_AY_IX_8();

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_8_aw(void)
{
    uint res = OPER_AW_8();

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_8_al(void)
{
    uint res = OPER_AL_8();

    FLAG_N = NFLAG_8(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_8_pcdi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint res = OPER_PCDI_8();

        FLAG_N = NFLAG_8(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_tst_8_pcix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint res = OPER_PCIX_8();

        FLAG_N = NFLAG_8(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_tst_8_i(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint res = OPER_I_8();

        FLAG_N = NFLAG_8(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_tst_16_d(void)
{
    uint res = MASK_OUT_ABOVE_16(DY);

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_16_a(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint res = MAKE_INT_16(AY);

        FLAG_N = NFLAG_16(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_tst_16_ai(void)
{
    uint res = OPER_AY_AI_16();

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_16_pi(void)
{
    uint res = OPER_AY_PI_16();

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_16_pd(void)
{
    uint res = OPER_AY_PD_16();

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_16_di(void)
{
    uint res = OPER_AY_DI_16();

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_16_ix(void)
{
    uint res = OPER_AY_IX_16();

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_16_aw(void)
{
    uint res = OPER_AW_16();

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_16_al(void)
{
    uint res = OPER_AL_16();

    FLAG_N = NFLAG_16(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_16_pcdi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint res = OPER_PCDI_16();

        FLAG_N = NFLAG_16(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_tst_16_pcix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint res = OPER_PCIX_16();

        FLAG_N = NFLAG_16(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_tst_16_i(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint res = OPER_I_16();

        FLAG_N = NFLAG_16(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_tst_32_d(void)
{
    uint res = DY;

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_32_a(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint res = AY;

        FLAG_N = NFLAG_32(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_tst_32_ai(void)
{
    uint res = OPER_AY_AI_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_32_pi(void)
{
    uint res = OPER_AY_PI_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_32_pd(void)
{
    uint res = OPER_AY_PD_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_32_di(void)
{
    uint res = OPER_AY_DI_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_32_ix(void)
{
    uint res = OPER_AY_IX_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_32_aw(void)
{
    uint res = OPER_AW_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_32_al(void)
{
    uint res = OPER_AL_32();

    FLAG_N = NFLAG_32(res);
    FLAG_Z = res;
    FLAG_V = VFLAG_CLEAR;
    FLAG_C = CFLAG_CLEAR;
}

static void m68k_op_tst_32_pcdi(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint res = OPER_PCDI_32();

        FLAG_N = NFLAG_32(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_tst_32_pcix(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint res = OPER_PCIX_32();

        FLAG_N = NFLAG_32(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_tst_32_i(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint res = OPER_I_32();

        FLAG_N = NFLAG_32(res);
        FLAG_Z = res;
        FLAG_V = VFLAG_CLEAR;
        FLAG_C = CFLAG_CLEAR;
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_unlk_32_a7(void)
{
    REG_A[7] = m68ki_read_32(REG_A[7]);
}

static void m68k_op_unlk_32(void)
{
    uint* r_dst = &AY;

    REG_A[7] = *r_dst;
    *r_dst = m68ki_pull_32();
}

static void m68k_op_unpk_16_rr(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        /* Note: DX and DY are reversed in Motorola's docs */
        uint src = DY;
        uint* r_dst = &DX;

        *r_dst = MASK_OUT_BELOW_16(*r_dst) | (((((src << 4) & 0x0f00) | (src & 0x000f)) + OPER_I_16()) & 0xffff);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_unpk_16_mm_ax7(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        /* Note: AX and AY are reversed in Motorola's docs */
        uint src = OPER_AY_PD_8();
        uint ea_dst;

        src = (((src << 4) & 0x0f00) | (src & 0x000f)) + OPER_I_16();
        ea_dst = EA_A7_PD_8();
        m68ki_write_8(ea_dst, (src >> 8) & 0xff);
        ea_dst = EA_A7_PD_8();
        m68ki_write_8(ea_dst, src & 0xff);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_unpk_16_mm_ay7(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        /* Note: AX and AY are reversed in Motorola's docs */
        uint src = OPER_A7_PD_8();
        uint ea_dst;

        src = (((src << 4) & 0x0f00) | (src & 0x000f)) + OPER_I_16();
        ea_dst = EA_AX_PD_8();
        m68ki_write_8(ea_dst, (src >> 8) & 0xff);
        ea_dst = EA_AX_PD_8();
        m68ki_write_8(ea_dst, src & 0xff);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_unpk_16_mm_axy7(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        uint src = OPER_A7_PD_8();
        uint ea_dst;

        src = (((src << 4) & 0x0f00) | (src & 0x000f)) + OPER_I_16();
        ea_dst = EA_A7_PD_8();
        m68ki_write_8(ea_dst, (src >> 8) & 0xff);
        ea_dst = EA_A7_PD_8();
        m68ki_write_8(ea_dst, src & 0xff);
        return;
    }
    m68ki_exception_illegal();
}

static void m68k_op_unpk_16_mm(void)
{
    if (CPU_TYPE_IS_EC020_PLUS(CPU_TYPE)) {
        /* Note: AX and AY are reversed in Motorola's docs */
        uint src = OPER_AY_PD_8();
        uint ea_dst;

        src = (((src << 4) & 0x0f00) | (src & 0x000f)) + OPER_I_16();
        ea_dst = EA_AX_PD_8();
        m68ki_write_8(ea_dst, (src >> 8) & 0xff);
        ea_dst = EA_AX_PD_8();
        m68ki_write_8(ea_dst, src & 0xff);
        return;
    }
    m68ki_exception_illegal();
}

/* ======================================================================== */
/* ============================== END OF FILE ============================= */
/* ======================================================================== */

/* ======================================================================== */
/* ========================= OPCODE TABLE BUILDER ========================= */
/* ======================================================================== */

#include <stdio.h>

#define NUM_CPU_TYPES 5

void (*m68ki_instruction_jump_table[0x10000])(void); /* opcode handler jump table */
unsigned char m68ki_cycles[NUM_CPU_TYPES][0x10000];  /* Cycles used by CPU type */

/* This is used to generate the opcode handler jump table */
typedef struct
{
    void (*opcode_handler)(void);        /* handler function */
    unsigned int mask;                   /* mask on opcode */
    unsigned int match;                  /* what to match after masking */
    unsigned char cycles[NUM_CPU_TYPES]; /* cycles each cpu type takes */
} opcode_handler_struct;

/* Opcode handler table */
static const opcode_handler_struct m68k_opcode_handler_table[] =
    {
        /*   function                      mask    match    000  010  020  040 */

        {m68k_op_1010, 0xf000, 0xa000, {4, 4, 4, 4, 4}},
        {m68k_op_1111, 0xf000, 0xf000, {4, 4, 4, 4, 4}},
        {m68k_op_moveq_32, 0xf100, 0x7000, {4, 4, 2, 2, 2}},
        {m68k_op_cpbcc_32, 0xf180, 0xf080, {0, 0, 4, 4, 0}},
        {m68k_op_cpgen_32, 0xf1c0, 0xf000, {0, 0, 4, 4, 0}},
        {m68k_op_cpscc_32, 0xf1c0, 0xf040, {0, 0, 4, 4, 0}},
        {m68k_op_pmmu_32, 0xfe00, 0xf000, {0, 0, 8, 8, 8}},
        {m68k_op_bra_8, 0xff00, 0x6000, {10, 10, 10, 10, 10}},
        {m68k_op_bsr_8, 0xff00, 0x6100, {18, 18, 7, 7, 7}},
        {m68k_op_bhi_8, 0xff00, 0x6200, {10, 10, 6, 6, 6}},
        {m68k_op_bls_8, 0xff00, 0x6300, {10, 10, 6, 6, 6}},
        {m68k_op_bcc_8, 0xff00, 0x6400, {10, 10, 6, 6, 6}},
        {m68k_op_bcs_8, 0xff00, 0x6500, {10, 10, 6, 6, 6}},
        {m68k_op_bne_8, 0xff00, 0x6600, {10, 10, 6, 6, 6}},
        {m68k_op_beq_8, 0xff00, 0x6700, {10, 10, 6, 6, 6}},
        {m68k_op_bvc_8, 0xff00, 0x6800, {10, 10, 6, 6, 6}},
        {m68k_op_bvs_8, 0xff00, 0x6900, {10, 10, 6, 6, 6}},
        {m68k_op_bpl_8, 0xff00, 0x6a00, {10, 10, 6, 6, 6}},
        {m68k_op_bmi_8, 0xff00, 0x6b00, {10, 10, 6, 6, 6}},
        {m68k_op_bge_8, 0xff00, 0x6c00, {10, 10, 6, 6, 6}},
        {m68k_op_blt_8, 0xff00, 0x6d00, {10, 10, 6, 6, 6}},
        {m68k_op_bgt_8, 0xff00, 0x6e00, {10, 10, 6, 6, 6}},
        {m68k_op_ble_8, 0xff00, 0x6f00, {10, 10, 6, 6, 6}},
        {m68k_op_040fpu0_32, 0xff00, 0xf200, {0, 0, 0, 0, 0}},
        {m68k_op_040fpu1_32, 0xff00, 0xf300, {0, 0, 0, 0, 0}},
        {m68k_op_btst_32_r_d, 0xf1f8, 0x0100, {6, 6, 4, 4, 4}},
        {m68k_op_movep_16_er, 0xf1f8, 0x0108, {16, 16, 12, 12, 12}},
        {m68k_op_btst_8_r_ai, 0xf1f8, 0x0110, {8, 8, 8, 8, 8}},
        {m68k_op_btst_8_r_pi, 0xf1f8, 0x0118, {8, 8, 8, 8, 8}},
        {m68k_op_btst_8_r_pd, 0xf1f8, 0x0120, {10, 10, 9, 9, 9}},
        {m68k_op_btst_8_r_di, 0xf1f8, 0x0128, {12, 12, 9, 9, 9}},
        {m68k_op_btst_8_r_ix, 0xf1f8, 0x0130, {14, 14, 11, 11, 11}},
        {m68k_op_bchg_32_r_d, 0xf1f8, 0x0140, {8, 8, 4, 4, 4}},
        {m68k_op_movep_32_er, 0xf1f8, 0x0148, {24, 24, 18, 18, 18}},
        {m68k_op_bchg_8_r_ai, 0xf1f8, 0x0150, {12, 12, 8, 8, 8}},
        {m68k_op_bchg_8_r_pi, 0xf1f8, 0x0158, {12, 12, 8, 8, 8}},
        {m68k_op_bchg_8_r_pd, 0xf1f8, 0x0160, {14, 14, 9, 9, 9}},
        {m68k_op_bchg_8_r_di, 0xf1f8, 0x0168, {16, 16, 9, 9, 9}},
        {m68k_op_bchg_8_r_ix, 0xf1f8, 0x0170, {18, 18, 11, 11, 11}},
        {m68k_op_bclr_32_r_d, 0xf1f8, 0x0180, {10, 10, 4, 4, 4}},
        {m68k_op_movep_16_re, 0xf1f8, 0x0188, {16, 16, 11, 11, 11}},
        {m68k_op_bclr_8_r_ai, 0xf1f8, 0x0190, {12, 14, 8, 8, 8}},
        {m68k_op_bclr_8_r_pi, 0xf1f8, 0x0198, {12, 14, 8, 8, 8}},
        {m68k_op_bclr_8_r_pd, 0xf1f8, 0x01a0, {14, 16, 9, 9, 9}},
        {m68k_op_bclr_8_r_di, 0xf1f8, 0x01a8, {16, 18, 9, 9, 9}},
        {m68k_op_bclr_8_r_ix, 0xf1f8, 0x01b0, {18, 20, 11, 11, 11}},
        {m68k_op_bset_32_r_d, 0xf1f8, 0x01c0, {8, 8, 4, 4, 4}},
        {m68k_op_movep_32_re, 0xf1f8, 0x01c8, {24, 24, 17, 17, 17}},
        {m68k_op_bset_8_r_ai, 0xf1f8, 0x01d0, {12, 12, 8, 8, 8}},
        {m68k_op_bset_8_r_pi, 0xf1f8, 0x01d8, {12, 12, 8, 8, 8}},
        {m68k_op_bset_8_r_pd, 0xf1f8, 0x01e0, {14, 14, 9, 9, 9}},
        {m68k_op_bset_8_r_di, 0xf1f8, 0x01e8, {16, 16, 9, 9, 9}},
        {m68k_op_bset_8_r_ix, 0xf1f8, 0x01f0, {18, 18, 11, 11, 11}},
        {m68k_op_move_8_d_d, 0xf1f8, 0x1000, {4, 4, 2, 2, 2}},
        {m68k_op_move_8_d_ai, 0xf1f8, 0x1010, {8, 8, 6, 6, 6}},
        {m68k_op_move_8_d_pi, 0xf1f8, 0x1018, {8, 8, 6, 6, 6}},
        {m68k_op_move_8_d_pd, 0xf1f8, 0x1020, {10, 10, 7, 7, 7}},
        {m68k_op_move_8_d_di, 0xf1f8, 0x1028, {12, 12, 7, 7, 7}},
        {m68k_op_move_8_d_ix, 0xf1f8, 0x1030, {14, 14, 9, 9, 9}},
        {m68k_op_move_8_ai_d, 0xf1f8, 0x1080, {8, 8, 4, 4, 4}},
        {m68k_op_move_8_ai_ai, 0xf1f8, 0x1090, {12, 12, 8, 8, 8}},
        {m68k_op_move_8_ai_pi, 0xf1f8, 0x1098, {12, 12, 8, 8, 8}},
        {m68k_op_move_8_ai_pd, 0xf1f8, 0x10a0, {14, 14, 9, 9, 9}},
        {m68k_op_move_8_ai_di, 0xf1f8, 0x10a8, {16, 16, 9, 9, 9}},
        {m68k_op_move_8_ai_ix, 0xf1f8, 0x10b0, {18, 18, 11, 11, 11}},
        {m68k_op_move_8_pi_d, 0xf1f8, 0x10c0, {8, 8, 4, 4, 4}},
        {m68k_op_move_8_pi_ai, 0xf1f8, 0x10d0, {12, 12, 8, 8, 8}},
        {m68k_op_move_8_pi_pi, 0xf1f8, 0x10d8, {12, 12, 8, 8, 8}},
        {m68k_op_move_8_pi_pd, 0xf1f8, 0x10e0, {14, 14, 9, 9, 9}},
        {m68k_op_move_8_pi_di, 0xf1f8, 0x10e8, {16, 16, 9, 9, 9}},
        {m68k_op_move_8_pi_ix, 0xf1f8, 0x10f0, {18, 18, 11, 11, 11}},
        {m68k_op_move_8_pd_d, 0xf1f8, 0x1100, {8, 8, 5, 5, 5}},
        {m68k_op_move_8_pd_ai, 0xf1f8, 0x1110, {12, 12, 9, 9, 9}},
        {m68k_op_move_8_pd_pi, 0xf1f8, 0x1118, {12, 12, 9, 9, 9}},
        {m68k_op_move_8_pd_pd, 0xf1f8, 0x1120, {14, 14, 10, 10, 10}},
        {m68k_op_move_8_pd_di, 0xf1f8, 0x1128, {16, 16, 10, 10, 10}},
        {m68k_op_move_8_pd_ix, 0xf1f8, 0x1130, {18, 18, 12, 12, 12}},
        {m68k_op_move_8_di_d, 0xf1f8, 0x1140, {12, 12, 5, 5, 5}},
        {m68k_op_move_8_di_ai, 0xf1f8, 0x1150, {16, 16, 9, 9, 9}},
        {m68k_op_move_8_di_pi, 0xf1f8, 0x1158, {16, 16, 9, 9, 9}},
        {m68k_op_move_8_di_pd, 0xf1f8, 0x1160, {18, 18, 10, 10, 10}},
        {m68k_op_move_8_di_di, 0xf1f8, 0x1168, {20, 20, 10, 10, 10}},
        {m68k_op_move_8_di_ix, 0xf1f8, 0x1170, {22, 22, 12, 12, 12}},
        {m68k_op_move_8_ix_d, 0xf1f8, 0x1180, {14, 14, 7, 7, 7}},
        {m68k_op_move_8_ix_ai, 0xf1f8, 0x1190, {18, 18, 11, 11, 11}},
        {m68k_op_move_8_ix_pi, 0xf1f8, 0x1198, {18, 18, 11, 11, 11}},
        {m68k_op_move_8_ix_pd, 0xf1f8, 0x11a0, {20, 20, 12, 12, 12}},
        {m68k_op_move_8_ix_di, 0xf1f8, 0x11a8, {22, 22, 12, 12, 12}},
        {m68k_op_move_8_ix_ix, 0xf1f8, 0x11b0, {24, 24, 14, 14, 14}},
        {m68k_op_move_32_d_d, 0xf1f8, 0x2000, {4, 4, 2, 2, 2}},
        {m68k_op_move_32_d_a, 0xf1f8, 0x2008, {4, 4, 2, 2, 2}},
        {m68k_op_move_32_d_ai, 0xf1f8, 0x2010, {12, 12, 6, 6, 6}},
        {m68k_op_move_32_d_pi, 0xf1f8, 0x2018, {12, 12, 6, 6, 6}},
        {m68k_op_move_32_d_pd, 0xf1f8, 0x2020, {14, 14, 7, 7, 7}},
        {m68k_op_move_32_d_di, 0xf1f8, 0x2028, {16, 16, 7, 7, 7}},
        {m68k_op_move_32_d_ix, 0xf1f8, 0x2030, {18, 18, 9, 9, 9}},
        {m68k_op_movea_32_d, 0xf1f8, 0x2040, {4, 4, 2, 2, 2}},
        {m68k_op_movea_32_a, 0xf1f8, 0x2048, {4, 4, 2, 2, 2}},
        {m68k_op_movea_32_ai, 0xf1f8, 0x2050, {12, 12, 6, 6, 6}},
        {m68k_op_movea_32_pi, 0xf1f8, 0x2058, {12, 12, 6, 6, 6}},
        {m68k_op_movea_32_pd, 0xf1f8, 0x2060, {14, 14, 7, 7, 7}},
        {m68k_op_movea_32_di, 0xf1f8, 0x2068, {16, 16, 7, 7, 7}},
        {m68k_op_movea_32_ix, 0xf1f8, 0x2070, {18, 18, 9, 9, 9}},
        {m68k_op_move_32_ai_d, 0xf1f8, 0x2080, {12, 12, 4, 4, 4}},
        {m68k_op_move_32_ai_a, 0xf1f8, 0x2088, {12, 12, 4, 4, 4}},
        {m68k_op_move_32_ai_ai, 0xf1f8, 0x2090, {20, 20, 8, 8, 8}},
        {m68k_op_move_32_ai_pi, 0xf1f8, 0x2098, {20, 20, 8, 8, 8}},
        {m68k_op_move_32_ai_pd, 0xf1f8, 0x20a0, {22, 22, 9, 9, 9}},
        {m68k_op_move_32_ai_di, 0xf1f8, 0x20a8, {24, 24, 9, 9, 9}},
        {m68k_op_move_32_ai_ix, 0xf1f8, 0x20b0, {26, 26, 11, 11, 11}},
        {m68k_op_move_32_pi_d, 0xf1f8, 0x20c0, {12, 12, 4, 4, 4}},
        {m68k_op_move_32_pi_a, 0xf1f8, 0x20c8, {12, 12, 4, 4, 4}},
        {m68k_op_move_32_pi_ai, 0xf1f8, 0x20d0, {20, 20, 8, 8, 8}},
        {m68k_op_move_32_pi_pi, 0xf1f8, 0x20d8, {20, 20, 8, 8, 8}},
        {m68k_op_move_32_pi_pd, 0xf1f8, 0x20e0, {22, 22, 9, 9, 9}},
        {m68k_op_move_32_pi_di, 0xf1f8, 0x20e8, {24, 24, 9, 9, 9}},
        {m68k_op_move_32_pi_ix, 0xf1f8, 0x20f0, {26, 26, 11, 11, 11}},
        {m68k_op_move_32_pd_d, 0xf1f8, 0x2100, {12, 14, 5, 5, 5}},
        {m68k_op_move_32_pd_a, 0xf1f8, 0x2108, {12, 14, 5, 5, 5}},
        {m68k_op_move_32_pd_ai, 0xf1f8, 0x2110, {20, 22, 9, 9, 9}},
        {m68k_op_move_32_pd_pi, 0xf1f8, 0x2118, {20, 22, 9, 9, 9}},
        {m68k_op_move_32_pd_pd, 0xf1f8, 0x2120, {22, 24, 10, 10, 10}},
        {m68k_op_move_32_pd_di, 0xf1f8, 0x2128, {24, 26, 10, 10, 10}},
        {m68k_op_move_32_pd_ix, 0xf1f8, 0x2130, {26, 28, 12, 12, 12}},
        {m68k_op_move_32_di_d, 0xf1f8, 0x2140, {16, 16, 5, 5, 5}},
        {m68k_op_move_32_di_a, 0xf1f8, 0x2148, {16, 16, 5, 5, 5}},
        {m68k_op_move_32_di_ai, 0xf1f8, 0x2150, {24, 24, 9, 9, 9}},
        {m68k_op_move_32_di_pi, 0xf1f8, 0x2158, {24, 24, 9, 9, 9}},
        {m68k_op_move_32_di_pd, 0xf1f8, 0x2160, {26, 26, 10, 10, 10}},
        {m68k_op_move_32_di_di, 0xf1f8, 0x2168, {28, 28, 10, 10, 10}},
        {m68k_op_move_32_di_ix, 0xf1f8, 0x2170, {30, 30, 12, 12, 12}},
        {m68k_op_move_32_ix_d, 0xf1f8, 0x2180, {18, 18, 7, 7, 7}},
        {m68k_op_move_32_ix_a, 0xf1f8, 0x2188, {18, 18, 7, 7, 7}},
        {m68k_op_move_32_ix_ai, 0xf1f8, 0x2190, {26, 26, 11, 11, 11}},
        {m68k_op_move_32_ix_pi, 0xf1f8, 0x2198, {26, 26, 11, 11, 11}},
        {m68k_op_move_32_ix_pd, 0xf1f8, 0x21a0, {28, 28, 12, 12, 12}},
        {m68k_op_move_32_ix_di, 0xf1f8, 0x21a8, {30, 30, 12, 12, 12}},
        {m68k_op_move_32_ix_ix, 0xf1f8, 0x21b0, {32, 32, 14, 14, 14}},
        {m68k_op_move_16_d_d, 0xf1f8, 0x3000, {4, 4, 2, 2, 2}},
        {m68k_op_move_16_d_a, 0xf1f8, 0x3008, {4, 4, 2, 2, 2}},
        {m68k_op_move_16_d_ai, 0xf1f8, 0x3010, {8, 8, 6, 6, 6}},
        {m68k_op_move_16_d_pi, 0xf1f8, 0x3018, {8, 8, 6, 6, 6}},
        {m68k_op_move_16_d_pd, 0xf1f8, 0x3020, {10, 10, 7, 7, 7}},
        {m68k_op_move_16_d_di, 0xf1f8, 0x3028, {12, 12, 7, 7, 7}},
        {m68k_op_move_16_d_ix, 0xf1f8, 0x3030, {14, 14, 9, 9, 9}},
        {m68k_op_movea_16_d, 0xf1f8, 0x3040, {4, 4, 2, 2, 2}},
        {m68k_op_movea_16_a, 0xf1f8, 0x3048, {4, 4, 2, 2, 2}},
        {m68k_op_movea_16_ai, 0xf1f8, 0x3050, {8, 8, 6, 6, 6}},
        {m68k_op_movea_16_pi, 0xf1f8, 0x3058, {8, 8, 6, 6, 6}},
        {m68k_op_movea_16_pd, 0xf1f8, 0x3060, {10, 10, 7, 7, 7}},
        {m68k_op_movea_16_di, 0xf1f8, 0x3068, {12, 12, 7, 7, 7}},
        {m68k_op_movea_16_ix, 0xf1f8, 0x3070, {14, 14, 9, 9, 9}},
        {m68k_op_move_16_ai_d, 0xf1f8, 0x3080, {8, 8, 4, 4, 4}},
        {m68k_op_move_16_ai_a, 0xf1f8, 0x3088, {8, 8, 4, 4, 4}},
        {m68k_op_move_16_ai_ai, 0xf1f8, 0x3090, {12, 12, 8, 8, 8}},
        {m68k_op_move_16_ai_pi, 0xf1f8, 0x3098, {12, 12, 8, 8, 8}},
        {m68k_op_move_16_ai_pd, 0xf1f8, 0x30a0, {14, 14, 9, 9, 9}},
        {m68k_op_move_16_ai_di, 0xf1f8, 0x30a8, {16, 16, 9, 9, 9}},
        {m68k_op_move_16_ai_ix, 0xf1f8, 0x30b0, {18, 18, 11, 11, 11}},
        {m68k_op_move_16_pi_d, 0xf1f8, 0x30c0, {8, 8, 4, 4, 4}},
        {m68k_op_move_16_pi_a, 0xf1f8, 0x30c8, {8, 8, 4, 4, 4}},
        {m68k_op_move_16_pi_ai, 0xf1f8, 0x30d0, {12, 12, 8, 8, 8}},
        {m68k_op_move_16_pi_pi, 0xf1f8, 0x30d8, {12, 12, 8, 8, 8}},
        {m68k_op_move_16_pi_pd, 0xf1f8, 0x30e0, {14, 14, 9, 9, 9}},
        {m68k_op_move_16_pi_di, 0xf1f8, 0x30e8, {16, 16, 9, 9, 9}},
        {m68k_op_move_16_pi_ix, 0xf1f8, 0x30f0, {18, 18, 11, 11, 11}},
        {m68k_op_move_16_pd_d, 0xf1f8, 0x3100, {8, 8, 5, 5, 5}},
        {m68k_op_move_16_pd_a, 0xf1f8, 0x3108, {8, 8, 5, 5, 5}},
        {m68k_op_move_16_pd_ai, 0xf1f8, 0x3110, {12, 12, 9, 9, 9}},
        {m68k_op_move_16_pd_pi, 0xf1f8, 0x3118, {12, 12, 9, 9, 9}},
        {m68k_op_move_16_pd_pd, 0xf1f8, 0x3120, {14, 14, 10, 10, 10}},
        {m68k_op_move_16_pd_di, 0xf1f8, 0x3128, {16, 16, 10, 10, 10}},
        {m68k_op_move_16_pd_ix, 0xf1f8, 0x3130, {18, 18, 12, 12, 12}},
        {m68k_op_move_16_di_d, 0xf1f8, 0x3140, {12, 12, 5, 5, 5}},
        {m68k_op_move_16_di_a, 0xf1f8, 0x3148, {12, 12, 5, 5, 5}},
        {m68k_op_move_16_di_ai, 0xf1f8, 0x3150, {16, 16, 9, 9, 9}},
        {m68k_op_move_16_di_pi, 0xf1f8, 0x3158, {16, 16, 9, 9, 9}},
        {m68k_op_move_16_di_pd, 0xf1f8, 0x3160, {18, 18, 10, 10, 10}},
        {m68k_op_move_16_di_di, 0xf1f8, 0x3168, {20, 20, 10, 10, 10}},
        {m68k_op_move_16_di_ix, 0xf1f8, 0x3170, {22, 22, 12, 12, 12}},
        {m68k_op_move_16_ix_d, 0xf1f8, 0x3180, {14, 14, 7, 7, 7}},
        {m68k_op_move_16_ix_a, 0xf1f8, 0x3188, {14, 14, 7, 7, 7}},
        {m68k_op_move_16_ix_ai, 0xf1f8, 0x3190, {18, 18, 11, 11, 11}},
        {m68k_op_move_16_ix_pi, 0xf1f8, 0x3198, {18, 18, 11, 11, 11}},
        {m68k_op_move_16_ix_pd, 0xf1f8, 0x31a0, {20, 20, 12, 12, 12}},
        {m68k_op_move_16_ix_di, 0xf1f8, 0x31a8, {22, 22, 12, 12, 12}},
        {m68k_op_move_16_ix_ix, 0xf1f8, 0x31b0, {24, 24, 14, 14, 14}},
        {m68k_op_chk_32_d, 0xf1f8, 0x4100, {0, 0, 8, 8, 8}},
        {m68k_op_chk_32_ai, 0xf1f8, 0x4110, {0, 0, 12, 12, 12}},
        {m68k_op_chk_32_pi, 0xf1f8, 0x4118, {0, 0, 12, 12, 12}},
        {m68k_op_chk_32_pd, 0xf1f8, 0x4120, {0, 0, 13, 13, 13}},
        {m68k_op_chk_32_di, 0xf1f8, 0x4128, {0, 0, 13, 13, 13}},
        {m68k_op_chk_32_ix, 0xf1f8, 0x4130, {0, 0, 15, 15, 15}},
        {m68k_op_chk_16_d, 0xf1f8, 0x4180, {10, 8, 8, 8, 8}},
        {m68k_op_chk_16_ai, 0xf1f8, 0x4190, {14, 12, 12, 12, 12}},
        {m68k_op_chk_16_pi, 0xf1f8, 0x4198, {14, 12, 12, 12, 12}},
        {m68k_op_chk_16_pd, 0xf1f8, 0x41a0, {16, 14, 13, 13, 13}},
        {m68k_op_chk_16_di, 0xf1f8, 0x41a8, {18, 16, 13, 13, 13}},
        {m68k_op_chk_16_ix, 0xf1f8, 0x41b0, {20, 18, 15, 15, 15}},
        {m68k_op_lea_32_ai, 0xf1f8, 0x41d0, {4, 4, 6, 6, 6}},
        {m68k_op_lea_32_di, 0xf1f8, 0x41e8, {8, 8, 7, 7, 7}},
        {m68k_op_lea_32_ix, 0xf1f8, 0x41f0, {12, 12, 9, 9, 9}},
        {m68k_op_addq_8_d, 0xf1f8, 0x5000, {4, 4, 2, 2, 2}},
        {m68k_op_addq_8_ai, 0xf1f8, 0x5010, {12, 12, 8, 8, 8}},
        {m68k_op_addq_8_pi, 0xf1f8, 0x5018, {12, 12, 8, 8, 8}},
        {m68k_op_addq_8_pd, 0xf1f8, 0x5020, {14, 14, 9, 9, 9}},
        {m68k_op_addq_8_di, 0xf1f8, 0x5028, {16, 16, 9, 9, 9}},
        {m68k_op_addq_8_ix, 0xf1f8, 0x5030, {18, 18, 11, 11, 11}},
        {m68k_op_addq_16_d, 0xf1f8, 0x5040, {4, 4, 2, 2, 2}},
        {m68k_op_addq_16_a, 0xf1f8, 0x5048, {4, 4, 2, 2, 2}},
        {m68k_op_addq_16_ai, 0xf1f8, 0x5050, {12, 12, 8, 8, 8}},
        {m68k_op_addq_16_pi, 0xf1f8, 0x5058, {12, 12, 8, 8, 8}},
        {m68k_op_addq_16_pd, 0xf1f8, 0x5060, {14, 14, 9, 9, 9}},
        {m68k_op_addq_16_di, 0xf1f8, 0x5068, {16, 16, 9, 9, 9}},
        {m68k_op_addq_16_ix, 0xf1f8, 0x5070, {18, 18, 11, 11, 11}},
        {m68k_op_addq_32_d, 0xf1f8, 0x5080, {8, 8, 2, 2, 2}},
        {m68k_op_addq_32_a, 0xf1f8, 0x5088, {8, 8, 2, 2, 2}},
        {m68k_op_addq_32_ai, 0xf1f8, 0x5090, {20, 20, 8, 8, 8}},
        {m68k_op_addq_32_pi, 0xf1f8, 0x5098, {20, 20, 8, 8, 8}},
        {m68k_op_addq_32_pd, 0xf1f8, 0x50a0, {22, 22, 9, 9, 9}},
        {m68k_op_addq_32_di, 0xf1f8, 0x50a8, {24, 24, 9, 9, 9}},
        {m68k_op_addq_32_ix, 0xf1f8, 0x50b0, {26, 26, 11, 11, 11}},
        {m68k_op_subq_8_d, 0xf1f8, 0x5100, {4, 4, 2, 2, 2}},
        {m68k_op_subq_8_ai, 0xf1f8, 0x5110, {12, 12, 8, 8, 8}},
        {m68k_op_subq_8_pi, 0xf1f8, 0x5118, {12, 12, 8, 8, 8}},
        {m68k_op_subq_8_pd, 0xf1f8, 0x5120, {14, 14, 9, 9, 9}},
        {m68k_op_subq_8_di, 0xf1f8, 0x5128, {16, 16, 9, 9, 9}},
        {m68k_op_subq_8_ix, 0xf1f8, 0x5130, {18, 18, 11, 11, 11}},
        {m68k_op_subq_16_d, 0xf1f8, 0x5140, {4, 4, 2, 2, 2}},
        {m68k_op_subq_16_a, 0xf1f8, 0x5148, {8, 4, 2, 2, 2}},
        {m68k_op_subq_16_ai, 0xf1f8, 0x5150, {12, 12, 8, 8, 8}},
        {m68k_op_subq_16_pi, 0xf1f8, 0x5158, {12, 12, 8, 8, 8}},
        {m68k_op_subq_16_pd, 0xf1f8, 0x5160, {14, 14, 9, 9, 9}},
        {m68k_op_subq_16_di, 0xf1f8, 0x5168, {16, 16, 9, 9, 9}},
        {m68k_op_subq_16_ix, 0xf1f8, 0x5170, {18, 18, 11, 11, 11}},
        {m68k_op_subq_32_d, 0xf1f8, 0x5180, {8, 8, 2, 2, 2}},
        {m68k_op_subq_32_a, 0xf1f8, 0x5188, {8, 8, 2, 2, 2}},
        {m68k_op_subq_32_ai, 0xf1f8, 0x5190, {20, 20, 8, 8, 8}},
        {m68k_op_subq_32_pi, 0xf1f8, 0x5198, {20, 20, 8, 8, 8}},
        {m68k_op_subq_32_pd, 0xf1f8, 0x51a0, {22, 22, 9, 9, 9}},
        {m68k_op_subq_32_di, 0xf1f8, 0x51a8, {24, 24, 9, 9, 9}},
        {m68k_op_subq_32_ix, 0xf1f8, 0x51b0, {26, 26, 11, 11, 11}},
        {m68k_op_or_8_er_d, 0xf1f8, 0x8000, {4, 4, 2, 2, 2}},
        {m68k_op_or_8_er_ai, 0xf1f8, 0x8010, {8, 8, 6, 6, 6}},
        {m68k_op_or_8_er_pi, 0xf1f8, 0x8018, {8, 8, 6, 6, 6}},
        {m68k_op_or_8_er_pd, 0xf1f8, 0x8020, {10, 10, 7, 7, 7}},
        {m68k_op_or_8_er_di, 0xf1f8, 0x8028, {12, 12, 7, 7, 7}},
        {m68k_op_or_8_er_ix, 0xf1f8, 0x8030, {14, 14, 9, 9, 9}},
        {m68k_op_or_16_er_d, 0xf1f8, 0x8040, {4, 4, 2, 2, 2}},
        {m68k_op_or_16_er_ai, 0xf1f8, 0x8050, {8, 8, 6, 6, 6}},
        {m68k_op_or_16_er_pi, 0xf1f8, 0x8058, {8, 8, 6, 6, 6}},
        {m68k_op_or_16_er_pd, 0xf1f8, 0x8060, {10, 10, 7, 7, 7}},
        {m68k_op_or_16_er_di, 0xf1f8, 0x8068, {12, 12, 7, 7, 7}},
        {m68k_op_or_16_er_ix, 0xf1f8, 0x8070, {14, 14, 9, 9, 9}},
        {m68k_op_or_32_er_d, 0xf1f8, 0x8080, {6, 6, 2, 2, 2}},
        {m68k_op_or_32_er_ai, 0xf1f8, 0x8090, {14, 14, 6, 6, 6}},
        {m68k_op_or_32_er_pi, 0xf1f8, 0x8098, {14, 14, 6, 6, 6}},
        {m68k_op_or_32_er_pd, 0xf1f8, 0x80a0, {16, 16, 7, 7, 7}},
        {m68k_op_or_32_er_di, 0xf1f8, 0x80a8, {18, 18, 7, 7, 7}},
        {m68k_op_or_32_er_ix, 0xf1f8, 0x80b0, {20, 20, 9, 9, 9}},
        {m68k_op_divu_16_d, 0xf1f8, 0x80c0, {140, 108, 44, 44, 44}},
        {m68k_op_divu_16_ai, 0xf1f8, 0x80d0, {144, 112, 48, 48, 48}},
        {m68k_op_divu_16_pi, 0xf1f8, 0x80d8, {144, 112, 48, 48, 48}},
        {m68k_op_divu_16_pd, 0xf1f8, 0x80e0, {146, 114, 49, 49, 49}},
        {m68k_op_divu_16_di, 0xf1f8, 0x80e8, {148, 116, 49, 49, 49}},
        {m68k_op_divu_16_ix, 0xf1f8, 0x80f0, {150, 118, 51, 51, 51}},
        {m68k_op_sbcd_8_rr, 0xf1f8, 0x8100, {6, 6, 4, 4, 4}},
        {m68k_op_sbcd_8_mm, 0xf1f8, 0x8108, {18, 18, 16, 16, 16}},
        {m68k_op_or_8_re_ai, 0xf1f8, 0x8110, {12, 12, 8, 8, 8}},
        {m68k_op_or_8_re_pi, 0xf1f8, 0x8118, {12, 12, 8, 8, 8}},
        {m68k_op_or_8_re_pd, 0xf1f8, 0x8120, {14, 14, 9, 9, 9}},
        {m68k_op_or_8_re_di, 0xf1f8, 0x8128, {16, 16, 9, 9, 9}},
        {m68k_op_or_8_re_ix, 0xf1f8, 0x8130, {18, 18, 11, 11, 11}},
        {m68k_op_pack_16_rr, 0xf1f8, 0x8140, {0, 0, 6, 6, 6}},
        {m68k_op_pack_16_mm, 0xf1f8, 0x8148, {0, 0, 13, 13, 13}},
        {m68k_op_or_16_re_ai, 0xf1f8, 0x8150, {12, 12, 8, 8, 8}},
        {m68k_op_or_16_re_pi, 0xf1f8, 0x8158, {12, 12, 8, 8, 8}},
        {m68k_op_or_16_re_pd, 0xf1f8, 0x8160, {14, 14, 9, 9, 9}},
        {m68k_op_or_16_re_di, 0xf1f8, 0x8168, {16, 16, 9, 9, 9}},
        {m68k_op_or_16_re_ix, 0xf1f8, 0x8170, {18, 18, 11, 11, 11}},
        {m68k_op_unpk_16_rr, 0xf1f8, 0x8180, {0, 0, 8, 8, 8}},
        {m68k_op_unpk_16_mm, 0xf1f8, 0x8188, {0, 0, 13, 13, 13}},
        {m68k_op_or_32_re_ai, 0xf1f8, 0x8190, {20, 20, 8, 8, 8}},
        {m68k_op_or_32_re_pi, 0xf1f8, 0x8198, {20, 20, 8, 8, 8}},
        {m68k_op_or_32_re_pd, 0xf1f8, 0x81a0, {22, 22, 9, 9, 9}},
        {m68k_op_or_32_re_di, 0xf1f8, 0x81a8, {24, 24, 9, 9, 9}},
        {m68k_op_or_32_re_ix, 0xf1f8, 0x81b0, {26, 26, 11, 11, 11}},
        {m68k_op_divs_16_d, 0xf1f8, 0x81c0, {158, 122, 56, 56, 56}},
        {m68k_op_divs_16_ai, 0xf1f8, 0x81d0, {162, 126, 60, 60, 60}},
        {m68k_op_divs_16_pi, 0xf1f8, 0x81d8, {162, 126, 60, 60, 60}},
        {m68k_op_divs_16_pd, 0xf1f8, 0x81e0, {164, 128, 61, 61, 61}},
        {m68k_op_divs_16_di, 0xf1f8, 0x81e8, {166, 130, 61, 61, 61}},
        {m68k_op_divs_16_ix, 0xf1f8, 0x81f0, {168, 132, 63, 63, 63}},
        {m68k_op_sub_8_er_d, 0xf1f8, 0x9000, {4, 4, 2, 2, 2}},
        {m68k_op_sub_8_er_ai, 0xf1f8, 0x9010, {8, 8, 6, 6, 6}},
        {m68k_op_sub_8_er_pi, 0xf1f8, 0x9018, {8, 8, 6, 6, 6}},
        {m68k_op_sub_8_er_pd, 0xf1f8, 0x9020, {10, 10, 7, 7, 7}},
        {m68k_op_sub_8_er_di, 0xf1f8, 0x9028, {12, 12, 7, 7, 7}},
        {m68k_op_sub_8_er_ix, 0xf1f8, 0x9030, {14, 14, 9, 9, 9}},
        {m68k_op_sub_16_er_d, 0xf1f8, 0x9040, {4, 4, 2, 2, 2}},
        {m68k_op_sub_16_er_a, 0xf1f8, 0x9048, {4, 4, 2, 2, 2}},
        {m68k_op_sub_16_er_ai, 0xf1f8, 0x9050, {8, 8, 6, 6, 6}},
        {m68k_op_sub_16_er_pi, 0xf1f8, 0x9058, {8, 8, 6, 6, 6}},
        {m68k_op_sub_16_er_pd, 0xf1f8, 0x9060, {10, 10, 7, 7, 7}},
        {m68k_op_sub_16_er_di, 0xf1f8, 0x9068, {12, 12, 7, 7, 7}},
        {m68k_op_sub_16_er_ix, 0xf1f8, 0x9070, {14, 14, 9, 9, 9}},
        {m68k_op_sub_32_er_d, 0xf1f8, 0x9080, {6, 6, 2, 2, 2}},
        {m68k_op_sub_32_er_a, 0xf1f8, 0x9088, {6, 6, 2, 2, 2}},
        {m68k_op_sub_32_er_ai, 0xf1f8, 0x9090, {14, 14, 6, 6, 6}},
        {m68k_op_sub_32_er_pi, 0xf1f8, 0x9098, {14, 14, 6, 6, 6}},
        {m68k_op_sub_32_er_pd, 0xf1f8, 0x90a0, {16, 16, 7, 7, 7}},
        {m68k_op_sub_32_er_di, 0xf1f8, 0x90a8, {18, 18, 7, 7, 7}},
        {m68k_op_sub_32_er_ix, 0xf1f8, 0x90b0, {20, 20, 9, 9, 9}},
        {m68k_op_suba_16_d, 0xf1f8, 0x90c0, {8, 8, 2, 2, 2}},
        {m68k_op_suba_16_a, 0xf1f8, 0x90c8, {8, 8, 2, 2, 2}},
        {m68k_op_suba_16_ai, 0xf1f8, 0x90d0, {12, 12, 6, 6, 6}},
        {m68k_op_suba_16_pi, 0xf1f8, 0x90d8, {12, 12, 6, 6, 6}},
        {m68k_op_suba_16_pd, 0xf1f8, 0x90e0, {14, 14, 7, 7, 7}},
        {m68k_op_suba_16_di, 0xf1f8, 0x90e8, {16, 16, 7, 7, 7}},
        {m68k_op_suba_16_ix, 0xf1f8, 0x90f0, {18, 18, 9, 9, 9}},
        {m68k_op_subx_8_rr, 0xf1f8, 0x9100, {4, 4, 2, 2, 2}},
        {m68k_op_subx_8_mm, 0xf1f8, 0x9108, {18, 18, 12, 12, 12}},
        {m68k_op_sub_8_re_ai, 0xf1f8, 0x9110, {12, 12, 8, 8, 8}},
        {m68k_op_sub_8_re_pi, 0xf1f8, 0x9118, {12, 12, 8, 8, 8}},
        {m68k_op_sub_8_re_pd, 0xf1f8, 0x9120, {14, 14, 9, 9, 9}},
        {m68k_op_sub_8_re_di, 0xf1f8, 0x9128, {16, 16, 9, 9, 9}},
        {m68k_op_sub_8_re_ix, 0xf1f8, 0x9130, {18, 18, 11, 11, 11}},
        {m68k_op_subx_16_rr, 0xf1f8, 0x9140, {4, 4, 2, 2, 2}},
        {m68k_op_subx_16_mm, 0xf1f8, 0x9148, {18, 18, 12, 12, 12}},
        {m68k_op_sub_16_re_ai, 0xf1f8, 0x9150, {12, 12, 8, 8, 8}},
        {m68k_op_sub_16_re_pi, 0xf1f8, 0x9158, {12, 12, 8, 8, 8}},
        {m68k_op_sub_16_re_pd, 0xf1f8, 0x9160, {14, 14, 9, 9, 9}},
        {m68k_op_sub_16_re_di, 0xf1f8, 0x9168, {16, 16, 9, 9, 9}},
        {m68k_op_sub_16_re_ix, 0xf1f8, 0x9170, {18, 18, 11, 11, 11}},
        {m68k_op_subx_32_rr, 0xf1f8, 0x9180, {8, 6, 2, 2, 2}},
        {m68k_op_subx_32_mm, 0xf1f8, 0x9188, {30, 30, 12, 12, 12}},
        {m68k_op_sub_32_re_ai, 0xf1f8, 0x9190, {20, 20, 8, 8, 8}},
        {m68k_op_sub_32_re_pi, 0xf1f8, 0x9198, {20, 20, 8, 8, 8}},
        {m68k_op_sub_32_re_pd, 0xf1f8, 0x91a0, {22, 22, 9, 9, 9}},
        {m68k_op_sub_32_re_di, 0xf1f8, 0x91a8, {24, 24, 9, 9, 9}},
        {m68k_op_sub_32_re_ix, 0xf1f8, 0x91b0, {26, 26, 11, 11, 11}},
        {m68k_op_suba_32_d, 0xf1f8, 0x91c0, {6, 6, 2, 2, 2}},
        {m68k_op_suba_32_a, 0xf1f8, 0x91c8, {6, 6, 2, 2, 2}},
        {m68k_op_suba_32_ai, 0xf1f8, 0x91d0, {14, 14, 6, 6, 6}},
        {m68k_op_suba_32_pi, 0xf1f8, 0x91d8, {14, 14, 6, 6, 6}},
        {m68k_op_suba_32_pd, 0xf1f8, 0x91e0, {16, 16, 7, 7, 7}},
        {m68k_op_suba_32_di, 0xf1f8, 0x91e8, {18, 18, 7, 7, 7}},
        {m68k_op_suba_32_ix, 0xf1f8, 0x91f0, {20, 20, 9, 9, 9}},
        {m68k_op_cmp_8_d, 0xf1f8, 0xb000, {4, 4, 2, 2, 2}},
        {m68k_op_cmp_8_ai, 0xf1f8, 0xb010, {8, 8, 6, 6, 6}},
        {m68k_op_cmp_8_pi, 0xf1f8, 0xb018, {8, 8, 6, 6, 6}},
        {m68k_op_cmp_8_pd, 0xf1f8, 0xb020, {10, 10, 7, 7, 7}},
        {m68k_op_cmp_8_di, 0xf1f8, 0xb028, {12, 12, 7, 7, 7}},
        {m68k_op_cmp_8_ix, 0xf1f8, 0xb030, {14, 14, 9, 9, 9}},
        {m68k_op_cmp_16_d, 0xf1f8, 0xb040, {4, 4, 2, 2, 2}},
        {m68k_op_cmp_16_a, 0xf1f8, 0xb048, {4, 4, 2, 2, 2}},
        {m68k_op_cmp_16_ai, 0xf1f8, 0xb050, {8, 8, 6, 6, 6}},
        {m68k_op_cmp_16_pi, 0xf1f8, 0xb058, {8, 8, 6, 6, 6}},
        {m68k_op_cmp_16_pd, 0xf1f8, 0xb060, {10, 10, 7, 7, 7}},
        {m68k_op_cmp_16_di, 0xf1f8, 0xb068, {12, 12, 7, 7, 7}},
        {m68k_op_cmp_16_ix, 0xf1f8, 0xb070, {14, 14, 9, 9, 9}},
        {m68k_op_cmp_32_d, 0xf1f8, 0xb080, {6, 6, 2, 2, 2}},
        {m68k_op_cmp_32_a, 0xf1f8, 0xb088, {6, 6, 2, 2, 2}},
        {m68k_op_cmp_32_ai, 0xf1f8, 0xb090, {14, 14, 6, 6, 6}},
        {m68k_op_cmp_32_pi, 0xf1f8, 0xb098, {14, 14, 6, 6, 6}},
        {m68k_op_cmp_32_pd, 0xf1f8, 0xb0a0, {16, 16, 7, 7, 7}},
        {m68k_op_cmp_32_di, 0xf1f8, 0xb0a8, {18, 18, 7, 7, 7}},
        {m68k_op_cmp_32_ix, 0xf1f8, 0xb0b0, {20, 20, 9, 9, 9}},
        {m68k_op_cmpa_16_d, 0xf1f8, 0xb0c0, {6, 6, 4, 4, 4}},
        {m68k_op_cmpa_16_a, 0xf1f8, 0xb0c8, {6, 6, 4, 4, 4}},
        {m68k_op_cmpa_16_ai, 0xf1f8, 0xb0d0, {10, 10, 8, 8, 8}},
        {m68k_op_cmpa_16_pi, 0xf1f8, 0xb0d8, {10, 10, 8, 8, 8}},
        {m68k_op_cmpa_16_pd, 0xf1f8, 0xb0e0, {12, 12, 9, 9, 9}},
        {m68k_op_cmpa_16_di, 0xf1f8, 0xb0e8, {14, 14, 9, 9, 9}},
        {m68k_op_cmpa_16_ix, 0xf1f8, 0xb0f0, {16, 16, 11, 11, 11}},
        {m68k_op_eor_8_d, 0xf1f8, 0xb100, {4, 4, 2, 2, 2}},
        {m68k_op_cmpm_8, 0xf1f8, 0xb108, {12, 12, 9, 9, 9}},
        {m68k_op_eor_8_ai, 0xf1f8, 0xb110, {12, 12, 8, 8, 8}},
        {m68k_op_eor_8_pi, 0xf1f8, 0xb118, {12, 12, 8, 8, 8}},
        {m68k_op_eor_8_pd, 0xf1f8, 0xb120, {14, 14, 9, 9, 9}},
        {m68k_op_eor_8_di, 0xf1f8, 0xb128, {16, 16, 9, 9, 9}},
        {m68k_op_eor_8_ix, 0xf1f8, 0xb130, {18, 18, 11, 11, 11}},
        {m68k_op_eor_16_d, 0xf1f8, 0xb140, {4, 4, 2, 2, 2}},
        {m68k_op_cmpm_16, 0xf1f8, 0xb148, {12, 12, 9, 9, 9}},
        {m68k_op_eor_16_ai, 0xf1f8, 0xb150, {12, 12, 8, 8, 8}},
        {m68k_op_eor_16_pi, 0xf1f8, 0xb158, {12, 12, 8, 8, 8}},
        {m68k_op_eor_16_pd, 0xf1f8, 0xb160, {14, 14, 9, 9, 9}},
        {m68k_op_eor_16_di, 0xf1f8, 0xb168, {16, 16, 9, 9, 9}},
        {m68k_op_eor_16_ix, 0xf1f8, 0xb170, {18, 18, 11, 11, 11}},
        {m68k_op_eor_32_d, 0xf1f8, 0xb180, {8, 6, 2, 2, 2}},
        {m68k_op_cmpm_32, 0xf1f8, 0xb188, {20, 20, 9, 9, 9}},
        {m68k_op_eor_32_ai, 0xf1f8, 0xb190, {20, 20, 8, 8, 8}},
        {m68k_op_eor_32_pi, 0xf1f8, 0xb198, {20, 20, 8, 8, 8}},
        {m68k_op_eor_32_pd, 0xf1f8, 0xb1a0, {22, 22, 9, 9, 9}},
        {m68k_op_eor_32_di, 0xf1f8, 0xb1a8, {24, 24, 9, 9, 9}},
        {m68k_op_eor_32_ix, 0xf1f8, 0xb1b0, {26, 26, 11, 11, 11}},
        {m68k_op_cmpa_32_d, 0xf1f8, 0xb1c0, {6, 6, 4, 4, 4}},
        {m68k_op_cmpa_32_a, 0xf1f8, 0xb1c8, {6, 6, 4, 4, 4}},
        {m68k_op_cmpa_32_ai, 0xf1f8, 0xb1d0, {14, 14, 8, 8, 8}},
        {m68k_op_cmpa_32_pi, 0xf1f8, 0xb1d8, {14, 14, 8, 8, 8}},
        {m68k_op_cmpa_32_pd, 0xf1f8, 0xb1e0, {16, 16, 9, 9, 9}},
        {m68k_op_cmpa_32_di, 0xf1f8, 0xb1e8, {18, 18, 9, 9, 9}},
        {m68k_op_cmpa_32_ix, 0xf1f8, 0xb1f0, {20, 20, 11, 11, 11}},
        {m68k_op_and_8_er_d, 0xf1f8, 0xc000, {4, 4, 2, 2, 2}},
        {m68k_op_and_8_er_ai, 0xf1f8, 0xc010, {8, 8, 6, 6, 6}},
        {m68k_op_and_8_er_pi, 0xf1f8, 0xc018, {8, 8, 6, 6, 6}},
        {m68k_op_and_8_er_pd, 0xf1f8, 0xc020, {10, 10, 7, 7, 7}},
        {m68k_op_and_8_er_di, 0xf1f8, 0xc028, {12, 12, 7, 7, 7}},
        {m68k_op_and_8_er_ix, 0xf1f8, 0xc030, {14, 14, 9, 9, 9}},
        {m68k_op_and_16_er_d, 0xf1f8, 0xc040, {4, 4, 2, 2, 2}},
        {m68k_op_and_16_er_ai, 0xf1f8, 0xc050, {8, 8, 6, 6, 6}},
        {m68k_op_and_16_er_pi, 0xf1f8, 0xc058, {8, 8, 6, 6, 6}},
        {m68k_op_and_16_er_pd, 0xf1f8, 0xc060, {10, 10, 7, 7, 7}},
        {m68k_op_and_16_er_di, 0xf1f8, 0xc068, {12, 12, 7, 7, 7}},
        {m68k_op_and_16_er_ix, 0xf1f8, 0xc070, {14, 14, 9, 9, 9}},
        {m68k_op_and_32_er_d, 0xf1f8, 0xc080, {6, 6, 2, 2, 2}},
        {m68k_op_and_32_er_ai, 0xf1f8, 0xc090, {14, 14, 6, 6, 6}},
        {m68k_op_and_32_er_pi, 0xf1f8, 0xc098, {14, 14, 6, 6, 6}},
        {m68k_op_and_32_er_pd, 0xf1f8, 0xc0a0, {16, 16, 7, 7, 7}},
        {m68k_op_and_32_er_di, 0xf1f8, 0xc0a8, {18, 18, 7, 7, 7}},
        {m68k_op_and_32_er_ix, 0xf1f8, 0xc0b0, {20, 20, 9, 9, 9}},
        {m68k_op_mulu_16_d, 0xf1f8, 0xc0c0, {38, 30, 27, 27, 27}},
        {m68k_op_mulu_16_ai, 0xf1f8, 0xc0d0, {42, 34, 31, 31, 31}},
        {m68k_op_mulu_16_pi, 0xf1f8, 0xc0d8, {42, 34, 31, 31, 31}},
        {m68k_op_mulu_16_pd, 0xf1f8, 0xc0e0, {44, 36, 32, 32, 32}},
        {m68k_op_mulu_16_di, 0xf1f8, 0xc0e8, {46, 38, 32, 32, 32}},
        {m68k_op_mulu_16_ix, 0xf1f8, 0xc0f0, {48, 40, 34, 34, 34}},
        {m68k_op_abcd_8_rr, 0xf1f8, 0xc100, {6, 6, 4, 4, 4}},
        {m68k_op_abcd_8_mm, 0xf1f8, 0xc108, {18, 18, 16, 16, 16}},
        {m68k_op_and_8_re_ai, 0xf1f8, 0xc110, {12, 12, 8, 8, 8}},
        {m68k_op_and_8_re_pi, 0xf1f8, 0xc118, {12, 12, 8, 8, 8}},
        {m68k_op_and_8_re_pd, 0xf1f8, 0xc120, {14, 14, 9, 9, 9}},
        {m68k_op_and_8_re_di, 0xf1f8, 0xc128, {16, 16, 9, 9, 9}},
        {m68k_op_and_8_re_ix, 0xf1f8, 0xc130, {18, 18, 11, 11, 11}},
        {m68k_op_exg_32_dd, 0xf1f8, 0xc140, {6, 6, 2, 2, 2}},
        {m68k_op_exg_32_aa, 0xf1f8, 0xc148, {6, 6, 2, 2, 2}},
        {m68k_op_and_16_re_ai, 0xf1f8, 0xc150, {12, 12, 8, 8, 8}},
        {m68k_op_and_16_re_pi, 0xf1f8, 0xc158, {12, 12, 8, 8, 8}},
        {m68k_op_and_16_re_pd, 0xf1f8, 0xc160, {14, 14, 9, 9, 9}},
        {m68k_op_and_16_re_di, 0xf1f8, 0xc168, {16, 16, 9, 9, 9}},
        {m68k_op_and_16_re_ix, 0xf1f8, 0xc170, {18, 18, 11, 11, 11}},
        {m68k_op_exg_32_da, 0xf1f8, 0xc188, {6, 6, 2, 2, 2}},
        {m68k_op_and_32_re_ai, 0xf1f8, 0xc190, {20, 20, 8, 8, 8}},
        {m68k_op_and_32_re_pi, 0xf1f8, 0xc198, {20, 20, 8, 8, 8}},
        {m68k_op_and_32_re_pd, 0xf1f8, 0xc1a0, {22, 22, 9, 9, 9}},
        {m68k_op_and_32_re_di, 0xf1f8, 0xc1a8, {24, 24, 9, 9, 9}},
        {m68k_op_and_32_re_ix, 0xf1f8, 0xc1b0, {26, 26, 11, 11, 11}},
        {m68k_op_muls_16_d, 0xf1f8, 0xc1c0, {38, 32, 27, 27, 27}},
        {m68k_op_muls_16_ai, 0xf1f8, 0xc1d0, {42, 36, 31, 31, 31}},
        {m68k_op_muls_16_pi, 0xf1f8, 0xc1d8, {42, 36, 31, 31, 31}},
        {m68k_op_muls_16_pd, 0xf1f8, 0xc1e0, {44, 38, 32, 32, 32}},
        {m68k_op_muls_16_di, 0xf1f8, 0xc1e8, {46, 40, 32, 32, 32}},
        {m68k_op_muls_16_ix, 0xf1f8, 0xc1f0, {48, 42, 34, 34, 34}},
        {m68k_op_add_8_er_d, 0xf1f8, 0xd000, {4, 4, 2, 2, 2}},
        {m68k_op_add_8_er_ai, 0xf1f8, 0xd010, {8, 8, 6, 6, 6}},
        {m68k_op_add_8_er_pi, 0xf1f8, 0xd018, {8, 8, 6, 6, 6}},
        {m68k_op_add_8_er_pd, 0xf1f8, 0xd020, {10, 10, 7, 7, 7}},
        {m68k_op_add_8_er_di, 0xf1f8, 0xd028, {12, 12, 7, 7, 7}},
        {m68k_op_add_8_er_ix, 0xf1f8, 0xd030, {14, 14, 9, 9, 9}},
        {m68k_op_add_16_er_d, 0xf1f8, 0xd040, {4, 4, 2, 2, 2}},
        {m68k_op_add_16_er_a, 0xf1f8, 0xd048, {4, 4, 2, 2, 2}},
        {m68k_op_add_16_er_ai, 0xf1f8, 0xd050, {8, 8, 6, 6, 6}},
        {m68k_op_add_16_er_pi, 0xf1f8, 0xd058, {8, 8, 6, 6, 6}},
        {m68k_op_add_16_er_pd, 0xf1f8, 0xd060, {10, 10, 7, 7, 7}},
        {m68k_op_add_16_er_di, 0xf1f8, 0xd068, {12, 12, 7, 7, 7}},
        {m68k_op_add_16_er_ix, 0xf1f8, 0xd070, {14, 14, 9, 9, 9}},
        {m68k_op_add_32_er_d, 0xf1f8, 0xd080, {6, 6, 2, 2, 2}},
        {m68k_op_add_32_er_a, 0xf1f8, 0xd088, {6, 6, 2, 2, 2}},
        {m68k_op_add_32_er_ai, 0xf1f8, 0xd090, {14, 14, 6, 6, 6}},
        {m68k_op_add_32_er_pi, 0xf1f8, 0xd098, {14, 14, 6, 6, 6}},
        {m68k_op_add_32_er_pd, 0xf1f8, 0xd0a0, {16, 16, 7, 7, 7}},
        {m68k_op_add_32_er_di, 0xf1f8, 0xd0a8, {18, 18, 7, 7, 7}},
        {m68k_op_add_32_er_ix, 0xf1f8, 0xd0b0, {20, 20, 9, 9, 9}},
        {m68k_op_adda_16_d, 0xf1f8, 0xd0c0, {8, 8, 2, 2, 2}},
        {m68k_op_adda_16_a, 0xf1f8, 0xd0c8, {8, 8, 2, 2, 2}},
        {m68k_op_adda_16_ai, 0xf1f8, 0xd0d0, {12, 12, 6, 6, 6}},
        {m68k_op_adda_16_pi, 0xf1f8, 0xd0d8, {12, 12, 6, 6, 6}},
        {m68k_op_adda_16_pd, 0xf1f8, 0xd0e0, {14, 14, 7, 7, 7}},
        {m68k_op_adda_16_di, 0xf1f8, 0xd0e8, {16, 16, 7, 7, 7}},
        {m68k_op_adda_16_ix, 0xf1f8, 0xd0f0, {18, 18, 9, 9, 9}},
        {m68k_op_addx_8_rr, 0xf1f8, 0xd100, {4, 4, 2, 2, 2}},
        {m68k_op_addx_8_mm, 0xf1f8, 0xd108, {18, 18, 12, 12, 12}},
        {m68k_op_add_8_re_ai, 0xf1f8, 0xd110, {12, 12, 8, 8, 8}},
        {m68k_op_add_8_re_pi, 0xf1f8, 0xd118, {12, 12, 8, 8, 8}},
        {m68k_op_add_8_re_pd, 0xf1f8, 0xd120, {14, 14, 9, 9, 9}},
        {m68k_op_add_8_re_di, 0xf1f8, 0xd128, {16, 16, 9, 9, 9}},
        {m68k_op_add_8_re_ix, 0xf1f8, 0xd130, {18, 18, 11, 11, 11}},
        {m68k_op_addx_16_rr, 0xf1f8, 0xd140, {4, 4, 2, 2, 2}},
        {m68k_op_addx_16_mm, 0xf1f8, 0xd148, {18, 18, 12, 12, 12}},
        {m68k_op_add_16_re_ai, 0xf1f8, 0xd150, {12, 12, 8, 8, 8}},
        {m68k_op_add_16_re_pi, 0xf1f8, 0xd158, {12, 12, 8, 8, 8}},
        {m68k_op_add_16_re_pd, 0xf1f8, 0xd160, {14, 14, 9, 9, 9}},
        {m68k_op_add_16_re_di, 0xf1f8, 0xd168, {16, 16, 9, 9, 9}},
        {m68k_op_add_16_re_ix, 0xf1f8, 0xd170, {18, 18, 11, 11, 11}},
        {m68k_op_addx_32_rr, 0xf1f8, 0xd180, {8, 6, 2, 2, 2}},
        {m68k_op_addx_32_mm, 0xf1f8, 0xd188, {30, 30, 12, 12, 12}},
        {m68k_op_add_32_re_ai, 0xf1f8, 0xd190, {20, 20, 8, 8, 8}},
        {m68k_op_add_32_re_pi, 0xf1f8, 0xd198, {20, 20, 8, 8, 8}},
        {m68k_op_add_32_re_pd, 0xf1f8, 0xd1a0, {22, 22, 9, 9, 9}},
        {m68k_op_add_32_re_di, 0xf1f8, 0xd1a8, {24, 24, 9, 9, 9}},
        {m68k_op_add_32_re_ix, 0xf1f8, 0xd1b0, {26, 26, 11, 11, 11}},
        {m68k_op_adda_32_d, 0xf1f8, 0xd1c0, {6, 6, 2, 2, 2}},
        {m68k_op_adda_32_a, 0xf1f8, 0xd1c8, {6, 6, 2, 2, 2}},
        {m68k_op_adda_32_ai, 0xf1f8, 0xd1d0, {14, 14, 6, 6, 6}},
        {m68k_op_adda_32_pi, 0xf1f8, 0xd1d8, {14, 14, 6, 6, 6}},
        {m68k_op_adda_32_pd, 0xf1f8, 0xd1e0, {16, 16, 7, 7, 7}},
        {m68k_op_adda_32_di, 0xf1f8, 0xd1e8, {18, 18, 7, 7, 7}},
        {m68k_op_adda_32_ix, 0xf1f8, 0xd1f0, {20, 20, 9, 9, 9}},
        {m68k_op_asr_8_s, 0xf1f8, 0xe000, {6, 6, 6, 6, 6}},
        {m68k_op_lsr_8_s, 0xf1f8, 0xe008, {6, 6, 4, 4, 4}},
        {m68k_op_roxr_8_s, 0xf1f8, 0xe010, {6, 6, 12, 12, 12}},
        {m68k_op_ror_8_s, 0xf1f8, 0xe018, {6, 6, 8, 8, 8}},
        {m68k_op_asr_8_r, 0xf1f8, 0xe020, {6, 6, 6, 6, 6}},
        {m68k_op_lsr_8_r, 0xf1f8, 0xe028, {6, 6, 6, 6, 6}},
        {m68k_op_roxr_8_r, 0xf1f8, 0xe030, {6, 6, 12, 12, 12}},
        {m68k_op_ror_8_r, 0xf1f8, 0xe038, {6, 6, 8, 8, 8}},
        {m68k_op_asr_16_s, 0xf1f8, 0xe040, {6, 6, 6, 6, 6}},
        {m68k_op_lsr_16_s, 0xf1f8, 0xe048, {6, 6, 4, 4, 4}},
        {m68k_op_roxr_16_s, 0xf1f8, 0xe050, {6, 6, 12, 12, 12}},
        {m68k_op_ror_16_s, 0xf1f8, 0xe058, {6, 6, 8, 8, 8}},
        {m68k_op_asr_16_r, 0xf1f8, 0xe060, {6, 6, 6, 6, 6}},
        {m68k_op_lsr_16_r, 0xf1f8, 0xe068, {6, 6, 6, 6, 6}},
        {m68k_op_roxr_16_r, 0xf1f8, 0xe070, {6, 6, 12, 12, 12}},
        {m68k_op_ror_16_r, 0xf1f8, 0xe078, {6, 6, 8, 8, 8}},
        {m68k_op_asr_32_s, 0xf1f8, 0xe080, {8, 8, 6, 6, 6}},
        {m68k_op_lsr_32_s, 0xf1f8, 0xe088, {8, 8, 4, 4, 4}},
        {m68k_op_roxr_32_s, 0xf1f8, 0xe090, {8, 8, 12, 12, 12}},
        {m68k_op_ror_32_s, 0xf1f8, 0xe098, {8, 8, 8, 8, 8}},
        {m68k_op_asr_32_r, 0xf1f8, 0xe0a0, {8, 8, 6, 6, 6}},
        {m68k_op_lsr_32_r, 0xf1f8, 0xe0a8, {8, 8, 6, 6, 6}},
        {m68k_op_roxr_32_r, 0xf1f8, 0xe0b0, {8, 8, 12, 12, 12}},
        {m68k_op_ror_32_r, 0xf1f8, 0xe0b8, {8, 8, 8, 8, 8}},
        {m68k_op_asl_8_s, 0xf1f8, 0xe100, {6, 6, 8, 8, 8}},
        {m68k_op_lsl_8_s, 0xf1f8, 0xe108, {6, 6, 4, 4, 4}},
        {m68k_op_roxl_8_s, 0xf1f8, 0xe110, {6, 6, 12, 12, 12}},
        {m68k_op_rol_8_s, 0xf1f8, 0xe118, {6, 6, 8, 8, 8}},
        {m68k_op_asl_8_r, 0xf1f8, 0xe120, {6, 6, 8, 8, 8}},
        {m68k_op_lsl_8_r, 0xf1f8, 0xe128, {6, 6, 6, 6, 6}},
        {m68k_op_roxl_8_r, 0xf1f8, 0xe130, {6, 6, 12, 12, 12}},
        {m68k_op_rol_8_r, 0xf1f8, 0xe138, {6, 6, 8, 8, 8}},
        {m68k_op_asl_16_s, 0xf1f8, 0xe140, {6, 6, 8, 8, 8}},
        {m68k_op_lsl_16_s, 0xf1f8, 0xe148, {6, 6, 4, 4, 4}},
        {m68k_op_roxl_16_s, 0xf1f8, 0xe150, {6, 6, 12, 12, 12}},
        {m68k_op_rol_16_s, 0xf1f8, 0xe158, {6, 6, 8, 8, 8}},
        {m68k_op_asl_16_r, 0xf1f8, 0xe160, {6, 6, 8, 8, 8}},
        {m68k_op_lsl_16_r, 0xf1f8, 0xe168, {6, 6, 6, 6, 6}},
        {m68k_op_roxl_16_r, 0xf1f8, 0xe170, {6, 6, 12, 12, 12}},
        {m68k_op_rol_16_r, 0xf1f8, 0xe178, {6, 6, 8, 8, 8}},
        {m68k_op_asl_32_s, 0xf1f8, 0xe180, {8, 8, 8, 8, 8}},
        {m68k_op_lsl_32_s, 0xf1f8, 0xe188, {8, 8, 4, 4, 4}},
        {m68k_op_roxl_32_s, 0xf1f8, 0xe190, {8, 8, 12, 12, 12}},
        {m68k_op_rol_32_s, 0xf1f8, 0xe198, {8, 8, 8, 8, 8}},
        {m68k_op_asl_32_r, 0xf1f8, 0xe1a0, {8, 8, 8, 8, 8}},
        {m68k_op_lsl_32_r, 0xf1f8, 0xe1a8, {8, 8, 6, 6, 6}},
        {m68k_op_roxl_32_r, 0xf1f8, 0xe1b0, {8, 8, 12, 12, 12}},
        {m68k_op_rol_32_r, 0xf1f8, 0xe1b8, {8, 8, 8, 8, 8}},
        {m68k_op_cpdbcc_32, 0xf1f8, 0xf048, {0, 0, 4, 4, 0}},
        {m68k_op_cptrapcc_32, 0xf1f8, 0xf078, {0, 0, 4, 4, 0}},
        {m68k_op_rtm_32, 0xfff0, 0x06c0, {0, 0, 19, 19, 19}},
        {m68k_op_trap, 0xfff0, 0x4e40, {4, 4, 4, 4, 4}},
        {m68k_op_btst_8_r_pi7, 0xf1ff, 0x011f, {8, 8, 8, 8, 8}},
        {m68k_op_btst_8_r_pd7, 0xf1ff, 0x0127, {10, 10, 9, 9, 9}},
        {m68k_op_btst_8_r_aw, 0xf1ff, 0x0138, {12, 12, 8, 8, 8}},
        {m68k_op_btst_8_r_al, 0xf1ff, 0x0139, {16, 16, 8, 8, 8}},
        {m68k_op_btst_8_r_pcdi, 0xf1ff, 0x013a, {12, 12, 9, 9, 9}},
        {m68k_op_btst_8_r_pcix, 0xf1ff, 0x013b, {14, 14, 11, 11, 11}},
        {m68k_op_btst_8_r_i, 0xf1ff, 0x013c, {8, 8, 6, 6, 6}},
        {m68k_op_bchg_8_r_pi7, 0xf1ff, 0x015f, {12, 12, 8, 8, 8}},
        {m68k_op_bchg_8_r_pd7, 0xf1ff, 0x0167, {14, 14, 9, 9, 9}},
        {m68k_op_bchg_8_r_aw, 0xf1ff, 0x0178, {16, 16, 8, 8, 8}},
        {m68k_op_bchg_8_r_al, 0xf1ff, 0x0179, {20, 20, 8, 8, 8}},
        {m68k_op_bclr_8_r_pi7, 0xf1ff, 0x019f, {12, 14, 8, 8, 8}},
        {m68k_op_bclr_8_r_pd7, 0xf1ff, 0x01a7, {14, 16, 9, 9, 9}},
        {m68k_op_bclr_8_r_aw, 0xf1ff, 0x01b8, {16, 18, 8, 8, 8}},
        {m68k_op_bclr_8_r_al, 0xf1ff, 0x01b9, {20, 22, 8, 8, 8}},
        {m68k_op_bset_8_r_pi7, 0xf1ff, 0x01df, {12, 12, 8, 8, 8}},
        {m68k_op_bset_8_r_pd7, 0xf1ff, 0x01e7, {14, 14, 9, 9, 9}},
        {m68k_op_bset_8_r_aw, 0xf1ff, 0x01f8, {16, 16, 8, 8, 8}},
        {m68k_op_bset_8_r_al, 0xf1ff, 0x01f9, {20, 20, 8, 8, 8}},
        {m68k_op_move_8_d_pi7, 0xf1ff, 0x101f, {8, 8, 6, 6, 6}},
        {m68k_op_move_8_d_pd7, 0xf1ff, 0x1027, {10, 10, 7, 7, 7}},
        {m68k_op_move_8_d_aw, 0xf1ff, 0x1038, {12, 12, 6, 6, 6}},
        {m68k_op_move_8_d_al, 0xf1ff, 0x1039, {16, 16, 6, 6, 6}},
        {m68k_op_move_8_d_pcdi, 0xf1ff, 0x103a, {12, 12, 7, 7, 7}},
        {m68k_op_move_8_d_pcix, 0xf1ff, 0x103b, {14, 14, 9, 9, 9}},
        {m68k_op_move_8_d_i, 0xf1ff, 0x103c, {8, 8, 4, 4, 4}},
        {m68k_op_move_8_ai_pi7, 0xf1ff, 0x109f, {12, 12, 8, 8, 8}},
        {m68k_op_move_8_ai_pd7, 0xf1ff, 0x10a7, {14, 14, 9, 9, 9}},
        {m68k_op_move_8_ai_aw, 0xf1ff, 0x10b8, {16, 16, 8, 8, 8}},
        {m68k_op_move_8_ai_al, 0xf1ff, 0x10b9, {20, 20, 8, 8, 8}},
        {m68k_op_move_8_ai_pcdi, 0xf1ff, 0x10ba, {16, 16, 9, 9, 9}},
        {m68k_op_move_8_ai_pcix, 0xf1ff, 0x10bb, {18, 18, 11, 11, 11}},
        {m68k_op_move_8_ai_i, 0xf1ff, 0x10bc, {12, 12, 6, 6, 6}},
        {m68k_op_move_8_pi_pi7, 0xf1ff, 0x10df, {12, 12, 8, 8, 8}},
        {m68k_op_move_8_pi_pd7, 0xf1ff, 0x10e7, {14, 14, 9, 9, 9}},
        {m68k_op_move_8_pi_aw, 0xf1ff, 0x10f8, {16, 16, 8, 8, 8}},
        {m68k_op_move_8_pi_al, 0xf1ff, 0x10f9, {20, 20, 8, 8, 8}},
        {m68k_op_move_8_pi_pcdi, 0xf1ff, 0x10fa, {16, 16, 9, 9, 9}},
        {m68k_op_move_8_pi_pcix, 0xf1ff, 0x10fb, {18, 18, 11, 11, 11}},
        {m68k_op_move_8_pi_i, 0xf1ff, 0x10fc, {12, 12, 6, 6, 6}},
        {m68k_op_move_8_pd_pi7, 0xf1ff, 0x111f, {12, 12, 9, 9, 9}},
        {m68k_op_move_8_pd_pd7, 0xf1ff, 0x1127, {14, 14, 10, 10, 10}},
        {m68k_op_move_8_pd_aw, 0xf1ff, 0x1138, {16, 16, 9, 9, 9}},
        {m68k_op_move_8_pd_al, 0xf1ff, 0x1139, {20, 20, 9, 9, 9}},
        {m68k_op_move_8_pd_pcdi, 0xf1ff, 0x113a, {16, 16, 10, 10, 10}},
        {m68k_op_move_8_pd_pcix, 0xf1ff, 0x113b, {18, 18, 12, 12, 12}},
        {m68k_op_move_8_pd_i, 0xf1ff, 0x113c, {12, 12, 7, 7, 7}},
        {m68k_op_move_8_di_pi7, 0xf1ff, 0x115f, {16, 16, 9, 9, 9}},
        {m68k_op_move_8_di_pd7, 0xf1ff, 0x1167, {18, 18, 10, 10, 10}},
        {m68k_op_move_8_di_aw, 0xf1ff, 0x1178, {20, 20, 9, 9, 9}},
        {m68k_op_move_8_di_al, 0xf1ff, 0x1179, {24, 24, 9, 9, 9}},
        {m68k_op_move_8_di_pcdi, 0xf1ff, 0x117a, {20, 20, 10, 10, 10}},
        {m68k_op_move_8_di_pcix, 0xf1ff, 0x117b, {22, 22, 12, 12, 12}},
        {m68k_op_move_8_di_i, 0xf1ff, 0x117c, {16, 16, 7, 7, 7}},
        {m68k_op_move_8_ix_pi7, 0xf1ff, 0x119f, {18, 18, 11, 11, 11}},
        {m68k_op_move_8_ix_pd7, 0xf1ff, 0x11a7, {20, 20, 12, 12, 12}},
        {m68k_op_move_8_ix_aw, 0xf1ff, 0x11b8, {22, 22, 11, 11, 11}},
        {m68k_op_move_8_ix_al, 0xf1ff, 0x11b9, {26, 26, 11, 11, 11}},
        {m68k_op_move_8_ix_pcdi, 0xf1ff, 0x11ba, {22, 22, 12, 12, 12}},
        {m68k_op_move_8_ix_pcix, 0xf1ff, 0x11bb, {24, 24, 14, 14, 14}},
        {m68k_op_move_8_ix_i, 0xf1ff, 0x11bc, {18, 18, 9, 9, 9}},
        {m68k_op_move_32_d_aw, 0xf1ff, 0x2038, {16, 16, 6, 6, 6}},
        {m68k_op_move_32_d_al, 0xf1ff, 0x2039, {20, 20, 6, 6, 6}},
        {m68k_op_move_32_d_pcdi, 0xf1ff, 0x203a, {16, 16, 7, 7, 7}},
        {m68k_op_move_32_d_pcix, 0xf1ff, 0x203b, {18, 18, 9, 9, 9}},
        {m68k_op_move_32_d_i, 0xf1ff, 0x203c, {12, 12, 6, 6, 6}},
        {m68k_op_movea_32_aw, 0xf1ff, 0x2078, {16, 16, 6, 6, 6}},
        {m68k_op_movea_32_al, 0xf1ff, 0x2079, {20, 20, 6, 6, 6}},
        {m68k_op_movea_32_pcdi, 0xf1ff, 0x207a, {16, 16, 7, 7, 7}},
        {m68k_op_movea_32_pcix, 0xf1ff, 0x207b, {18, 18, 9, 9, 9}},
        {m68k_op_movea_32_i, 0xf1ff, 0x207c, {12, 12, 6, 6, 6}},
        {m68k_op_move_32_ai_aw, 0xf1ff, 0x20b8, {24, 24, 8, 8, 8}},
        {m68k_op_move_32_ai_al, 0xf1ff, 0x20b9, {28, 28, 8, 8, 8}},
        {m68k_op_move_32_ai_pcdi, 0xf1ff, 0x20ba, {24, 24, 9, 9, 9}},
        {m68k_op_move_32_ai_pcix, 0xf1ff, 0x20bb, {26, 26, 11, 11, 11}},
        {m68k_op_move_32_ai_i, 0xf1ff, 0x20bc, {20, 20, 8, 8, 8}},
        {m68k_op_move_32_pi_aw, 0xf1ff, 0x20f8, {24, 24, 8, 8, 8}},
        {m68k_op_move_32_pi_al, 0xf1ff, 0x20f9, {28, 28, 8, 8, 8}},
        {m68k_op_move_32_pi_pcdi, 0xf1ff, 0x20fa, {24, 24, 9, 9, 9}},
        {m68k_op_move_32_pi_pcix, 0xf1ff, 0x20fb, {26, 26, 11, 11, 11}},
        {m68k_op_move_32_pi_i, 0xf1ff, 0x20fc, {20, 20, 8, 8, 8}},
        {m68k_op_move_32_pd_aw, 0xf1ff, 0x2138, {24, 26, 9, 9, 9}},
        {m68k_op_move_32_pd_al, 0xf1ff, 0x2139, {28, 30, 9, 9, 9}},
        {m68k_op_move_32_pd_pcdi, 0xf1ff, 0x213a, {24, 26, 10, 10, 10}},
        {m68k_op_move_32_pd_pcix, 0xf1ff, 0x213b, {26, 28, 12, 12, 12}},
        {m68k_op_move_32_pd_i, 0xf1ff, 0x213c, {20, 22, 9, 9, 9}},
        {m68k_op_move_32_di_aw, 0xf1ff, 0x2178, {28, 28, 9, 9, 9}},
        {m68k_op_move_32_di_al, 0xf1ff, 0x2179, {32, 32, 9, 9, 9}},
        {m68k_op_move_32_di_pcdi, 0xf1ff, 0x217a, {28, 28, 10, 10, 10}},
        {m68k_op_move_32_di_pcix, 0xf1ff, 0x217b, {30, 30, 12, 12, 12}},
        {m68k_op_move_32_di_i, 0xf1ff, 0x217c, {24, 24, 9, 9, 9}},
        {m68k_op_move_32_ix_aw, 0xf1ff, 0x21b8, {30, 30, 11, 11, 11}},
        {m68k_op_move_32_ix_al, 0xf1ff, 0x21b9, {34, 34, 11, 11, 11}},
        {m68k_op_move_32_ix_pcdi, 0xf1ff, 0x21ba, {30, 30, 12, 12, 12}},
        {m68k_op_move_32_ix_pcix, 0xf1ff, 0x21bb, {32, 32, 14, 14, 14}},
        {m68k_op_move_32_ix_i, 0xf1ff, 0x21bc, {26, 26, 11, 11, 11}},
        {m68k_op_move_16_d_aw, 0xf1ff, 0x3038, {12, 12, 6, 6, 6}},
        {m68k_op_move_16_d_al, 0xf1ff, 0x3039, {16, 16, 6, 6, 6}},
        {m68k_op_move_16_d_pcdi, 0xf1ff, 0x303a, {12, 12, 7, 7, 7}},
        {m68k_op_move_16_d_pcix, 0xf1ff, 0x303b, {14, 14, 9, 9, 9}},
        {m68k_op_move_16_d_i, 0xf1ff, 0x303c, {8, 8, 4, 4, 4}},
        {m68k_op_movea_16_aw, 0xf1ff, 0x3078, {12, 12, 6, 6, 6}},
        {m68k_op_movea_16_al, 0xf1ff, 0x3079, {16, 16, 6, 6, 6}},
        {m68k_op_movea_16_pcdi, 0xf1ff, 0x307a, {12, 12, 7, 7, 7}},
        {m68k_op_movea_16_pcix, 0xf1ff, 0x307b, {14, 14, 9, 9, 9}},
        {m68k_op_movea_16_i, 0xf1ff, 0x307c, {8, 8, 4, 4, 4}},
        {m68k_op_move_16_ai_aw, 0xf1ff, 0x30b8, {16, 16, 8, 8, 8}},
        {m68k_op_move_16_ai_al, 0xf1ff, 0x30b9, {20, 20, 8, 8, 8}},
        {m68k_op_move_16_ai_pcdi, 0xf1ff, 0x30ba, {16, 16, 9, 9, 9}},
        {m68k_op_move_16_ai_pcix, 0xf1ff, 0x30bb, {18, 18, 11, 11, 11}},
        {m68k_op_move_16_ai_i, 0xf1ff, 0x30bc, {12, 12, 6, 6, 6}},
        {m68k_op_move_16_pi_aw, 0xf1ff, 0x30f8, {16, 16, 8, 8, 8}},
        {m68k_op_move_16_pi_al, 0xf1ff, 0x30f9, {20, 20, 8, 8, 8}},
        {m68k_op_move_16_pi_pcdi, 0xf1ff, 0x30fa, {16, 16, 9, 9, 9}},
        {m68k_op_move_16_pi_pcix, 0xf1ff, 0x30fb, {18, 18, 11, 11, 11}},
        {m68k_op_move_16_pi_i, 0xf1ff, 0x30fc, {12, 12, 6, 6, 6}},
        {m68k_op_move_16_pd_aw, 0xf1ff, 0x3138, {16, 16, 9, 9, 9}},
        {m68k_op_move_16_pd_al, 0xf1ff, 0x3139, {20, 20, 9, 9, 9}},
        {m68k_op_move_16_pd_pcdi, 0xf1ff, 0x313a, {16, 16, 10, 10, 10}},
        {m68k_op_move_16_pd_pcix, 0xf1ff, 0x313b, {18, 18, 12, 12, 12}},
        {m68k_op_move_16_pd_i, 0xf1ff, 0x313c, {12, 12, 7, 7, 7}},
        {m68k_op_move_16_di_aw, 0xf1ff, 0x3178, {20, 20, 9, 9, 9}},
        {m68k_op_move_16_di_al, 0xf1ff, 0x3179, {24, 24, 9, 9, 9}},
        {m68k_op_move_16_di_pcdi, 0xf1ff, 0x317a, {20, 20, 10, 10, 10}},
        {m68k_op_move_16_di_pcix, 0xf1ff, 0x317b, {22, 22, 12, 12, 12}},
        {m68k_op_move_16_di_i, 0xf1ff, 0x317c, {16, 16, 7, 7, 7}},
        {m68k_op_move_16_ix_aw, 0xf1ff, 0x31b8, {22, 22, 11, 11, 11}},
        {m68k_op_move_16_ix_al, 0xf1ff, 0x31b9, {26, 26, 11, 11, 11}},
        {m68k_op_move_16_ix_pcdi, 0xf1ff, 0x31ba, {22, 22, 12, 12, 12}},
        {m68k_op_move_16_ix_pcix, 0xf1ff, 0x31bb, {24, 24, 14, 14, 14}},
        {m68k_op_move_16_ix_i, 0xf1ff, 0x31bc, {18, 18, 9, 9, 9}},
        {m68k_op_chk_32_aw, 0xf1ff, 0x4138, {0, 0, 12, 12, 12}},
        {m68k_op_chk_32_al, 0xf1ff, 0x4139, {0, 0, 12, 12, 12}},
        {m68k_op_chk_32_pcdi, 0xf1ff, 0x413a, {0, 0, 13, 13, 13}},
        {m68k_op_chk_32_pcix, 0xf1ff, 0x413b, {0, 0, 15, 15, 15}},
        {m68k_op_chk_32_i, 0xf1ff, 0x413c, {0, 0, 12, 12, 12}},
        {m68k_op_chk_16_aw, 0xf1ff, 0x41b8, {18, 16, 12, 12, 12}},
        {m68k_op_chk_16_al, 0xf1ff, 0x41b9, {22, 20, 12, 12, 12}},
        {m68k_op_chk_16_pcdi, 0xf1ff, 0x41ba, {18, 16, 13, 13, 13}},
        {m68k_op_chk_16_pcix, 0xf1ff, 0x41bb, {20, 18, 15, 15, 15}},
        {m68k_op_chk_16_i, 0xf1ff, 0x41bc, {14, 12, 10, 10, 10}},
        {m68k_op_lea_32_aw, 0xf1ff, 0x41f8, {8, 8, 6, 6, 6}},
        {m68k_op_lea_32_al, 0xf1ff, 0x41f9, {12, 12, 6, 6, 6}},
        {m68k_op_lea_32_pcdi, 0xf1ff, 0x41fa, {8, 8, 7, 7, 7}},
        {m68k_op_lea_32_pcix, 0xf1ff, 0x41fb, {12, 12, 9, 9, 9}},
        {m68k_op_addq_8_pi7, 0xf1ff, 0x501f, {12, 12, 8, 8, 8}},
        {m68k_op_addq_8_pd7, 0xf1ff, 0x5027, {14, 14, 9, 9, 9}},
        {m68k_op_addq_8_aw, 0xf1ff, 0x5038, {16, 16, 8, 8, 8}},
        {m68k_op_addq_8_al, 0xf1ff, 0x5039, {20, 20, 8, 8, 8}},
        {m68k_op_addq_16_aw, 0xf1ff, 0x5078, {16, 16, 8, 8, 8}},
        {m68k_op_addq_16_al, 0xf1ff, 0x5079, {20, 20, 8, 8, 8}},
        {m68k_op_addq_32_aw, 0xf1ff, 0x50b8, {24, 24, 8, 8, 8}},
        {m68k_op_addq_32_al, 0xf1ff, 0x50b9, {28, 28, 8, 8, 8}},
        {m68k_op_subq_8_pi7, 0xf1ff, 0x511f, {12, 12, 8, 8, 8}},
        {m68k_op_subq_8_pd7, 0xf1ff, 0x5127, {14, 14, 9, 9, 9}},
        {m68k_op_subq_8_aw, 0xf1ff, 0x5138, {16, 16, 8, 8, 8}},
        {m68k_op_subq_8_al, 0xf1ff, 0x5139, {20, 20, 8, 8, 8}},
        {m68k_op_subq_16_aw, 0xf1ff, 0x5178, {16, 16, 8, 8, 8}},
        {m68k_op_subq_16_al, 0xf1ff, 0x5179, {20, 20, 8, 8, 8}},
        {m68k_op_subq_32_aw, 0xf1ff, 0x51b8, {24, 24, 8, 8, 8}},
        {m68k_op_subq_32_al, 0xf1ff, 0x51b9, {28, 28, 8, 8, 8}},
        {m68k_op_or_8_er_pi7, 0xf1ff, 0x801f, {8, 8, 6, 6, 6}},
        {m68k_op_or_8_er_pd7, 0xf1ff, 0x8027, {10, 10, 7, 7, 7}},
        {m68k_op_or_8_er_aw, 0xf1ff, 0x8038, {12, 12, 6, 6, 6}},
        {m68k_op_or_8_er_al, 0xf1ff, 0x8039, {16, 16, 6, 6, 6}},
        {m68k_op_or_8_er_pcdi, 0xf1ff, 0x803a, {12, 12, 7, 7, 7}},
        {m68k_op_or_8_er_pcix, 0xf1ff, 0x803b, {14, 14, 9, 9, 9}},
        {m68k_op_or_8_er_i, 0xf1ff, 0x803c, {10, 8, 4, 4, 4}},
        {m68k_op_or_16_er_aw, 0xf1ff, 0x8078, {12, 12, 6, 6, 6}},
        {m68k_op_or_16_er_al, 0xf1ff, 0x8079, {16, 16, 6, 6, 6}},
        {m68k_op_or_16_er_pcdi, 0xf1ff, 0x807a, {12, 12, 7, 7, 7}},
        {m68k_op_or_16_er_pcix, 0xf1ff, 0x807b, {14, 14, 9, 9, 9}},
        {m68k_op_or_16_er_i, 0xf1ff, 0x807c, {10, 8, 4, 4, 4}},
        {m68k_op_or_32_er_aw, 0xf1ff, 0x80b8, {18, 18, 6, 6, 6}},
        {m68k_op_or_32_er_al, 0xf1ff, 0x80b9, {22, 22, 6, 6, 6}},
        {m68k_op_or_32_er_pcdi, 0xf1ff, 0x80ba, {18, 18, 7, 7, 7}},
        {m68k_op_or_32_er_pcix, 0xf1ff, 0x80bb, {20, 20, 9, 9, 9}},
        {m68k_op_or_32_er_i, 0xf1ff, 0x80bc, {16, 14, 6, 6, 6}},
        {m68k_op_divu_16_aw, 0xf1ff, 0x80f8, {148, 116, 48, 48, 48}},
        {m68k_op_divu_16_al, 0xf1ff, 0x80f9, {152, 120, 48, 48, 48}},
        {m68k_op_divu_16_pcdi, 0xf1ff, 0x80fa, {148, 116, 49, 49, 49}},
        {m68k_op_divu_16_pcix, 0xf1ff, 0x80fb, {150, 118, 51, 51, 51}},
        {m68k_op_divu_16_i, 0xf1ff, 0x80fc, {144, 112, 46, 46, 46}},
        {m68k_op_sbcd_8_mm_ay7, 0xf1ff, 0x810f, {18, 18, 16, 16, 16}},
        {m68k_op_or_8_re_pi7, 0xf1ff, 0x811f, {12, 12, 8, 8, 8}},
        {m68k_op_or_8_re_pd7, 0xf1ff, 0x8127, {14, 14, 9, 9, 9}},
        {m68k_op_or_8_re_aw, 0xf1ff, 0x8138, {16, 16, 8, 8, 8}},
        {m68k_op_or_8_re_al, 0xf1ff, 0x8139, {20, 20, 8, 8, 8}},
        {m68k_op_pack_16_mm_ay7, 0xf1ff, 0x814f, {0, 0, 13, 13, 13}},
        {m68k_op_or_16_re_aw, 0xf1ff, 0x8178, {16, 16, 8, 8, 8}},
        {m68k_op_or_16_re_al, 0xf1ff, 0x8179, {20, 20, 8, 8, 8}},
        {m68k_op_unpk_16_mm_ay7, 0xf1ff, 0x818f, {0, 0, 13, 13, 13}},
        {m68k_op_or_32_re_aw, 0xf1ff, 0x81b8, {24, 24, 8, 8, 8}},
        {m68k_op_or_32_re_al, 0xf1ff, 0x81b9, {28, 28, 8, 8, 8}},
        {m68k_op_divs_16_aw, 0xf1ff, 0x81f8, {166, 130, 60, 60, 60}},
        {m68k_op_divs_16_al, 0xf1ff, 0x81f9, {170, 134, 60, 60, 60}},
        {m68k_op_divs_16_pcdi, 0xf1ff, 0x81fa, {166, 130, 61, 61, 61}},
        {m68k_op_divs_16_pcix, 0xf1ff, 0x81fb, {168, 132, 63, 63, 63}},
        {m68k_op_divs_16_i, 0xf1ff, 0x81fc, {162, 126, 58, 58, 58}},
        {m68k_op_sub_8_er_pi7, 0xf1ff, 0x901f, {8, 8, 6, 6, 6}},
        {m68k_op_sub_8_er_pd7, 0xf1ff, 0x9027, {10, 10, 7, 7, 7}},
        {m68k_op_sub_8_er_aw, 0xf1ff, 0x9038, {12, 12, 6, 6, 6}},
        {m68k_op_sub_8_er_al, 0xf1ff, 0x9039, {16, 16, 6, 6, 6}},
        {m68k_op_sub_8_er_pcdi, 0xf1ff, 0x903a, {12, 12, 7, 7, 7}},
        {m68k_op_sub_8_er_pcix, 0xf1ff, 0x903b, {14, 14, 9, 9, 9}},
        {m68k_op_sub_8_er_i, 0xf1ff, 0x903c, {10, 8, 4, 4, 4}},
        {m68k_op_sub_16_er_aw, 0xf1ff, 0x9078, {12, 12, 6, 6, 6}},
        {m68k_op_sub_16_er_al, 0xf1ff, 0x9079, {16, 16, 6, 6, 6}},
        {m68k_op_sub_16_er_pcdi, 0xf1ff, 0x907a, {12, 12, 7, 7, 7}},
        {m68k_op_sub_16_er_pcix, 0xf1ff, 0x907b, {14, 14, 9, 9, 9}},
        {m68k_op_sub_16_er_i, 0xf1ff, 0x907c, {10, 8, 4, 4, 4}},
        {m68k_op_sub_32_er_aw, 0xf1ff, 0x90b8, {18, 18, 6, 6, 6}},
        {m68k_op_sub_32_er_al, 0xf1ff, 0x90b9, {22, 22, 6, 6, 6}},
        {m68k_op_sub_32_er_pcdi, 0xf1ff, 0x90ba, {18, 18, 7, 7, 7}},
        {m68k_op_sub_32_er_pcix, 0xf1ff, 0x90bb, {20, 20, 9, 9, 9}},
        {m68k_op_sub_32_er_i, 0xf1ff, 0x90bc, {16, 14, 6, 6, 6}},
        {m68k_op_suba_16_aw, 0xf1ff, 0x90f8, {16, 16, 6, 6, 6}},
        {m68k_op_suba_16_al, 0xf1ff, 0x90f9, {20, 20, 6, 6, 6}},
        {m68k_op_suba_16_pcdi, 0xf1ff, 0x90fa, {16, 16, 7, 7, 7}},
        {m68k_op_suba_16_pcix, 0xf1ff, 0x90fb, {18, 18, 9, 9, 9}},
        {m68k_op_suba_16_i, 0xf1ff, 0x90fc, {14, 12, 4, 4, 4}},
        {m68k_op_subx_8_mm_ay7, 0xf1ff, 0x910f, {18, 18, 12, 12, 12}},
        {m68k_op_sub_8_re_pi7, 0xf1ff, 0x911f, {12, 12, 8, 8, 8}},
        {m68k_op_sub_8_re_pd7, 0xf1ff, 0x9127, {14, 14, 9, 9, 9}},
        {m68k_op_sub_8_re_aw, 0xf1ff, 0x9138, {16, 16, 8, 8, 8}},
        {m68k_op_sub_8_re_al, 0xf1ff, 0x9139, {20, 20, 8, 8, 8}},
        {m68k_op_sub_16_re_aw, 0xf1ff, 0x9178, {16, 16, 8, 8, 8}},
        {m68k_op_sub_16_re_al, 0xf1ff, 0x9179, {20, 20, 8, 8, 8}},
        {m68k_op_sub_32_re_aw, 0xf1ff, 0x91b8, {24, 24, 8, 8, 8}},
        {m68k_op_sub_32_re_al, 0xf1ff, 0x91b9, {28, 28, 8, 8, 8}},
        {m68k_op_suba_32_aw, 0xf1ff, 0x91f8, {18, 18, 6, 6, 6}},
        {m68k_op_suba_32_al, 0xf1ff, 0x91f9, {22, 22, 6, 6, 6}},
        {m68k_op_suba_32_pcdi, 0xf1ff, 0x91fa, {18, 18, 7, 7, 7}},
        {m68k_op_suba_32_pcix, 0xf1ff, 0x91fb, {20, 20, 9, 9, 9}},
        {m68k_op_suba_32_i, 0xf1ff, 0x91fc, {16, 14, 6, 6, 6}},
        {m68k_op_cmp_8_pi7, 0xf1ff, 0xb01f, {8, 8, 6, 6, 6}},
        {m68k_op_cmp_8_pd7, 0xf1ff, 0xb027, {10, 10, 7, 7, 7}},
        {m68k_op_cmp_8_aw, 0xf1ff, 0xb038, {12, 12, 6, 6, 6}},
        {m68k_op_cmp_8_al, 0xf1ff, 0xb039, {16, 16, 6, 6, 6}},
        {m68k_op_cmp_8_pcdi, 0xf1ff, 0xb03a, {12, 12, 7, 7, 7}},
        {m68k_op_cmp_8_pcix, 0xf1ff, 0xb03b, {14, 14, 9, 9, 9}},
        {m68k_op_cmp_8_i, 0xf1ff, 0xb03c, {8, 8, 4, 4, 4}},
        {m68k_op_cmp_16_aw, 0xf1ff, 0xb078, {12, 12, 6, 6, 6}},
        {m68k_op_cmp_16_al, 0xf1ff, 0xb079, {16, 16, 6, 6, 6}},
        {m68k_op_cmp_16_pcdi, 0xf1ff, 0xb07a, {12, 12, 7, 7, 7}},
        {m68k_op_cmp_16_pcix, 0xf1ff, 0xb07b, {14, 14, 9, 9, 9}},
        {m68k_op_cmp_16_i, 0xf1ff, 0xb07c, {8, 8, 4, 4, 4}},
        {m68k_op_cmp_32_aw, 0xf1ff, 0xb0b8, {18, 18, 6, 6, 6}},
        {m68k_op_cmp_32_al, 0xf1ff, 0xb0b9, {22, 22, 6, 6, 6}},
        {m68k_op_cmp_32_pcdi, 0xf1ff, 0xb0ba, {18, 18, 7, 7, 7}},
        {m68k_op_cmp_32_pcix, 0xf1ff, 0xb0bb, {20, 20, 9, 9, 9}},
        {m68k_op_cmp_32_i, 0xf1ff, 0xb0bc, {14, 14, 6, 6, 6}},
        {m68k_op_cmpa_16_aw, 0xf1ff, 0xb0f8, {14, 14, 8, 8, 8}},
        {m68k_op_cmpa_16_al, 0xf1ff, 0xb0f9, {18, 18, 8, 8, 8}},
        {m68k_op_cmpa_16_pcdi, 0xf1ff, 0xb0fa, {14, 14, 9, 9, 9}},
        {m68k_op_cmpa_16_pcix, 0xf1ff, 0xb0fb, {16, 16, 11, 11, 11}},
        {m68k_op_cmpa_16_i, 0xf1ff, 0xb0fc, {10, 10, 6, 6, 6}},
        {m68k_op_cmpm_8_ay7, 0xf1ff, 0xb10f, {12, 12, 9, 9, 9}},
        {m68k_op_eor_8_pi7, 0xf1ff, 0xb11f, {12, 12, 8, 8, 8}},
        {m68k_op_eor_8_pd7, 0xf1ff, 0xb127, {14, 14, 9, 9, 9}},
        {m68k_op_eor_8_aw, 0xf1ff, 0xb138, {16, 16, 8, 8, 8}},
        {m68k_op_eor_8_al, 0xf1ff, 0xb139, {20, 20, 8, 8, 8}},
        {m68k_op_eor_16_aw, 0xf1ff, 0xb178, {16, 16, 8, 8, 8}},
        {m68k_op_eor_16_al, 0xf1ff, 0xb179, {20, 20, 8, 8, 8}},
        {m68k_op_eor_32_aw, 0xf1ff, 0xb1b8, {24, 24, 8, 8, 8}},
        {m68k_op_eor_32_al, 0xf1ff, 0xb1b9, {28, 28, 8, 8, 8}},
        {m68k_op_cmpa_32_aw, 0xf1ff, 0xb1f8, {18, 18, 8, 8, 8}},
        {m68k_op_cmpa_32_al, 0xf1ff, 0xb1f9, {22, 22, 8, 8, 8}},
        {m68k_op_cmpa_32_pcdi, 0xf1ff, 0xb1fa, {18, 18, 9, 9, 9}},
        {m68k_op_cmpa_32_pcix, 0xf1ff, 0xb1fb, {20, 20, 11, 11, 11}},
        {m68k_op_cmpa_32_i, 0xf1ff, 0xb1fc, {14, 14, 8, 8, 8}},
        {m68k_op_and_8_er_pi7, 0xf1ff, 0xc01f, {8, 8, 6, 6, 6}},
        {m68k_op_and_8_er_pd7, 0xf1ff, 0xc027, {10, 10, 7, 7, 7}},
        {m68k_op_and_8_er_aw, 0xf1ff, 0xc038, {12, 12, 6, 6, 6}},
        {m68k_op_and_8_er_al, 0xf1ff, 0xc039, {16, 16, 6, 6, 6}},
        {m68k_op_and_8_er_pcdi, 0xf1ff, 0xc03a, {12, 12, 7, 7, 7}},
        {m68k_op_and_8_er_pcix, 0xf1ff, 0xc03b, {14, 14, 9, 9, 9}},
        {m68k_op_and_8_er_i, 0xf1ff, 0xc03c, {10, 8, 4, 4, 4}},
        {m68k_op_and_16_er_aw, 0xf1ff, 0xc078, {12, 12, 6, 6, 6}},
        {m68k_op_and_16_er_al, 0xf1ff, 0xc079, {16, 16, 6, 6, 6}},
        {m68k_op_and_16_er_pcdi, 0xf1ff, 0xc07a, {12, 12, 7, 7, 7}},
        {m68k_op_and_16_er_pcix, 0xf1ff, 0xc07b, {14, 14, 9, 9, 9}},
        {m68k_op_and_16_er_i, 0xf1ff, 0xc07c, {10, 8, 4, 4, 4}},
        {m68k_op_and_32_er_aw, 0xf1ff, 0xc0b8, {18, 18, 6, 6, 6}},
        {m68k_op_and_32_er_al, 0xf1ff, 0xc0b9, {22, 22, 6, 6, 6}},
        {m68k_op_and_32_er_pcdi, 0xf1ff, 0xc0ba, {18, 18, 7, 7, 7}},
        {m68k_op_and_32_er_pcix, 0xf1ff, 0xc0bb, {20, 20, 9, 9, 9}},
        {m68k_op_and_32_er_i, 0xf1ff, 0xc0bc, {16, 14, 6, 6, 6}},
        {m68k_op_mulu_16_aw, 0xf1ff, 0xc0f8, {46, 38, 31, 31, 31}},
        {m68k_op_mulu_16_al, 0xf1ff, 0xc0f9, {50, 42, 31, 31, 31}},
        {m68k_op_mulu_16_pcdi, 0xf1ff, 0xc0fa, {46, 38, 32, 32, 32}},
        {m68k_op_mulu_16_pcix, 0xf1ff, 0xc0fb, {48, 40, 34, 34, 34}},
        {m68k_op_mulu_16_i, 0xf1ff, 0xc0fc, {42, 34, 29, 29, 29}},
        {m68k_op_abcd_8_mm_ay7, 0xf1ff, 0xc10f, {18, 18, 16, 16, 16}},
        {m68k_op_and_8_re_pi7, 0xf1ff, 0xc11f, {12, 12, 8, 8, 8}},
        {m68k_op_and_8_re_pd7, 0xf1ff, 0xc127, {14, 14, 9, 9, 9}},
        {m68k_op_and_8_re_aw, 0xf1ff, 0xc138, {16, 16, 8, 8, 8}},
        {m68k_op_and_8_re_al, 0xf1ff, 0xc139, {20, 20, 8, 8, 8}},
        {m68k_op_and_16_re_aw, 0xf1ff, 0xc178, {16, 16, 8, 8, 8}},
        {m68k_op_and_16_re_al, 0xf1ff, 0xc179, {20, 20, 8, 8, 8}},
        {m68k_op_and_32_re_aw, 0xf1ff, 0xc1b8, {24, 24, 8, 8, 8}},
        {m68k_op_and_32_re_al, 0xf1ff, 0xc1b9, {28, 28, 8, 8, 8}},
        {m68k_op_muls_16_aw, 0xf1ff, 0xc1f8, {46, 40, 31, 31, 31}},
        {m68k_op_muls_16_al, 0xf1ff, 0xc1f9, {50, 44, 31, 31, 31}},
        {m68k_op_muls_16_pcdi, 0xf1ff, 0xc1fa, {46, 40, 32, 32, 32}},
        {m68k_op_muls_16_pcix, 0xf1ff, 0xc1fb, {48, 42, 34, 34, 34}},
        {m68k_op_muls_16_i, 0xf1ff, 0xc1fc, {42, 36, 29, 29, 29}},
        {m68k_op_add_8_er_pi7, 0xf1ff, 0xd01f, {8, 8, 6, 6, 6}},
        {m68k_op_add_8_er_pd7, 0xf1ff, 0xd027, {10, 10, 7, 7, 7}},
        {m68k_op_add_8_er_aw, 0xf1ff, 0xd038, {12, 12, 6, 6, 6}},
        {m68k_op_add_8_er_al, 0xf1ff, 0xd039, {16, 16, 6, 6, 6}},
        {m68k_op_add_8_er_pcdi, 0xf1ff, 0xd03a, {12, 12, 7, 7, 7}},
        {m68k_op_add_8_er_pcix, 0xf1ff, 0xd03b, {14, 14, 9, 9, 9}},
        {m68k_op_add_8_er_i, 0xf1ff, 0xd03c, {10, 8, 4, 4, 4}},
        {m68k_op_add_16_er_aw, 0xf1ff, 0xd078, {12, 12, 6, 6, 6}},
        {m68k_op_add_16_er_al, 0xf1ff, 0xd079, {16, 16, 6, 6, 6}},
        {m68k_op_add_16_er_pcdi, 0xf1ff, 0xd07a, {12, 12, 7, 7, 7}},
        {m68k_op_add_16_er_pcix, 0xf1ff, 0xd07b, {14, 14, 9, 9, 9}},
        {m68k_op_add_16_er_i, 0xf1ff, 0xd07c, {10, 8, 4, 4, 4}},
        {m68k_op_add_32_er_aw, 0xf1ff, 0xd0b8, {18, 18, 6, 6, 6}},
        {m68k_op_add_32_er_al, 0xf1ff, 0xd0b9, {22, 22, 6, 6, 6}},
        {m68k_op_add_32_er_pcdi, 0xf1ff, 0xd0ba, {18, 18, 7, 7, 7}},
        {m68k_op_add_32_er_pcix, 0xf1ff, 0xd0bb, {20, 20, 9, 9, 9}},
        {m68k_op_add_32_er_i, 0xf1ff, 0xd0bc, {16, 14, 6, 6, 6}},
        {m68k_op_adda_16_aw, 0xf1ff, 0xd0f8, {16, 16, 6, 6, 6}},
        {m68k_op_adda_16_al, 0xf1ff, 0xd0f9, {20, 20, 6, 6, 6}},
        {m68k_op_adda_16_pcdi, 0xf1ff, 0xd0fa, {16, 16, 7, 7, 7}},
        {m68k_op_adda_16_pcix, 0xf1ff, 0xd0fb, {18, 18, 9, 9, 9}},
        {m68k_op_adda_16_i, 0xf1ff, 0xd0fc, {14, 12, 4, 4, 4}},
        {m68k_op_addx_8_mm_ay7, 0xf1ff, 0xd10f, {18, 18, 12, 12, 12}},
        {m68k_op_add_8_re_pi7, 0xf1ff, 0xd11f, {12, 12, 8, 8, 8}},
        {m68k_op_add_8_re_pd7, 0xf1ff, 0xd127, {14, 14, 9, 9, 9}},
        {m68k_op_add_8_re_aw, 0xf1ff, 0xd138, {16, 16, 8, 8, 8}},
        {m68k_op_add_8_re_al, 0xf1ff, 0xd139, {20, 20, 8, 8, 8}},
        {m68k_op_add_16_re_aw, 0xf1ff, 0xd178, {16, 16, 8, 8, 8}},
        {m68k_op_add_16_re_al, 0xf1ff, 0xd179, {20, 20, 8, 8, 8}},
        {m68k_op_add_32_re_aw, 0xf1ff, 0xd1b8, {24, 24, 8, 8, 8}},
        {m68k_op_add_32_re_al, 0xf1ff, 0xd1b9, {28, 28, 8, 8, 8}},
        {m68k_op_adda_32_aw, 0xf1ff, 0xd1f8, {18, 18, 6, 6, 6}},
        {m68k_op_adda_32_al, 0xf1ff, 0xd1f9, {22, 22, 6, 6, 6}},
        {m68k_op_adda_32_pcdi, 0xf1ff, 0xd1fa, {18, 18, 7, 7, 7}},
        {m68k_op_adda_32_pcix, 0xf1ff, 0xd1fb, {20, 20, 9, 9, 9}},
        {m68k_op_adda_32_i, 0xf1ff, 0xd1fc, {16, 14, 6, 6, 6}},
        {m68k_op_ori_8_d, 0xfff8, 0x0000, {8, 8, 2, 2, 2}},
        {m68k_op_ori_8_ai, 0xfff8, 0x0010, {16, 16, 8, 8, 8}},
        {m68k_op_ori_8_pi, 0xfff8, 0x0018, {16, 16, 8, 8, 8}},
        {m68k_op_ori_8_pd, 0xfff8, 0x0020, {18, 18, 9, 9, 9}},
        {m68k_op_ori_8_di, 0xfff8, 0x0028, {20, 20, 9, 9, 9}},
        {m68k_op_ori_8_ix, 0xfff8, 0x0030, {22, 22, 11, 11, 11}},
        {m68k_op_ori_16_d, 0xfff8, 0x0040, {8, 8, 2, 2, 2}},
        {m68k_op_ori_16_ai, 0xfff8, 0x0050, {16, 16, 8, 8, 8}},
        {m68k_op_ori_16_pi, 0xfff8, 0x0058, {16, 16, 8, 8, 8}},
        {m68k_op_ori_16_pd, 0xfff8, 0x0060, {18, 18, 9, 9, 9}},
        {m68k_op_ori_16_di, 0xfff8, 0x0068, {20, 20, 9, 9, 9}},
        {m68k_op_ori_16_ix, 0xfff8, 0x0070, {22, 22, 11, 11, 11}},
        {m68k_op_ori_32_d, 0xfff8, 0x0080, {16, 14, 2, 2, 2}},
        {m68k_op_ori_32_ai, 0xfff8, 0x0090, {28, 28, 8, 8, 8}},
        {m68k_op_ori_32_pi, 0xfff8, 0x0098, {28, 28, 8, 8, 8}},
        {m68k_op_ori_32_pd, 0xfff8, 0x00a0, {30, 30, 9, 9, 9}},
        {m68k_op_ori_32_di, 0xfff8, 0x00a8, {32, 32, 9, 9, 9}},
        {m68k_op_ori_32_ix, 0xfff8, 0x00b0, {34, 34, 11, 11, 11}},
        {m68k_op_chk2cmp2_8_ai, 0xfff8, 0x00d0, {0, 0, 22, 22, 22}},
        {m68k_op_chk2cmp2_8_di, 0xfff8, 0x00e8, {0, 0, 23, 23, 23}},
        {m68k_op_chk2cmp2_8_ix, 0xfff8, 0x00f0, {0, 0, 25, 25, 25}},
        {m68k_op_andi_8_d, 0xfff8, 0x0200, {8, 8, 2, 2, 2}},
        {m68k_op_andi_8_ai, 0xfff8, 0x0210, {16, 16, 8, 8, 8}},
        {m68k_op_andi_8_pi, 0xfff8, 0x0218, {16, 16, 8, 8, 8}},
        {m68k_op_andi_8_pd, 0xfff8, 0x0220, {18, 18, 9, 9, 9}},
        {m68k_op_andi_8_di, 0xfff8, 0x0228, {20, 20, 9, 9, 9}},
        {m68k_op_andi_8_ix, 0xfff8, 0x0230, {22, 22, 11, 11, 11}},
        {m68k_op_andi_16_d, 0xfff8, 0x0240, {8, 8, 2, 2, 2}},
        {m68k_op_andi_16_ai, 0xfff8, 0x0250, {16, 16, 8, 8, 8}},
        {m68k_op_andi_16_pi, 0xfff8, 0x0258, {16, 16, 8, 8, 8}},
        {m68k_op_andi_16_pd, 0xfff8, 0x0260, {18, 18, 9, 9, 9}},
        {m68k_op_andi_16_di, 0xfff8, 0x0268, {20, 20, 9, 9, 9}},
        {m68k_op_andi_16_ix, 0xfff8, 0x0270, {22, 22, 11, 11, 11}},
        {m68k_op_andi_32_d, 0xfff8, 0x0280, {14, 14, 2, 2, 2}},
        {m68k_op_andi_32_ai, 0xfff8, 0x0290, {28, 28, 8, 8, 8}},
        {m68k_op_andi_32_pi, 0xfff8, 0x0298, {28, 28, 8, 8, 8}},
        {m68k_op_andi_32_pd, 0xfff8, 0x02a0, {30, 30, 9, 9, 9}},
        {m68k_op_andi_32_di, 0xfff8, 0x02a8, {32, 32, 9, 9, 9}},
        {m68k_op_andi_32_ix, 0xfff8, 0x02b0, {34, 34, 11, 11, 11}},
        {m68k_op_chk2cmp2_16_ai, 0xfff8, 0x02d0, {0, 0, 22, 22, 22}},
        {m68k_op_chk2cmp2_16_di, 0xfff8, 0x02e8, {0, 0, 23, 23, 23}},
        {m68k_op_chk2cmp2_16_ix, 0xfff8, 0x02f0, {0, 0, 25, 25, 25}},
        {m68k_op_subi_8_d, 0xfff8, 0x0400, {8, 8, 2, 2, 2}},
        {m68k_op_subi_8_ai, 0xfff8, 0x0410, {16, 16, 8, 8, 8}},
        {m68k_op_subi_8_pi, 0xfff8, 0x0418, {16, 16, 8, 8, 8}},
        {m68k_op_subi_8_pd, 0xfff8, 0x0420, {18, 18, 9, 9, 9}},
        {m68k_op_subi_8_di, 0xfff8, 0x0428, {20, 20, 9, 9, 9}},
        {m68k_op_subi_8_ix, 0xfff8, 0x0430, {22, 22, 11, 11, 11}},
        {m68k_op_subi_16_d, 0xfff8, 0x0440, {8, 8, 2, 2, 2}},
        {m68k_op_subi_16_ai, 0xfff8, 0x0450, {16, 16, 8, 8, 8}},
        {m68k_op_subi_16_pi, 0xfff8, 0x0458, {16, 16, 8, 8, 8}},
        {m68k_op_subi_16_pd, 0xfff8, 0x0460, {18, 18, 9, 9, 9}},
        {m68k_op_subi_16_di, 0xfff8, 0x0468, {20, 20, 9, 9, 9}},
        {m68k_op_subi_16_ix, 0xfff8, 0x0470, {22, 22, 11, 11, 11}},
        {m68k_op_subi_32_d, 0xfff8, 0x0480, {16, 14, 2, 2, 2}},
        {m68k_op_subi_32_ai, 0xfff8, 0x0490, {28, 28, 8, 8, 8}},
        {m68k_op_subi_32_pi, 0xfff8, 0x0498, {28, 28, 8, 8, 8}},
        {m68k_op_subi_32_pd, 0xfff8, 0x04a0, {30, 30, 9, 9, 9}},
        {m68k_op_subi_32_di, 0xfff8, 0x04a8, {32, 32, 9, 9, 9}},
        {m68k_op_subi_32_ix, 0xfff8, 0x04b0, {34, 34, 11, 11, 11}},
        {m68k_op_chk2cmp2_32_ai, 0xfff8, 0x04d0, {0, 0, 22, 22, 22}},
        {m68k_op_chk2cmp2_32_di, 0xfff8, 0x04e8, {0, 0, 23, 23, 23}},
        {m68k_op_chk2cmp2_32_ix, 0xfff8, 0x04f0, {0, 0, 25, 25, 25}},
        {m68k_op_addi_8_d, 0xfff8, 0x0600, {8, 8, 2, 2, 2}},
        {m68k_op_addi_8_ai, 0xfff8, 0x0610, {16, 16, 8, 8, 8}},
        {m68k_op_addi_8_pi, 0xfff8, 0x0618, {16, 16, 8, 8, 8}},
        {m68k_op_addi_8_pd, 0xfff8, 0x0620, {18, 18, 9, 9, 9}},
        {m68k_op_addi_8_di, 0xfff8, 0x0628, {20, 20, 9, 9, 9}},
        {m68k_op_addi_8_ix, 0xfff8, 0x0630, {22, 22, 11, 11, 11}},
        {m68k_op_addi_16_d, 0xfff8, 0x0640, {8, 8, 2, 2, 2}},
        {m68k_op_addi_16_ai, 0xfff8, 0x0650, {16, 16, 8, 8, 8}},
        {m68k_op_addi_16_pi, 0xfff8, 0x0658, {16, 16, 8, 8, 8}},
        {m68k_op_addi_16_pd, 0xfff8, 0x0660, {18, 18, 9, 9, 9}},
        {m68k_op_addi_16_di, 0xfff8, 0x0668, {20, 20, 9, 9, 9}},
        {m68k_op_addi_16_ix, 0xfff8, 0x0670, {22, 22, 11, 11, 11}},
        {m68k_op_addi_32_d, 0xfff8, 0x0680, {16, 14, 2, 2, 2}},
        {m68k_op_addi_32_ai, 0xfff8, 0x0690, {28, 28, 8, 8, 8}},
        {m68k_op_addi_32_pi, 0xfff8, 0x0698, {28, 28, 8, 8, 8}},
        {m68k_op_addi_32_pd, 0xfff8, 0x06a0, {30, 30, 9, 9, 9}},
        {m68k_op_addi_32_di, 0xfff8, 0x06a8, {32, 32, 9, 9, 9}},
        {m68k_op_addi_32_ix, 0xfff8, 0x06b0, {34, 34, 11, 11, 11}},
        {m68k_op_callm_32_ai, 0xfff8, 0x06d0, {0, 0, 64, 64, 64}},
        {m68k_op_callm_32_di, 0xfff8, 0x06e8, {0, 0, 65, 65, 65}},
        {m68k_op_callm_32_ix, 0xfff8, 0x06f0, {0, 0, 67, 67, 67}},
        {m68k_op_btst_32_s_d, 0xfff8, 0x0800, {10, 10, 4, 4, 4}},
        {m68k_op_btst_8_s_ai, 0xfff8, 0x0810, {12, 12, 8, 8, 8}},
        {m68k_op_btst_8_s_pi, 0xfff8, 0x0818, {12, 12, 8, 8, 8}},
        {m68k_op_btst_8_s_pd, 0xfff8, 0x0820, {14, 14, 9, 9, 9}},
        {m68k_op_btst_8_s_di, 0xfff8, 0x0828, {16, 16, 9, 9, 9}},
        {m68k_op_btst_8_s_ix, 0xfff8, 0x0830, {18, 18, 11, 11, 11}},
        {m68k_op_bchg_32_s_d, 0xfff8, 0x0840, {12, 12, 4, 4, 4}},
        {m68k_op_bchg_8_s_ai, 0xfff8, 0x0850, {16, 16, 8, 8, 8}},
        {m68k_op_bchg_8_s_pi, 0xfff8, 0x0858, {16, 16, 8, 8, 8}},
        {m68k_op_bchg_8_s_pd, 0xfff8, 0x0860, {18, 18, 9, 9, 9}},
        {m68k_op_bchg_8_s_di, 0xfff8, 0x0868, {20, 20, 9, 9, 9}},
        {m68k_op_bchg_8_s_ix, 0xfff8, 0x0870, {22, 22, 11, 11, 11}},
        {m68k_op_bclr_32_s_d, 0xfff8, 0x0880, {14, 14, 4, 4, 4}},
        {m68k_op_bclr_8_s_ai, 0xfff8, 0x0890, {16, 16, 8, 8, 8}},
        {m68k_op_bclr_8_s_pi, 0xfff8, 0x0898, {16, 16, 8, 8, 8}},
        {m68k_op_bclr_8_s_pd, 0xfff8, 0x08a0, {18, 18, 9, 9, 9}},
        {m68k_op_bclr_8_s_di, 0xfff8, 0x08a8, {20, 20, 9, 9, 9}},
        {m68k_op_bclr_8_s_ix, 0xfff8, 0x08b0, {22, 22, 11, 11, 11}},
        {m68k_op_bset_32_s_d, 0xfff8, 0x08c0, {12, 12, 4, 4, 4}},
        {m68k_op_bset_8_s_ai, 0xfff8, 0x08d0, {16, 16, 8, 8, 8}},
        {m68k_op_bset_8_s_pi, 0xfff8, 0x08d8, {16, 16, 8, 8, 8}},
        {m68k_op_bset_8_s_pd, 0xfff8, 0x08e0, {18, 18, 9, 9, 9}},
        {m68k_op_bset_8_s_di, 0xfff8, 0x08e8, {20, 20, 9, 9, 9}},
        {m68k_op_bset_8_s_ix, 0xfff8, 0x08f0, {22, 22, 11, 11, 11}},
        {m68k_op_eori_8_d, 0xfff8, 0x0a00, {8, 8, 2, 2, 2}},
        {m68k_op_eori_8_ai, 0xfff8, 0x0a10, {16, 16, 8, 8, 8}},
        {m68k_op_eori_8_pi, 0xfff8, 0x0a18, {16, 16, 8, 8, 8}},
        {m68k_op_eori_8_pd, 0xfff8, 0x0a20, {18, 18, 9, 9, 9}},
        {m68k_op_eori_8_di, 0xfff8, 0x0a28, {20, 20, 9, 9, 9}},
        {m68k_op_eori_8_ix, 0xfff8, 0x0a30, {22, 22, 11, 11, 11}},
        {m68k_op_eori_16_d, 0xfff8, 0x0a40, {8, 8, 2, 2, 2}},
        {m68k_op_eori_16_ai, 0xfff8, 0x0a50, {16, 16, 8, 8, 8}},
        {m68k_op_eori_16_pi, 0xfff8, 0x0a58, {16, 16, 8, 8, 8}},
        {m68k_op_eori_16_pd, 0xfff8, 0x0a60, {18, 18, 9, 9, 9}},
        {m68k_op_eori_16_di, 0xfff8, 0x0a68, {20, 20, 9, 9, 9}},
        {m68k_op_eori_16_ix, 0xfff8, 0x0a70, {22, 22, 11, 11, 11}},
        {m68k_op_eori_32_d, 0xfff8, 0x0a80, {16, 14, 2, 2, 2}},
        {m68k_op_eori_32_ai, 0xfff8, 0x0a90, {28, 28, 8, 8, 8}},
        {m68k_op_eori_32_pi, 0xfff8, 0x0a98, {28, 28, 8, 8, 8}},
        {m68k_op_eori_32_pd, 0xfff8, 0x0aa0, {30, 30, 9, 9, 9}},
        {m68k_op_eori_32_di, 0xfff8, 0x0aa8, {32, 32, 9, 9, 9}},
        {m68k_op_eori_32_ix, 0xfff8, 0x0ab0, {34, 34, 11, 11, 11}},
        {m68k_op_cas_8_ai, 0xfff8, 0x0ad0, {0, 0, 16, 16, 16}},
        {m68k_op_cas_8_pi, 0xfff8, 0x0ad8, {0, 0, 16, 16, 16}},
        {m68k_op_cas_8_pd, 0xfff8, 0x0ae0, {0, 0, 17, 17, 17}},
        {m68k_op_cas_8_di, 0xfff8, 0x0ae8, {0, 0, 17, 17, 17}},
        {m68k_op_cas_8_ix, 0xfff8, 0x0af0, {0, 0, 19, 19, 19}},
        {m68k_op_cmpi_8_d, 0xfff8, 0x0c00, {8, 8, 2, 2, 2}},
        {m68k_op_cmpi_8_ai, 0xfff8, 0x0c10, {12, 12, 6, 6, 6}},
        {m68k_op_cmpi_8_pi, 0xfff8, 0x0c18, {12, 12, 6, 6, 6}},
        {m68k_op_cmpi_8_pd, 0xfff8, 0x0c20, {14, 14, 7, 7, 7}},
        {m68k_op_cmpi_8_di, 0xfff8, 0x0c28, {16, 16, 7, 7, 7}},
        {m68k_op_cmpi_8_ix, 0xfff8, 0x0c30, {18, 18, 9, 9, 9}},
        {m68k_op_cmpi_16_d, 0xfff8, 0x0c40, {8, 8, 2, 2, 2}},
        {m68k_op_cmpi_16_ai, 0xfff8, 0x0c50, {12, 12, 6, 6, 6}},
        {m68k_op_cmpi_16_pi, 0xfff8, 0x0c58, {12, 12, 6, 6, 6}},
        {m68k_op_cmpi_16_pd, 0xfff8, 0x0c60, {14, 14, 7, 7, 7}},
        {m68k_op_cmpi_16_di, 0xfff8, 0x0c68, {16, 16, 7, 7, 7}},
        {m68k_op_cmpi_16_ix, 0xfff8, 0x0c70, {18, 18, 9, 9, 9}},
        {m68k_op_cmpi_32_d, 0xfff8, 0x0c80, {14, 12, 2, 2, 2}},
        {m68k_op_cmpi_32_ai, 0xfff8, 0x0c90, {20, 20, 6, 6, 6}},
        {m68k_op_cmpi_32_pi, 0xfff8, 0x0c98, {20, 20, 6, 6, 6}},
        {m68k_op_cmpi_32_pd, 0xfff8, 0x0ca0, {22, 22, 7, 7, 7}},
        {m68k_op_cmpi_32_di, 0xfff8, 0x0ca8, {24, 24, 7, 7, 7}},
        {m68k_op_cmpi_32_ix, 0xfff8, 0x0cb0, {26, 26, 9, 9, 9}},
        {m68k_op_cas_16_ai, 0xfff8, 0x0cd0, {0, 0, 16, 16, 16}},
        {m68k_op_cas_16_pi, 0xfff8, 0x0cd8, {0, 0, 16, 16, 16}},
        {m68k_op_cas_16_pd, 0xfff8, 0x0ce0, {0, 0, 17, 17, 17}},
        {m68k_op_cas_16_di, 0xfff8, 0x0ce8, {0, 0, 17, 17, 17}},
        {m68k_op_cas_16_ix, 0xfff8, 0x0cf0, {0, 0, 19, 19, 19}},
        {m68k_op_moves_8_ai, 0xfff8, 0x0e10, {0, 18, 9, 9, 9}},
        {m68k_op_moves_8_pi, 0xfff8, 0x0e18, {0, 18, 9, 9, 9}},
        {m68k_op_moves_8_pd, 0xfff8, 0x0e20, {0, 20, 10, 10, 10}},
        {m68k_op_moves_8_di, 0xfff8, 0x0e28, {0, 26, 10, 10, 10}},
        {m68k_op_moves_8_ix, 0xfff8, 0x0e30, {0, 30, 12, 12, 12}},
        {m68k_op_moves_16_ai, 0xfff8, 0x0e50, {0, 18, 9, 9, 9}},
        {m68k_op_moves_16_pi, 0xfff8, 0x0e58, {0, 18, 9, 9, 9}},
        {m68k_op_moves_16_pd, 0xfff8, 0x0e60, {0, 20, 10, 10, 10}},
        {m68k_op_moves_16_di, 0xfff8, 0x0e68, {0, 26, 10, 10, 10}},
        {m68k_op_moves_16_ix, 0xfff8, 0x0e70, {0, 30, 12, 12, 12}},
        {m68k_op_moves_32_ai, 0xfff8, 0x0e90, {0, 22, 9, 9, 9}},
        {m68k_op_moves_32_pi, 0xfff8, 0x0e98, {0, 22, 9, 9, 9}},
        {m68k_op_moves_32_pd, 0xfff8, 0x0ea0, {0, 28, 10, 10, 10}},
        {m68k_op_moves_32_di, 0xfff8, 0x0ea8, {0, 32, 10, 10, 10}},
        {m68k_op_moves_32_ix, 0xfff8, 0x0eb0, {0, 36, 12, 12, 12}},
        {m68k_op_cas_32_ai, 0xfff8, 0x0ed0, {0, 0, 16, 16, 16}},
        {m68k_op_cas_32_pi, 0xfff8, 0x0ed8, {0, 0, 16, 16, 16}},
        {m68k_op_cas_32_pd, 0xfff8, 0x0ee0, {0, 0, 17, 17, 17}},
        {m68k_op_cas_32_di, 0xfff8, 0x0ee8, {0, 0, 17, 17, 17}},
        {m68k_op_cas_32_ix, 0xfff8, 0x0ef0, {0, 0, 19, 19, 19}},
        {m68k_op_move_8_aw_d, 0xfff8, 0x11c0, {12, 12, 4, 4, 4}},
        {m68k_op_move_8_aw_ai, 0xfff8, 0x11d0, {16, 16, 8, 8, 8}},
        {m68k_op_move_8_aw_pi, 0xfff8, 0x11d8, {16, 16, 8, 8, 8}},
        {m68k_op_move_8_aw_pd, 0xfff8, 0x11e0, {18, 18, 9, 9, 9}},
        {m68k_op_move_8_aw_di, 0xfff8, 0x11e8, {20, 20, 9, 9, 9}},
        {m68k_op_move_8_aw_ix, 0xfff8, 0x11f0, {22, 22, 11, 11, 11}},
        {m68k_op_move_8_al_d, 0xfff8, 0x13c0, {16, 16, 6, 6, 6}},
        {m68k_op_move_8_al_ai, 0xfff8, 0x13d0, {20, 20, 10, 10, 10}},
        {m68k_op_move_8_al_pi, 0xfff8, 0x13d8, {20, 20, 10, 10, 10}},
        {m68k_op_move_8_al_pd, 0xfff8, 0x13e0, {22, 22, 11, 11, 11}},
        {m68k_op_move_8_al_di, 0xfff8, 0x13e8, {24, 24, 11, 11, 11}},
        {m68k_op_move_8_al_ix, 0xfff8, 0x13f0, {26, 26, 13, 13, 13}},
        {m68k_op_move_8_pi7_d, 0xfff8, 0x1ec0, {8, 8, 4, 4, 4}},
        {m68k_op_move_8_pi7_ai, 0xfff8, 0x1ed0, {12, 12, 8, 8, 8}},
        {m68k_op_move_8_pi7_pi, 0xfff8, 0x1ed8, {12, 12, 8, 8, 8}},
        {m68k_op_move_8_pi7_pd, 0xfff8, 0x1ee0, {14, 14, 9, 9, 9}},
        {m68k_op_move_8_pi7_di, 0xfff8, 0x1ee8, {16, 16, 9, 9, 9}},
        {m68k_op_move_8_pi7_ix, 0xfff8, 0x1ef0, {18, 18, 11, 11, 11}},
        {m68k_op_move_8_pd7_d, 0xfff8, 0x1f00, {8, 8, 5, 5, 5}},
        {m68k_op_move_8_pd7_ai, 0xfff8, 0x1f10, {12, 12, 9, 9, 9}},
        {m68k_op_move_8_pd7_pi, 0xfff8, 0x1f18, {12, 12, 9, 9, 9}},
        {m68k_op_move_8_pd7_pd, 0xfff8, 0x1f20, {14, 14, 10, 10, 10}},
        {m68k_op_move_8_pd7_di, 0xfff8, 0x1f28, {16, 16, 10, 10, 10}},
        {m68k_op_move_8_pd7_ix, 0xfff8, 0x1f30, {18, 18, 12, 12, 12}},
        {m68k_op_move_32_aw_d, 0xfff8, 0x21c0, {16, 16, 4, 4, 4}},
        {m68k_op_move_32_aw_a, 0xfff8, 0x21c8, {16, 16, 4, 4, 4}},
        {m68k_op_move_32_aw_ai, 0xfff8, 0x21d0, {24, 24, 8, 8, 8}},
        {m68k_op_move_32_aw_pi, 0xfff8, 0x21d8, {24, 24, 8, 8, 8}},
        {m68k_op_move_32_aw_pd, 0xfff8, 0x21e0, {26, 26, 9, 9, 9}},
        {m68k_op_move_32_aw_di, 0xfff8, 0x21e8, {28, 28, 9, 9, 9}},
        {m68k_op_move_32_aw_ix, 0xfff8, 0x21f0, {30, 30, 11, 11, 11}},
        {m68k_op_move_32_al_d, 0xfff8, 0x23c0, {20, 20, 6, 6, 6}},
        {m68k_op_move_32_al_a, 0xfff8, 0x23c8, {20, 20, 6, 6, 6}},
        {m68k_op_move_32_al_ai, 0xfff8, 0x23d0, {28, 28, 10, 10, 10}},
        {m68k_op_move_32_al_pi, 0xfff8, 0x23d8, {28, 28, 10, 10, 10}},
        {m68k_op_move_32_al_pd, 0xfff8, 0x23e0, {30, 30, 11, 11, 11}},
        {m68k_op_move_32_al_di, 0xfff8, 0x23e8, {32, 32, 11, 11, 11}},
        {m68k_op_move_32_al_ix, 0xfff8, 0x23f0, {34, 34, 13, 13, 13}},
        {m68k_op_move_16_aw_d, 0xfff8, 0x31c0, {12, 12, 4, 4, 4}},
        {m68k_op_move_16_aw_a, 0xfff8, 0x31c8, {12, 12, 4, 4, 4}},
        {m68k_op_move_16_aw_ai, 0xfff8, 0x31d0, {16, 16, 8, 8, 8}},
        {m68k_op_move_16_aw_pi, 0xfff8, 0x31d8, {16, 16, 8, 8, 8}},
        {m68k_op_move_16_aw_pd, 0xfff8, 0x31e0, {18, 18, 9, 9, 9}},
        {m68k_op_move_16_aw_di, 0xfff8, 0x31e8, {20, 20, 9, 9, 9}},
        {m68k_op_move_16_aw_ix, 0xfff8, 0x31f0, {22, 22, 11, 11, 11}},
        {m68k_op_move_16_al_d, 0xfff8, 0x33c0, {16, 16, 6, 6, 6}},
        {m68k_op_move_16_al_a, 0xfff8, 0x33c8, {16, 16, 6, 6, 6}},
        {m68k_op_move_16_al_ai, 0xfff8, 0x33d0, {20, 20, 10, 10, 10}},
        {m68k_op_move_16_al_pi, 0xfff8, 0x33d8, {20, 20, 10, 10, 10}},
        {m68k_op_move_16_al_pd, 0xfff8, 0x33e0, {22, 22, 11, 11, 11}},
        {m68k_op_move_16_al_di, 0xfff8, 0x33e8, {24, 24, 11, 11, 11}},
        {m68k_op_move_16_al_ix, 0xfff8, 0x33f0, {26, 26, 13, 13, 13}},
        {m68k_op_negx_8_d, 0xfff8, 0x4000, {4, 4, 2, 2, 2}},
        {m68k_op_negx_8_ai, 0xfff8, 0x4010, {12, 12, 8, 8, 8}},
        {m68k_op_negx_8_pi, 0xfff8, 0x4018, {12, 12, 8, 8, 8}},
        {m68k_op_negx_8_pd, 0xfff8, 0x4020, {14, 14, 9, 9, 9}},
        {m68k_op_negx_8_di, 0xfff8, 0x4028, {16, 16, 9, 9, 9}},
        {m68k_op_negx_8_ix, 0xfff8, 0x4030, {18, 18, 11, 11, 11}},
        {m68k_op_negx_16_d, 0xfff8, 0x4040, {4, 4, 2, 2, 2}},
        {m68k_op_negx_16_ai, 0xfff8, 0x4050, {12, 12, 8, 8, 8}},
        {m68k_op_negx_16_pi, 0xfff8, 0x4058, {12, 12, 8, 8, 8}},
        {m68k_op_negx_16_pd, 0xfff8, 0x4060, {14, 14, 9, 9, 9}},
        {m68k_op_negx_16_di, 0xfff8, 0x4068, {16, 16, 9, 9, 9}},
        {m68k_op_negx_16_ix, 0xfff8, 0x4070, {18, 18, 11, 11, 11}},
        {m68k_op_negx_32_d, 0xfff8, 0x4080, {6, 6, 2, 2, 2}},
        {m68k_op_negx_32_ai, 0xfff8, 0x4090, {20, 20, 8, 8, 8}},
        {m68k_op_negx_32_pi, 0xfff8, 0x4098, {20, 20, 8, 8, 8}},
        {m68k_op_negx_32_pd, 0xfff8, 0x40a0, {22, 22, 9, 9, 9}},
        {m68k_op_negx_32_di, 0xfff8, 0x40a8, {24, 24, 9, 9, 9}},
        {m68k_op_negx_32_ix, 0xfff8, 0x40b0, {26, 26, 11, 11, 11}},
        {m68k_op_move_16_frs_d, 0xfff8, 0x40c0, {6, 4, 8, 8, 8}},
        {m68k_op_move_16_frs_ai, 0xfff8, 0x40d0, {12, 12, 12, 12, 12}},
        {m68k_op_move_16_frs_pi, 0xfff8, 0x40d8, {12, 12, 12, 12, 12}},
        {m68k_op_move_16_frs_pd, 0xfff8, 0x40e0, {14, 14, 13, 13, 13}},
        {m68k_op_move_16_frs_di, 0xfff8, 0x40e8, {16, 16, 13, 13, 13}},
        {m68k_op_move_16_frs_ix, 0xfff8, 0x40f0, {18, 18, 15, 15, 15}},
        {m68k_op_clr_8_d, 0xfff8, 0x4200, {4, 4, 2, 2, 2}},
        {m68k_op_clr_8_ai, 0xfff8, 0x4210, {12, 8, 8, 8, 8}},
        {m68k_op_clr_8_pi, 0xfff8, 0x4218, {12, 8, 8, 8, 8}},
        {m68k_op_clr_8_pd, 0xfff8, 0x4220, {14, 10, 9, 9, 9}},
        {m68k_op_clr_8_di, 0xfff8, 0x4228, {16, 12, 9, 9, 9}},
        {m68k_op_clr_8_ix, 0xfff8, 0x4230, {18, 14, 11, 11, 11}},
        {m68k_op_clr_16_d, 0xfff8, 0x4240, {4, 4, 2, 2, 2}},
        {m68k_op_clr_16_ai, 0xfff8, 0x4250, {12, 8, 8, 8, 8}},
        {m68k_op_clr_16_pi, 0xfff8, 0x4258, {12, 8, 8, 8, 8}},
        {m68k_op_clr_16_pd, 0xfff8, 0x4260, {14, 10, 9, 9, 9}},
        {m68k_op_clr_16_di, 0xfff8, 0x4268, {16, 12, 9, 9, 9}},
        {m68k_op_clr_16_ix, 0xfff8, 0x4270, {18, 14, 11, 11, 11}},
        {m68k_op_clr_32_d, 0xfff8, 0x4280, {6, 6, 2, 2, 2}},
        {m68k_op_clr_32_ai, 0xfff8, 0x4290, {20, 12, 8, 8, 8}},
        {m68k_op_clr_32_pi, 0xfff8, 0x4298, {20, 12, 8, 8, 8}},
        {m68k_op_clr_32_pd, 0xfff8, 0x42a0, {22, 14, 9, 9, 9}},
        {m68k_op_clr_32_di, 0xfff8, 0x42a8, {24, 16, 9, 9, 9}},
        {m68k_op_clr_32_ix, 0xfff8, 0x42b0, {26, 20, 11, 11, 11}},
        {m68k_op_move_16_frc_d, 0xfff8, 0x42c0, {0, 4, 4, 4, 4}},
        {m68k_op_move_16_frc_ai, 0xfff8, 0x42d0, {0, 12, 8, 8, 8}},
        {m68k_op_move_16_frc_pi, 0xfff8, 0x42d8, {0, 12, 8, 8, 8}},
        {m68k_op_move_16_frc_pd, 0xfff8, 0x42e0, {0, 14, 9, 9, 9}},
        {m68k_op_move_16_frc_di, 0xfff8, 0x42e8, {0, 16, 9, 9, 9}},
        {m68k_op_move_16_frc_ix, 0xfff8, 0x42f0, {0, 18, 11, 11, 11}},
        {m68k_op_neg_8_d, 0xfff8, 0x4400, {4, 4, 2, 2, 2}},
        {m68k_op_neg_8_ai, 0xfff8, 0x4410, {12, 12, 8, 8, 8}},
        {m68k_op_neg_8_pi, 0xfff8, 0x4418, {12, 12, 8, 8, 8}},
        {m68k_op_neg_8_pd, 0xfff8, 0x4420, {14, 14, 9, 9, 9}},
        {m68k_op_neg_8_di, 0xfff8, 0x4428, {16, 16, 9, 9, 9}},
        {m68k_op_neg_8_ix, 0xfff8, 0x4430, {18, 18, 11, 11, 11}},
        {m68k_op_neg_16_d, 0xfff8, 0x4440, {4, 4, 2, 2, 2}},
        {m68k_op_neg_16_ai, 0xfff8, 0x4450, {12, 12, 8, 8, 8}},
        {m68k_op_neg_16_pi, 0xfff8, 0x4458, {12, 12, 8, 8, 8}},
        {m68k_op_neg_16_pd, 0xfff8, 0x4460, {14, 14, 9, 9, 9}},
        {m68k_op_neg_16_di, 0xfff8, 0x4468, {16, 16, 9, 9, 9}},
        {m68k_op_neg_16_ix, 0xfff8, 0x4470, {18, 18, 11, 11, 11}},
        {m68k_op_neg_32_d, 0xfff8, 0x4480, {6, 6, 2, 2, 2}},
        {m68k_op_neg_32_ai, 0xfff8, 0x4490, {20, 20, 8, 8, 8}},
        {m68k_op_neg_32_pi, 0xfff8, 0x4498, {20, 20, 8, 8, 8}},
        {m68k_op_neg_32_pd, 0xfff8, 0x44a0, {22, 22, 9, 9, 9}},
        {m68k_op_neg_32_di, 0xfff8, 0x44a8, {24, 24, 9, 9, 9}},
        {m68k_op_neg_32_ix, 0xfff8, 0x44b0, {26, 26, 11, 11, 11}},
        {m68k_op_move_16_toc_d, 0xfff8, 0x44c0, {12, 12, 4, 4, 4}},
        {m68k_op_move_16_toc_ai, 0xfff8, 0x44d0, {16, 16, 8, 8, 8}},
        {m68k_op_move_16_toc_pi, 0xfff8, 0x44d8, {16, 16, 8, 8, 8}},
        {m68k_op_move_16_toc_pd, 0xfff8, 0x44e0, {18, 18, 9, 9, 9}},
        {m68k_op_move_16_toc_di, 0xfff8, 0x44e8, {20, 20, 9, 9, 9}},
        {m68k_op_move_16_toc_ix, 0xfff8, 0x44f0, {22, 22, 11, 11, 11}},
        {m68k_op_not_8_d, 0xfff8, 0x4600, {4, 4, 2, 2, 2}},
        {m68k_op_not_8_ai, 0xfff8, 0x4610, {12, 12, 8, 8, 8}},
        {m68k_op_not_8_pi, 0xfff8, 0x4618, {12, 12, 8, 8, 8}},
        {m68k_op_not_8_pd, 0xfff8, 0x4620, {14, 14, 9, 9, 9}},
        {m68k_op_not_8_di, 0xfff8, 0x4628, {16, 16, 9, 9, 9}},
        {m68k_op_not_8_ix, 0xfff8, 0x4630, {18, 18, 11, 11, 11}},
        {m68k_op_not_16_d, 0xfff8, 0x4640, {4, 4, 2, 2, 2}},
        {m68k_op_not_16_ai, 0xfff8, 0x4650, {12, 12, 8, 8, 8}},
        {m68k_op_not_16_pi, 0xfff8, 0x4658, {12, 12, 8, 8, 8}},
        {m68k_op_not_16_pd, 0xfff8, 0x4660, {14, 14, 9, 9, 9}},
        {m68k_op_not_16_di, 0xfff8, 0x4668, {16, 16, 9, 9, 9}},
        {m68k_op_not_16_ix, 0xfff8, 0x4670, {18, 18, 11, 11, 11}},
        {m68k_op_not_32_d, 0xfff8, 0x4680, {6, 6, 2, 2, 2}},
        {m68k_op_not_32_ai, 0xfff8, 0x4690, {20, 20, 8, 8, 8}},
        {m68k_op_not_32_pi, 0xfff8, 0x4698, {20, 20, 8, 8, 8}},
        {m68k_op_not_32_pd, 0xfff8, 0x46a0, {22, 22, 9, 9, 9}},
        {m68k_op_not_32_di, 0xfff8, 0x46a8, {24, 24, 9, 9, 9}},
        {m68k_op_not_32_ix, 0xfff8, 0x46b0, {26, 26, 11, 11, 11}},
        {m68k_op_move_16_tos_d, 0xfff8, 0x46c0, {12, 12, 8, 8, 8}},
        {m68k_op_move_16_tos_ai, 0xfff8, 0x46d0, {16, 16, 12, 12, 12}},
        {m68k_op_move_16_tos_pi, 0xfff8, 0x46d8, {16, 16, 12, 12, 12}},
        {m68k_op_move_16_tos_pd, 0xfff8, 0x46e0, {18, 18, 13, 13, 13}},
        {m68k_op_move_16_tos_di, 0xfff8, 0x46e8, {20, 20, 13, 13, 13}},
        {m68k_op_move_16_tos_ix, 0xfff8, 0x46f0, {22, 22, 15, 15, 15}},
        {m68k_op_nbcd_8_d, 0xfff8, 0x4800, {6, 6, 6, 6, 6}},
        {m68k_op_link_32, 0xfff8, 0x4808, {0, 0, 6, 6, 6}},
        {m68k_op_nbcd_8_ai, 0xfff8, 0x4810, {12, 12, 10, 10, 10}},
        {m68k_op_nbcd_8_pi, 0xfff8, 0x4818, {12, 12, 10, 10, 10}},
        {m68k_op_nbcd_8_pd, 0xfff8, 0x4820, {14, 14, 11, 11, 11}},
        {m68k_op_nbcd_8_di, 0xfff8, 0x4828, {16, 16, 11, 11, 11}},
        {m68k_op_nbcd_8_ix, 0xfff8, 0x4830, {18, 18, 13, 13, 13}},
        {m68k_op_swap_32, 0xfff8, 0x4840, {4, 4, 4, 4, 4}},
        {m68k_op_bkpt, 0xfff8, 0x4848, {0, 10, 10, 10, 10}},
        {m68k_op_pea_32_ai, 0xfff8, 0x4850, {12, 12, 9, 9, 9}},
        {m68k_op_pea_32_di, 0xfff8, 0x4868, {16, 16, 10, 10, 10}},
        {m68k_op_pea_32_ix, 0xfff8, 0x4870, {20, 20, 12, 12, 12}},
        {m68k_op_ext_16, 0xfff8, 0x4880, {4, 4, 4, 4, 4}},
        {m68k_op_movem_16_re_ai, 0xfff8, 0x4890, {8, 8, 8, 8, 8}},
        {m68k_op_movem_16_re_pd, 0xfff8, 0x48a0, {8, 8, 4, 4, 4}},
        {m68k_op_movem_16_re_di, 0xfff8, 0x48a8, {12, 12, 9, 9, 9}},
        {m68k_op_movem_16_re_ix, 0xfff8, 0x48b0, {14, 14, 11, 11, 11}},
        {m68k_op_ext_32, 0xfff8, 0x48c0, {4, 4, 4, 4, 4}},
        {m68k_op_movem_32_re_ai, 0xfff8, 0x48d0, {8, 8, 8, 8, 8}},
        {m68k_op_movem_32_re_pd, 0xfff8, 0x48e0, {8, 8, 4, 4, 4}},
        {m68k_op_movem_32_re_di, 0xfff8, 0x48e8, {12, 12, 9, 9, 9}},
        {m68k_op_movem_32_re_ix, 0xfff8, 0x48f0, {14, 14, 11, 11, 11}},
        {m68k_op_extb_32, 0xfff8, 0x49c0, {0, 0, 4, 4, 4}},
        {m68k_op_tst_8_d, 0xfff8, 0x4a00, {4, 4, 2, 2, 2}},
        {m68k_op_tst_8_ai, 0xfff8, 0x4a10, {8, 8, 6, 6, 6}},
        {m68k_op_tst_8_pi, 0xfff8, 0x4a18, {8, 8, 6, 6, 6}},
        {m68k_op_tst_8_pd, 0xfff8, 0x4a20, {10, 10, 7, 7, 7}},
        {m68k_op_tst_8_di, 0xfff8, 0x4a28, {12, 12, 7, 7, 7}},
        {m68k_op_tst_8_ix, 0xfff8, 0x4a30, {14, 14, 9, 9, 9}},
        {m68k_op_tst_16_d, 0xfff8, 0x4a40, {4, 4, 2, 2, 2}},
        {m68k_op_tst_16_a, 0xfff8, 0x4a48, {0, 0, 2, 2, 2}},
        {m68k_op_tst_16_ai, 0xfff8, 0x4a50, {8, 8, 6, 6, 6}},
        {m68k_op_tst_16_pi, 0xfff8, 0x4a58, {8, 8, 6, 6, 6}},
        {m68k_op_tst_16_pd, 0xfff8, 0x4a60, {10, 10, 7, 7, 7}},
        {m68k_op_tst_16_di, 0xfff8, 0x4a68, {12, 12, 7, 7, 7}},
        {m68k_op_tst_16_ix, 0xfff8, 0x4a70, {14, 14, 9, 9, 9}},
        {m68k_op_tst_32_d, 0xfff8, 0x4a80, {4, 4, 2, 2, 2}},
        {m68k_op_tst_32_a, 0xfff8, 0x4a88, {0, 0, 2, 2, 2}},
        {m68k_op_tst_32_ai, 0xfff8, 0x4a90, {12, 12, 6, 6, 6}},
        {m68k_op_tst_32_pi, 0xfff8, 0x4a98, {12, 12, 6, 6, 6}},
        {m68k_op_tst_32_pd, 0xfff8, 0x4aa0, {14, 14, 7, 7, 7}},
        {m68k_op_tst_32_di, 0xfff8, 0x4aa8, {16, 16, 7, 7, 7}},
        {m68k_op_tst_32_ix, 0xfff8, 0x4ab0, {18, 18, 9, 9, 9}},
        {m68k_op_tas_8_d, 0xfff8, 0x4ac0, {4, 4, 4, 4, 4}},
        {m68k_op_tas_8_ai, 0xfff8, 0x4ad0, {18, 18, 16, 16, 16}},
        {m68k_op_tas_8_pi, 0xfff8, 0x4ad8, {18, 18, 16, 16, 16}},
        {m68k_op_tas_8_pd, 0xfff8, 0x4ae0, {20, 20, 17, 17, 17}},
        {m68k_op_tas_8_di, 0xfff8, 0x4ae8, {22, 22, 17, 17, 17}},
        {m68k_op_tas_8_ix, 0xfff8, 0x4af0, {24, 24, 19, 19, 19}},
        {m68k_op_mull_32_d, 0xfff8, 0x4c00, {0, 0, 43, 43, 43}},
        {m68k_op_mull_32_ai, 0xfff8, 0x4c10, {0, 0, 47, 47, 47}},
        {m68k_op_mull_32_pi, 0xfff8, 0x4c18, {0, 0, 47, 47, 47}},
        {m68k_op_mull_32_pd, 0xfff8, 0x4c20, {0, 0, 48, 48, 48}},
        {m68k_op_mull_32_di, 0xfff8, 0x4c28, {0, 0, 48, 48, 48}},
        {m68k_op_mull_32_ix, 0xfff8, 0x4c30, {0, 0, 50, 50, 50}},
        {m68k_op_divl_32_d, 0xfff8, 0x4c40, {0, 0, 84, 84, 84}},
        {m68k_op_divl_32_ai, 0xfff8, 0x4c50, {0, 0, 88, 88, 88}},
        {m68k_op_divl_32_pi, 0xfff8, 0x4c58, {0, 0, 88, 88, 88}},
        {m68k_op_divl_32_pd, 0xfff8, 0x4c60, {0, 0, 89, 89, 89}},
        {m68k_op_divl_32_di, 0xfff8, 0x4c68, {0, 0, 89, 89, 89}},
        {m68k_op_divl_32_ix, 0xfff8, 0x4c70, {0, 0, 91, 91, 91}},
        {m68k_op_movem_16_er_ai, 0xfff8, 0x4c90, {12, 12, 12, 12, 12}},
        {m68k_op_movem_16_er_pi, 0xfff8, 0x4c98, {12, 12, 8, 8, 8}},
        {m68k_op_movem_16_er_di, 0xfff8, 0x4ca8, {16, 16, 13, 13, 13}},
        {m68k_op_movem_16_er_ix, 0xfff8, 0x4cb0, {18, 18, 15, 15, 15}},
        {m68k_op_movem_32_er_ai, 0xfff8, 0x4cd0, {12, 12, 12, 12, 12}},
        {m68k_op_movem_32_er_pi, 0xfff8, 0x4cd8, {12, 12, 8, 8, 8}},
        {m68k_op_movem_32_er_di, 0xfff8, 0x4ce8, {16, 16, 13, 13, 13}},
        {m68k_op_movem_32_er_ix, 0xfff8, 0x4cf0, {18, 18, 15, 15, 15}},
        {m68k_op_link_16, 0xfff8, 0x4e50, {16, 16, 5, 5, 5}},
        {m68k_op_unlk_32, 0xfff8, 0x4e58, {12, 12, 6, 6, 6}},
        {m68k_op_move_32_tou, 0xfff8, 0x4e60, {4, 6, 2, 2, 2}},
        {m68k_op_move_32_fru, 0xfff8, 0x4e68, {4, 6, 2, 2, 2}},
        {m68k_op_jsr_32_ai, 0xfff8, 0x4e90, {16, 16, 4, 4, 4}},
        {m68k_op_jsr_32_di, 0xfff8, 0x4ea8, {18, 18, 5, 5, 5}},
        {m68k_op_jsr_32_ix, 0xfff8, 0x4eb0, {22, 22, 7, 7, 7}},
        {m68k_op_jmp_32_ai, 0xfff8, 0x4ed0, {8, 8, 4, 4, 4}},
        {m68k_op_jmp_32_di, 0xfff8, 0x4ee8, {10, 10, 5, 5, 5}},
        {m68k_op_jmp_32_ix, 0xfff8, 0x4ef0, {14, 14, 7, 7, 7}},
        {m68k_op_st_8_d, 0xfff8, 0x50c0, {6, 4, 4, 4, 4}},
        {m68k_op_dbt_16, 0xfff8, 0x50c8, {12, 12, 6, 6, 6}},
        {m68k_op_st_8_ai, 0xfff8, 0x50d0, {12, 12, 10, 10, 10}},
        {m68k_op_st_8_pi, 0xfff8, 0x50d8, {12, 12, 10, 10, 10}},
        {m68k_op_st_8_pd, 0xfff8, 0x50e0, {14, 14, 11, 11, 11}},
        {m68k_op_st_8_di, 0xfff8, 0x50e8, {16, 16, 11, 11, 11}},
        {m68k_op_st_8_ix, 0xfff8, 0x50f0, {18, 18, 13, 13, 13}},
        {m68k_op_sf_8_d, 0xfff8, 0x51c0, {4, 4, 4, 4, 4}},
        {m68k_op_dbf_16, 0xfff8, 0x51c8, {12, 12, 6, 6, 6}},
        {m68k_op_sf_8_ai, 0xfff8, 0x51d0, {12, 12, 10, 10, 10}},
        {m68k_op_sf_8_pi, 0xfff8, 0x51d8, {12, 12, 10, 10, 10}},
        {m68k_op_sf_8_pd, 0xfff8, 0x51e0, {14, 14, 11, 11, 11}},
        {m68k_op_sf_8_di, 0xfff8, 0x51e8, {16, 16, 11, 11, 11}},
        {m68k_op_sf_8_ix, 0xfff8, 0x51f0, {18, 18, 13, 13, 13}},
        {m68k_op_shi_8_d, 0xfff8, 0x52c0, {4, 4, 4, 4, 4}},
        {m68k_op_dbhi_16, 0xfff8, 0x52c8, {12, 12, 6, 6, 6}},
        {m68k_op_shi_8_ai, 0xfff8, 0x52d0, {12, 12, 10, 10, 10}},
        {m68k_op_shi_8_pi, 0xfff8, 0x52d8, {12, 12, 10, 10, 10}},
        {m68k_op_shi_8_pd, 0xfff8, 0x52e0, {14, 14, 11, 11, 11}},
        {m68k_op_shi_8_di, 0xfff8, 0x52e8, {16, 16, 11, 11, 11}},
        {m68k_op_shi_8_ix, 0xfff8, 0x52f0, {18, 18, 13, 13, 13}},
        {m68k_op_sls_8_d, 0xfff8, 0x53c0, {4, 4, 4, 4, 4}},
        {m68k_op_dbls_16, 0xfff8, 0x53c8, {12, 12, 6, 6, 6}},
        {m68k_op_sls_8_ai, 0xfff8, 0x53d0, {12, 12, 10, 10, 10}},
        {m68k_op_sls_8_pi, 0xfff8, 0x53d8, {12, 12, 10, 10, 10}},
        {m68k_op_sls_8_pd, 0xfff8, 0x53e0, {14, 14, 11, 11, 11}},
        {m68k_op_sls_8_di, 0xfff8, 0x53e8, {16, 16, 11, 11, 11}},
        {m68k_op_sls_8_ix, 0xfff8, 0x53f0, {18, 18, 13, 13, 13}},
        {m68k_op_scc_8_d, 0xfff8, 0x54c0, {4, 4, 4, 4, 4}},
        {m68k_op_dbcc_16, 0xfff8, 0x54c8, {12, 12, 6, 6, 6}},
        {m68k_op_scc_8_ai, 0xfff8, 0x54d0, {12, 12, 10, 10, 10}},
        {m68k_op_scc_8_pi, 0xfff8, 0x54d8, {12, 12, 10, 10, 10}},
        {m68k_op_scc_8_pd, 0xfff8, 0x54e0, {14, 14, 11, 11, 11}},
        {m68k_op_scc_8_di, 0xfff8, 0x54e8, {16, 16, 11, 11, 11}},
        {m68k_op_scc_8_ix, 0xfff8, 0x54f0, {18, 18, 13, 13, 13}},
        {m68k_op_scs_8_d, 0xfff8, 0x55c0, {4, 4, 4, 4, 4}},
        {m68k_op_dbcs_16, 0xfff8, 0x55c8, {12, 12, 6, 6, 6}},
        {m68k_op_scs_8_ai, 0xfff8, 0x55d0, {12, 12, 10, 10, 10}},
        {m68k_op_scs_8_pi, 0xfff8, 0x55d8, {12, 12, 10, 10, 10}},
        {m68k_op_scs_8_pd, 0xfff8, 0x55e0, {14, 14, 11, 11, 11}},
        {m68k_op_scs_8_di, 0xfff8, 0x55e8, {16, 16, 11, 11, 11}},
        {m68k_op_scs_8_ix, 0xfff8, 0x55f0, {18, 18, 13, 13, 13}},
        {m68k_op_sne_8_d, 0xfff8, 0x56c0, {4, 4, 4, 4, 4}},
        {m68k_op_dbne_16, 0xfff8, 0x56c8, {12, 12, 6, 6, 6}},
        {m68k_op_sne_8_ai, 0xfff8, 0x56d0, {12, 12, 10, 10, 10}},
        {m68k_op_sne_8_pi, 0xfff8, 0x56d8, {12, 12, 10, 10, 10}},
        {m68k_op_sne_8_pd, 0xfff8, 0x56e0, {14, 14, 11, 11, 11}},
        {m68k_op_sne_8_di, 0xfff8, 0x56e8, {16, 16, 11, 11, 11}},
        {m68k_op_sne_8_ix, 0xfff8, 0x56f0, {18, 18, 13, 13, 13}},
        {m68k_op_seq_8_d, 0xfff8, 0x57c0, {4, 4, 4, 4, 4}},
        {m68k_op_dbeq_16, 0xfff8, 0x57c8, {12, 12, 6, 6, 6}},
        {m68k_op_seq_8_ai, 0xfff8, 0x57d0, {12, 12, 10, 10, 10}},
        {m68k_op_seq_8_pi, 0xfff8, 0x57d8, {12, 12, 10, 10, 10}},
        {m68k_op_seq_8_pd, 0xfff8, 0x57e0, {14, 14, 11, 11, 11}},
        {m68k_op_seq_8_di, 0xfff8, 0x57e8, {16, 16, 11, 11, 11}},
        {m68k_op_seq_8_ix, 0xfff8, 0x57f0, {18, 18, 13, 13, 13}},
        {m68k_op_svc_8_d, 0xfff8, 0x58c0, {4, 4, 4, 4, 4}},
        {m68k_op_dbvc_16, 0xfff8, 0x58c8, {12, 12, 6, 6, 6}},
        {m68k_op_svc_8_ai, 0xfff8, 0x58d0, {12, 12, 10, 10, 10}},
        {m68k_op_svc_8_pi, 0xfff8, 0x58d8, {12, 12, 10, 10, 10}},
        {m68k_op_svc_8_pd, 0xfff8, 0x58e0, {14, 14, 11, 11, 11}},
        {m68k_op_svc_8_di, 0xfff8, 0x58e8, {16, 16, 11, 11, 11}},
        {m68k_op_svc_8_ix, 0xfff8, 0x58f0, {18, 18, 13, 13, 13}},
        {m68k_op_svs_8_d, 0xfff8, 0x59c0, {4, 4, 4, 4, 4}},
        {m68k_op_dbvs_16, 0xfff8, 0x59c8, {12, 12, 6, 6, 6}},
        {m68k_op_svs_8_ai, 0xfff8, 0x59d0, {12, 12, 10, 10, 10}},
        {m68k_op_svs_8_pi, 0xfff8, 0x59d8, {12, 12, 10, 10, 10}},
        {m68k_op_svs_8_pd, 0xfff8, 0x59e0, {14, 14, 11, 11, 11}},
        {m68k_op_svs_8_di, 0xfff8, 0x59e8, {16, 16, 11, 11, 11}},
        {m68k_op_svs_8_ix, 0xfff8, 0x59f0, {18, 18, 13, 13, 13}},
        {m68k_op_spl_8_d, 0xfff8, 0x5ac0, {4, 4, 4, 4, 4}},
        {m68k_op_dbpl_16, 0xfff8, 0x5ac8, {12, 12, 6, 6, 6}},
        {m68k_op_spl_8_ai, 0xfff8, 0x5ad0, {12, 12, 10, 10, 10}},
        {m68k_op_spl_8_pi, 0xfff8, 0x5ad8, {12, 12, 10, 10, 10}},
        {m68k_op_spl_8_pd, 0xfff8, 0x5ae0, {14, 14, 11, 11, 11}},
        {m68k_op_spl_8_di, 0xfff8, 0x5ae8, {16, 16, 11, 11, 11}},
        {m68k_op_spl_8_ix, 0xfff8, 0x5af0, {18, 18, 13, 13, 13}},
        {m68k_op_smi_8_d, 0xfff8, 0x5bc0, {4, 4, 4, 4, 4}},
        {m68k_op_dbmi_16, 0xfff8, 0x5bc8, {12, 12, 6, 6, 6}},
        {m68k_op_smi_8_ai, 0xfff8, 0x5bd0, {12, 12, 10, 10, 10}},
        {m68k_op_smi_8_pi, 0xfff8, 0x5bd8, {12, 12, 10, 10, 10}},
        {m68k_op_smi_8_pd, 0xfff8, 0x5be0, {14, 14, 11, 11, 11}},
        {m68k_op_smi_8_di, 0xfff8, 0x5be8, {16, 16, 11, 11, 11}},
        {m68k_op_smi_8_ix, 0xfff8, 0x5bf0, {18, 18, 13, 13, 13}},
        {m68k_op_sge_8_d, 0xfff8, 0x5cc0, {4, 4, 4, 4, 4}},
        {m68k_op_dbge_16, 0xfff8, 0x5cc8, {12, 12, 6, 6, 6}},
        {m68k_op_sge_8_ai, 0xfff8, 0x5cd0, {12, 12, 10, 10, 10}},
        {m68k_op_sge_8_pi, 0xfff8, 0x5cd8, {12, 12, 10, 10, 10}},
        {m68k_op_sge_8_pd, 0xfff8, 0x5ce0, {14, 14, 11, 11, 11}},
        {m68k_op_sge_8_di, 0xfff8, 0x5ce8, {16, 16, 11, 11, 11}},
        {m68k_op_sge_8_ix, 0xfff8, 0x5cf0, {18, 18, 13, 13, 13}},
        {m68k_op_slt_8_d, 0xfff8, 0x5dc0, {4, 4, 4, 4, 4}},
        {m68k_op_dblt_16, 0xfff8, 0x5dc8, {12, 12, 6, 6, 6}},
        {m68k_op_slt_8_ai, 0xfff8, 0x5dd0, {12, 12, 10, 10, 10}},
        {m68k_op_slt_8_pi, 0xfff8, 0x5dd8, {12, 12, 10, 10, 10}},
        {m68k_op_slt_8_pd, 0xfff8, 0x5de0, {14, 14, 11, 11, 11}},
        {m68k_op_slt_8_di, 0xfff8, 0x5de8, {16, 16, 11, 11, 11}},
        {m68k_op_slt_8_ix, 0xfff8, 0x5df0, {18, 18, 13, 13, 13}},
        {m68k_op_sgt_8_d, 0xfff8, 0x5ec0, {4, 4, 4, 4, 4}},
        {m68k_op_dbgt_16, 0xfff8, 0x5ec8, {12, 12, 6, 6, 6}},
        {m68k_op_sgt_8_ai, 0xfff8, 0x5ed0, {12, 12, 10, 10, 10}},
        {m68k_op_sgt_8_pi, 0xfff8, 0x5ed8, {12, 12, 10, 10, 10}},
        {m68k_op_sgt_8_pd, 0xfff8, 0x5ee0, {14, 14, 11, 11, 11}},
        {m68k_op_sgt_8_di, 0xfff8, 0x5ee8, {16, 16, 11, 11, 11}},
        {m68k_op_sgt_8_ix, 0xfff8, 0x5ef0, {18, 18, 13, 13, 13}},
        {m68k_op_sle_8_d, 0xfff8, 0x5fc0, {4, 4, 4, 4, 4}},
        {m68k_op_dble_16, 0xfff8, 0x5fc8, {12, 12, 6, 6, 6}},
        {m68k_op_sle_8_ai, 0xfff8, 0x5fd0, {12, 12, 10, 10, 10}},
        {m68k_op_sle_8_pi, 0xfff8, 0x5fd8, {12, 12, 10, 10, 10}},
        {m68k_op_sle_8_pd, 0xfff8, 0x5fe0, {14, 14, 11, 11, 11}},
        {m68k_op_sle_8_di, 0xfff8, 0x5fe8, {16, 16, 11, 11, 11}},
        {m68k_op_sle_8_ix, 0xfff8, 0x5ff0, {18, 18, 13, 13, 13}},
        {m68k_op_sbcd_8_mm_ax7, 0xfff8, 0x8f08, {18, 18, 16, 16, 16}},
        {m68k_op_pack_16_mm_ax7, 0xfff8, 0x8f48, {0, 0, 13, 13, 13}},
        {m68k_op_unpk_16_mm_ax7, 0xfff8, 0x8f88, {0, 0, 13, 13, 13}},
        {m68k_op_subx_8_mm_ax7, 0xfff8, 0x9f08, {18, 18, 12, 12, 12}},
        {m68k_op_cmpm_8_ax7, 0xfff8, 0xbf08, {12, 12, 9, 9, 9}},
        {m68k_op_abcd_8_mm_ax7, 0xfff8, 0xcf08, {18, 18, 16, 16, 16}},
        {m68k_op_addx_8_mm_ax7, 0xfff8, 0xdf08, {18, 18, 12, 12, 12}},
        {m68k_op_asr_16_ai, 0xfff8, 0xe0d0, {12, 12, 9, 9, 9}},
        {m68k_op_asr_16_pi, 0xfff8, 0xe0d8, {12, 12, 9, 9, 9}},
        {m68k_op_asr_16_pd, 0xfff8, 0xe0e0, {14, 14, 10, 10, 10}},
        {m68k_op_asr_16_di, 0xfff8, 0xe0e8, {16, 16, 10, 10, 10}},
        {m68k_op_asr_16_ix, 0xfff8, 0xe0f0, {18, 18, 12, 12, 12}},
        {m68k_op_asl_16_ai, 0xfff8, 0xe1d0, {12, 12, 10, 10, 10}},
        {m68k_op_asl_16_pi, 0xfff8, 0xe1d8, {12, 12, 10, 10, 10}},
        {m68k_op_asl_16_pd, 0xfff8, 0xe1e0, {14, 14, 11, 11, 11}},
        {m68k_op_asl_16_di, 0xfff8, 0xe1e8, {16, 16, 11, 11, 11}},
        {m68k_op_asl_16_ix, 0xfff8, 0xe1f0, {18, 18, 13, 13, 13}},
        {m68k_op_lsr_16_ai, 0xfff8, 0xe2d0, {12, 12, 9, 9, 9}},
        {m68k_op_lsr_16_pi, 0xfff8, 0xe2d8, {12, 12, 9, 9, 9}},
        {m68k_op_lsr_16_pd, 0xfff8, 0xe2e0, {14, 14, 10, 10, 10}},
        {m68k_op_lsr_16_di, 0xfff8, 0xe2e8, {16, 16, 10, 10, 10}},
        {m68k_op_lsr_16_ix, 0xfff8, 0xe2f0, {18, 18, 12, 12, 12}},
        {m68k_op_lsl_16_ai, 0xfff8, 0xe3d0, {12, 12, 9, 9, 9}},
        {m68k_op_lsl_16_pi, 0xfff8, 0xe3d8, {12, 12, 9, 9, 9}},
        {m68k_op_lsl_16_pd, 0xfff8, 0xe3e0, {14, 14, 10, 10, 10}},
        {m68k_op_lsl_16_di, 0xfff8, 0xe3e8, {16, 16, 10, 10, 10}},
        {m68k_op_lsl_16_ix, 0xfff8, 0xe3f0, {18, 18, 12, 12, 12}},
        {m68k_op_roxr_16_ai, 0xfff8, 0xe4d0, {12, 12, 9, 9, 9}},
        {m68k_op_roxr_16_pi, 0xfff8, 0xe4d8, {12, 12, 9, 9, 9}},
        {m68k_op_roxr_16_pd, 0xfff8, 0xe4e0, {14, 14, 10, 10, 10}},
        {m68k_op_roxr_16_di, 0xfff8, 0xe4e8, {16, 16, 10, 10, 10}},
        {m68k_op_roxr_16_ix, 0xfff8, 0xe4f0, {18, 18, 12, 12, 12}},
        {m68k_op_roxl_16_ai, 0xfff8, 0xe5d0, {12, 12, 9, 9, 9}},
        {m68k_op_roxl_16_pi, 0xfff8, 0xe5d8, {12, 12, 9, 9, 9}},
        {m68k_op_roxl_16_pd, 0xfff8, 0xe5e0, {14, 14, 10, 10, 10}},
        {m68k_op_roxl_16_di, 0xfff8, 0xe5e8, {16, 16, 10, 10, 10}},
        {m68k_op_roxl_16_ix, 0xfff8, 0xe5f0, {18, 18, 12, 12, 12}},
        {m68k_op_ror_16_ai, 0xfff8, 0xe6d0, {12, 12, 11, 11, 11}},
        {m68k_op_ror_16_pi, 0xfff8, 0xe6d8, {12, 12, 11, 11, 11}},
        {m68k_op_ror_16_pd, 0xfff8, 0xe6e0, {14, 14, 12, 12, 12}},
        {m68k_op_ror_16_di, 0xfff8, 0xe6e8, {16, 16, 12, 12, 12}},
        {m68k_op_ror_16_ix, 0xfff8, 0xe6f0, {18, 18, 14, 14, 14}},
        {m68k_op_rol_16_ai, 0xfff8, 0xe7d0, {12, 12, 11, 11, 11}},
        {m68k_op_rol_16_pi, 0xfff8, 0xe7d8, {12, 12, 11, 11, 11}},
        {m68k_op_rol_16_pd, 0xfff8, 0xe7e0, {14, 14, 12, 12, 12}},
        {m68k_op_rol_16_di, 0xfff8, 0xe7e8, {16, 16, 12, 12, 12}},
        {m68k_op_rol_16_ix, 0xfff8, 0xe7f0, {18, 18, 14, 14, 14}},
        {m68k_op_bftst_32_d, 0xfff8, 0xe8c0, {0, 0, 6, 6, 6}},
        {m68k_op_bftst_32_ai, 0xfff8, 0xe8d0, {0, 0, 17, 17, 17}},
        {m68k_op_bftst_32_di, 0xfff8, 0xe8e8, {0, 0, 18, 18, 18}},
        {m68k_op_bftst_32_ix, 0xfff8, 0xe8f0, {0, 0, 20, 20, 20}},
        {m68k_op_bfextu_32_d, 0xfff8, 0xe9c0, {0, 0, 8, 8, 8}},
        {m68k_op_bfextu_32_ai, 0xfff8, 0xe9d0, {0, 0, 19, 19, 19}},
        {m68k_op_bfextu_32_di, 0xfff8, 0xe9e8, {0, 0, 20, 20, 20}},
        {m68k_op_bfextu_32_ix, 0xfff8, 0xe9f0, {0, 0, 22, 22, 22}},
        {m68k_op_bfchg_32_d, 0xfff8, 0xeac0, {0, 0, 12, 12, 12}},
        {m68k_op_bfchg_32_ai, 0xfff8, 0xead0, {0, 0, 24, 24, 24}},
        {m68k_op_bfchg_32_di, 0xfff8, 0xeae8, {0, 0, 25, 25, 25}},
        {m68k_op_bfchg_32_ix, 0xfff8, 0xeaf0, {0, 0, 27, 27, 27}},
        {m68k_op_bfexts_32_d, 0xfff8, 0xebc0, {0, 0, 8, 8, 8}},
        {m68k_op_bfexts_32_ai, 0xfff8, 0xebd0, {0, 0, 19, 19, 19}},
        {m68k_op_bfexts_32_di, 0xfff8, 0xebe8, {0, 0, 20, 20, 20}},
        {m68k_op_bfexts_32_ix, 0xfff8, 0xebf0, {0, 0, 22, 22, 22}},
        {m68k_op_bfclr_32_d, 0xfff8, 0xecc0, {0, 0, 12, 12, 12}},
        {m68k_op_bfclr_32_ai, 0xfff8, 0xecd0, {0, 0, 24, 24, 24}},
        {m68k_op_bfclr_32_di, 0xfff8, 0xece8, {0, 0, 25, 25, 25}},
        {m68k_op_bfclr_32_ix, 0xfff8, 0xecf0, {0, 0, 27, 27, 27}},
        {m68k_op_bfffo_32_d, 0xfff8, 0xedc0, {0, 0, 18, 18, 18}},
        {m68k_op_bfffo_32_ai, 0xfff8, 0xedd0, {0, 0, 32, 32, 32}},
        {m68k_op_bfffo_32_di, 0xfff8, 0xede8, {0, 0, 33, 33, 33}},
        {m68k_op_bfffo_32_ix, 0xfff8, 0xedf0, {0, 0, 35, 35, 35}},
        {m68k_op_bfset_32_d, 0xfff8, 0xeec0, {0, 0, 12, 12, 12}},
        {m68k_op_bfset_32_ai, 0xfff8, 0xeed0, {0, 0, 24, 24, 24}},
        {m68k_op_bfset_32_di, 0xfff8, 0xeee8, {0, 0, 25, 25, 25}},
        {m68k_op_bfset_32_ix, 0xfff8, 0xeef0, {0, 0, 27, 27, 27}},
        {m68k_op_bfins_32_d, 0xfff8, 0xefc0, {0, 0, 10, 10, 10}},
        {m68k_op_bfins_32_ai, 0xfff8, 0xefd0, {0, 0, 21, 21, 21}},
        {m68k_op_bfins_32_di, 0xfff8, 0xefe8, {0, 0, 22, 22, 22}},
        {m68k_op_bfins_32_ix, 0xfff8, 0xeff0, {0, 0, 24, 24, 24}},
        {m68k_op_move16_32, 0xfff8, 0xf620, {0, 0, 0, 0, 4}},
        {m68k_op_ori_8_pi7, 0xffff, 0x001f, {16, 16, 8, 8, 8}},
        {m68k_op_ori_8_pd7, 0xffff, 0x0027, {18, 18, 9, 9, 9}},
        {m68k_op_ori_8_aw, 0xffff, 0x0038, {20, 20, 8, 8, 8}},
        {m68k_op_ori_8_al, 0xffff, 0x0039, {24, 24, 8, 8, 8}},
        {m68k_op_ori_16_toc, 0xffff, 0x003c, {20, 16, 12, 12, 12}},
        {m68k_op_ori_16_aw, 0xffff, 0x0078, {20, 20, 8, 8, 8}},
        {m68k_op_ori_16_al, 0xffff, 0x0079, {24, 24, 8, 8, 8}},
        {m68k_op_ori_16_tos, 0xffff, 0x007c, {20, 16, 12, 12, 12}},
        {m68k_op_ori_32_aw, 0xffff, 0x00b8, {32, 32, 8, 8, 8}},
        {m68k_op_ori_32_al, 0xffff, 0x00b9, {36, 36, 8, 8, 8}},
        {m68k_op_chk2cmp2_8_aw, 0xffff, 0x00f8, {0, 0, 22, 22, 22}},
        {m68k_op_chk2cmp2_8_al, 0xffff, 0x00f9, {0, 0, 22, 22, 22}},
        {m68k_op_chk2cmp2_8_pcdi, 0xffff, 0x00fa, {0, 0, 23, 23, 23}},
        {m68k_op_chk2cmp2_8_pcix, 0xffff, 0x00fb, {0, 0, 23, 23, 23}},
        {m68k_op_andi_8_pi7, 0xffff, 0x021f, {16, 16, 8, 8, 8}},
        {m68k_op_andi_8_pd7, 0xffff, 0x0227, {18, 18, 9, 9, 9}},
        {m68k_op_andi_8_aw, 0xffff, 0x0238, {20, 20, 8, 8, 8}},
        {m68k_op_andi_8_al, 0xffff, 0x0239, {24, 24, 8, 8, 8}},
        {m68k_op_andi_16_toc, 0xffff, 0x023c, {20, 16, 12, 12, 12}},
        {m68k_op_andi_16_aw, 0xffff, 0x0278, {20, 20, 8, 8, 8}},
        {m68k_op_andi_16_al, 0xffff, 0x0279, {24, 24, 8, 8, 8}},
        {m68k_op_andi_16_tos, 0xffff, 0x027c, {20, 16, 12, 12, 12}},
        {m68k_op_andi_32_aw, 0xffff, 0x02b8, {32, 32, 8, 8, 8}},
        {m68k_op_andi_32_al, 0xffff, 0x02b9, {36, 36, 8, 8, 8}},
        {m68k_op_chk2cmp2_16_aw, 0xffff, 0x02f8, {0, 0, 22, 22, 22}},
        {m68k_op_chk2cmp2_16_al, 0xffff, 0x02f9, {0, 0, 22, 22, 22}},
        {m68k_op_chk2cmp2_16_pcdi, 0xffff, 0x02fa, {0, 0, 23, 23, 23}},
        {m68k_op_chk2cmp2_16_pcix, 0xffff, 0x02fb, {0, 0, 23, 23, 23}},
        {m68k_op_subi_8_pi7, 0xffff, 0x041f, {16, 16, 8, 8, 8}},
        {m68k_op_subi_8_pd7, 0xffff, 0x0427, {18, 18, 9, 9, 9}},
        {m68k_op_subi_8_aw, 0xffff, 0x0438, {20, 20, 8, 8, 8}},
        {m68k_op_subi_8_al, 0xffff, 0x0439, {24, 24, 8, 8, 8}},
        {m68k_op_subi_16_aw, 0xffff, 0x0478, {20, 20, 8, 8, 8}},
        {m68k_op_subi_16_al, 0xffff, 0x0479, {24, 24, 8, 8, 8}},
        {m68k_op_subi_32_aw, 0xffff, 0x04b8, {32, 32, 8, 8, 8}},
        {m68k_op_subi_32_al, 0xffff, 0x04b9, {36, 36, 8, 8, 8}},
        {m68k_op_chk2cmp2_32_aw, 0xffff, 0x04f8, {0, 0, 22, 22, 22}},
        {m68k_op_chk2cmp2_32_al, 0xffff, 0x04f9, {0, 0, 22, 22, 22}},
        {m68k_op_chk2cmp2_32_pcdi, 0xffff, 0x04fa, {0, 0, 23, 23, 23}},
        {m68k_op_chk2cmp2_32_pcix, 0xffff, 0x04fb, {0, 0, 23, 23, 23}},
        {m68k_op_addi_8_pi7, 0xffff, 0x061f, {16, 16, 8, 8, 8}},
        {m68k_op_addi_8_pd7, 0xffff, 0x0627, {18, 18, 9, 9, 9}},
        {m68k_op_addi_8_aw, 0xffff, 0x0638, {20, 20, 8, 8, 8}},
        {m68k_op_addi_8_al, 0xffff, 0x0639, {24, 24, 8, 8, 8}},
        {m68k_op_addi_16_aw, 0xffff, 0x0678, {20, 20, 8, 8, 8}},
        {m68k_op_addi_16_al, 0xffff, 0x0679, {24, 24, 8, 8, 8}},
        {m68k_op_addi_32_aw, 0xffff, 0x06b8, {32, 32, 8, 8, 8}},
        {m68k_op_addi_32_al, 0xffff, 0x06b9, {36, 36, 8, 8, 8}},
        {m68k_op_callm_32_aw, 0xffff, 0x06f8, {0, 0, 64, 64, 64}},
        {m68k_op_callm_32_al, 0xffff, 0x06f9, {0, 0, 64, 64, 64}},
        {m68k_op_callm_32_pcdi, 0xffff, 0x06fa, {0, 0, 65, 65, 65}},
        {m68k_op_callm_32_pcix, 0xffff, 0x06fb, {0, 0, 67, 67, 67}},
        {m68k_op_btst_8_s_pi7, 0xffff, 0x081f, {12, 12, 8, 8, 8}},
        {m68k_op_btst_8_s_pd7, 0xffff, 0x0827, {14, 14, 9, 9, 9}},
        {m68k_op_btst_8_s_aw, 0xffff, 0x0838, {16, 16, 8, 8, 8}},
        {m68k_op_btst_8_s_al, 0xffff, 0x0839, {20, 20, 8, 8, 8}},
        {m68k_op_btst_8_s_pcdi, 0xffff, 0x083a, {16, 16, 9, 9, 9}},
        {m68k_op_btst_8_s_pcix, 0xffff, 0x083b, {18, 18, 11, 11, 11}},
        {m68k_op_bchg_8_s_pi7, 0xffff, 0x085f, {16, 16, 8, 8, 8}},
        {m68k_op_bchg_8_s_pd7, 0xffff, 0x0867, {18, 18, 9, 9, 9}},
        {m68k_op_bchg_8_s_aw, 0xffff, 0x0878, {20, 20, 8, 8, 8}},
        {m68k_op_bchg_8_s_al, 0xffff, 0x0879, {24, 24, 8, 8, 8}},
        {m68k_op_bclr_8_s_pi7, 0xffff, 0x089f, {16, 16, 8, 8, 8}},
        {m68k_op_bclr_8_s_pd7, 0xffff, 0x08a7, {18, 18, 9, 9, 9}},
        {m68k_op_bclr_8_s_aw, 0xffff, 0x08b8, {20, 20, 8, 8, 8}},
        {m68k_op_bclr_8_s_al, 0xffff, 0x08b9, {24, 24, 8, 8, 8}},
        {m68k_op_bset_8_s_pi7, 0xffff, 0x08df, {16, 16, 8, 8, 8}},
        {m68k_op_bset_8_s_pd7, 0xffff, 0x08e7, {18, 18, 9, 9, 9}},
        {m68k_op_bset_8_s_aw, 0xffff, 0x08f8, {20, 20, 8, 8, 8}},
        {m68k_op_bset_8_s_al, 0xffff, 0x08f9, {24, 24, 8, 8, 8}},
        {m68k_op_eori_8_pi7, 0xffff, 0x0a1f, {16, 16, 8, 8, 8}},
        {m68k_op_eori_8_pd7, 0xffff, 0x0a27, {18, 18, 9, 9, 9}},
        {m68k_op_eori_8_aw, 0xffff, 0x0a38, {20, 20, 8, 8, 8}},
        {m68k_op_eori_8_al, 0xffff, 0x0a39, {24, 24, 8, 8, 8}},
        {m68k_op_eori_16_toc, 0xffff, 0x0a3c, {20, 16, 12, 12, 12}},
        {m68k_op_eori_16_aw, 0xffff, 0x0a78, {20, 20, 8, 8, 8}},
        {m68k_op_eori_16_al, 0xffff, 0x0a79, {24, 24, 8, 8, 8}},
        {m68k_op_eori_16_tos, 0xffff, 0x0a7c, {20, 16, 12, 12, 12}},
        {m68k_op_eori_32_aw, 0xffff, 0x0ab8, {32, 32, 8, 8, 8}},
        {m68k_op_eori_32_al, 0xffff, 0x0ab9, {36, 36, 8, 8, 8}},
        {m68k_op_cas_8_pi7, 0xffff, 0x0adf, {0, 0, 16, 16, 16}},
        {m68k_op_cas_8_pd7, 0xffff, 0x0ae7, {0, 0, 17, 17, 17}},
        {m68k_op_cas_8_aw, 0xffff, 0x0af8, {0, 0, 16, 16, 16}},
        {m68k_op_cas_8_al, 0xffff, 0x0af9, {0, 0, 16, 16, 16}},
        {m68k_op_cmpi_8_pi7, 0xffff, 0x0c1f, {12, 12, 6, 6, 6}},
        {m68k_op_cmpi_8_pd7, 0xffff, 0x0c27, {14, 14, 7, 7, 7}},
        {m68k_op_cmpi_8_aw, 0xffff, 0x0c38, {16, 16, 6, 6, 6}},
        {m68k_op_cmpi_8_al, 0xffff, 0x0c39, {20, 20, 6, 6, 6}},
        {m68k_op_cmpi_8_pcdi, 0xffff, 0x0c3a, {0, 0, 7, 7, 7}},
        {m68k_op_cmpi_8_pcix, 0xffff, 0x0c3b, {0, 0, 9, 9, 9}},
        {m68k_op_cmpi_16_aw, 0xffff, 0x0c78, {16, 16, 6, 6, 6}},
        {m68k_op_cmpi_16_al, 0xffff, 0x0c79, {20, 20, 6, 6, 6}},
        {m68k_op_cmpi_16_pcdi, 0xffff, 0x0c7a, {0, 0, 7, 7, 7}},
        {m68k_op_cmpi_16_pcix, 0xffff, 0x0c7b, {0, 0, 9, 9, 9}},
        {m68k_op_cmpi_32_aw, 0xffff, 0x0cb8, {24, 24, 6, 6, 6}},
        {m68k_op_cmpi_32_al, 0xffff, 0x0cb9, {28, 28, 6, 6, 6}},
        {m68k_op_cmpi_32_pcdi, 0xffff, 0x0cba, {0, 0, 7, 7, 7}},
        {m68k_op_cmpi_32_pcix, 0xffff, 0x0cbb, {0, 0, 9, 9, 9}},
        {m68k_op_cas_16_aw, 0xffff, 0x0cf8, {0, 0, 16, 16, 16}},
        {m68k_op_cas_16_al, 0xffff, 0x0cf9, {0, 0, 16, 16, 16}},
        {m68k_op_cas2_16, 0xffff, 0x0cfc, {0, 0, 12, 12, 12}},
        {m68k_op_moves_8_pi7, 0xffff, 0x0e1f, {0, 18, 9, 9, 9}},
        {m68k_op_moves_8_pd7, 0xffff, 0x0e27, {0, 20, 10, 10, 10}},
        {m68k_op_moves_8_aw, 0xffff, 0x0e38, {0, 26, 9, 9, 9}},
        {m68k_op_moves_8_al, 0xffff, 0x0e39, {0, 30, 9, 9, 9}},
        {m68k_op_moves_16_aw, 0xffff, 0x0e78, {0, 26, 9, 9, 9}},
        {m68k_op_moves_16_al, 0xffff, 0x0e79, {0, 30, 9, 9, 9}},
        {m68k_op_moves_32_aw, 0xffff, 0x0eb8, {0, 32, 9, 9, 9}},
        {m68k_op_moves_32_al, 0xffff, 0x0eb9, {0, 36, 9, 9, 9}},
        {m68k_op_cas_32_aw, 0xffff, 0x0ef8, {0, 0, 16, 16, 16}},
        {m68k_op_cas_32_al, 0xffff, 0x0ef9, {0, 0, 16, 16, 16}},
        {m68k_op_cas2_32, 0xffff, 0x0efc, {0, 0, 12, 12, 12}},
        {m68k_op_move_8_aw_pi7, 0xffff, 0x11df, {16, 16, 8, 8, 8}},
        {m68k_op_move_8_aw_pd7, 0xffff, 0x11e7, {18, 18, 9, 9, 9}},
        {m68k_op_move_8_aw_aw, 0xffff, 0x11f8, {20, 20, 8, 8, 8}},
        {m68k_op_move_8_aw_al, 0xffff, 0x11f9, {24, 24, 8, 8, 8}},
        {m68k_op_move_8_aw_pcdi, 0xffff, 0x11fa, {20, 20, 9, 9, 9}},
        {m68k_op_move_8_aw_pcix, 0xffff, 0x11fb, {22, 22, 11, 11, 11}},
        {m68k_op_move_8_aw_i, 0xffff, 0x11fc, {16, 16, 6, 6, 6}},
        {m68k_op_move_8_al_pi7, 0xffff, 0x13df, {20, 20, 10, 10, 10}},
        {m68k_op_move_8_al_pd7, 0xffff, 0x13e7, {22, 22, 11, 11, 11}},
        {m68k_op_move_8_al_aw, 0xffff, 0x13f8, {24, 24, 10, 10, 10}},
        {m68k_op_move_8_al_al, 0xffff, 0x13f9, {28, 28, 10, 10, 10}},
        {m68k_op_move_8_al_pcdi, 0xffff, 0x13fa, {24, 24, 11, 11, 11}},
        {m68k_op_move_8_al_pcix, 0xffff, 0x13fb, {26, 26, 13, 13, 13}},
        {m68k_op_move_8_al_i, 0xffff, 0x13fc, {20, 20, 8, 8, 8}},
        {m68k_op_move_8_pi7_pi7, 0xffff, 0x1edf, {12, 12, 8, 8, 8}},
        {m68k_op_move_8_pi7_pd7, 0xffff, 0x1ee7, {14, 14, 9, 9, 9}},
        {m68k_op_move_8_pi7_aw, 0xffff, 0x1ef8, {16, 16, 8, 8, 8}},
        {m68k_op_move_8_pi7_al, 0xffff, 0x1ef9, {20, 20, 8, 8, 8}},
        {m68k_op_move_8_pi7_pcdi, 0xffff, 0x1efa, {16, 16, 9, 9, 9}},
        {m68k_op_move_8_pi7_pcix, 0xffff, 0x1efb, {18, 18, 11, 11, 11}},
        {m68k_op_move_8_pi7_i, 0xffff, 0x1efc, {12, 12, 6, 6, 6}},
        {m68k_op_move_8_pd7_pi7, 0xffff, 0x1f1f, {12, 12, 9, 9, 9}},
        {m68k_op_move_8_pd7_pd7, 0xffff, 0x1f27, {14, 14, 10, 10, 10}},
        {m68k_op_move_8_pd7_aw, 0xffff, 0x1f38, {16, 16, 9, 9, 9}},
        {m68k_op_move_8_pd7_al, 0xffff, 0x1f39, {20, 20, 9, 9, 9}},
        {m68k_op_move_8_pd7_pcdi, 0xffff, 0x1f3a, {16, 16, 10, 10, 10}},
        {m68k_op_move_8_pd7_pcix, 0xffff, 0x1f3b, {18, 18, 12, 12, 12}},
        {m68k_op_move_8_pd7_i, 0xffff, 0x1f3c, {12, 12, 7, 7, 7}},
        {m68k_op_move_32_aw_aw, 0xffff, 0x21f8, {28, 28, 8, 8, 8}},
        {m68k_op_move_32_aw_al, 0xffff, 0x21f9, {32, 32, 8, 8, 8}},
        {m68k_op_move_32_aw_pcdi, 0xffff, 0x21fa, {28, 28, 9, 9, 9}},
        {m68k_op_move_32_aw_pcix, 0xffff, 0x21fb, {30, 30, 11, 11, 11}},
        {m68k_op_move_32_aw_i, 0xffff, 0x21fc, {24, 24, 8, 8, 8}},
        {m68k_op_move_32_al_aw, 0xffff, 0x23f8, {32, 32, 10, 10, 10}},
        {m68k_op_move_32_al_al, 0xffff, 0x23f9, {36, 36, 10, 10, 10}},
        {m68k_op_move_32_al_pcdi, 0xffff, 0x23fa, {32, 32, 11, 11, 11}},
        {m68k_op_move_32_al_pcix, 0xffff, 0x23fb, {34, 34, 13, 13, 13}},
        {m68k_op_move_32_al_i, 0xffff, 0x23fc, {28, 28, 10, 10, 10}},
        {m68k_op_move_16_aw_aw, 0xffff, 0x31f8, {20, 20, 8, 8, 8}},
        {m68k_op_move_16_aw_al, 0xffff, 0x31f9, {24, 24, 8, 8, 8}},
        {m68k_op_move_16_aw_pcdi, 0xffff, 0x31fa, {20, 20, 9, 9, 9}},
        {m68k_op_move_16_aw_pcix, 0xffff, 0x31fb, {22, 22, 11, 11, 11}},
        {m68k_op_move_16_aw_i, 0xffff, 0x31fc, {16, 16, 6, 6, 6}},
        {m68k_op_move_16_al_aw, 0xffff, 0x33f8, {24, 24, 10, 10, 10}},
        {m68k_op_move_16_al_al, 0xffff, 0x33f9, {28, 28, 10, 10, 10}},
        {m68k_op_move_16_al_pcdi, 0xffff, 0x33fa, {24, 24, 11, 11, 11}},
        {m68k_op_move_16_al_pcix, 0xffff, 0x33fb, {26, 26, 13, 13, 13}},
        {m68k_op_move_16_al_i, 0xffff, 0x33fc, {20, 20, 8, 8, 8}},
        {m68k_op_negx_8_pi7, 0xffff, 0x401f, {12, 12, 8, 8, 8}},
        {m68k_op_negx_8_pd7, 0xffff, 0x4027, {14, 14, 9, 9, 9}},
        {m68k_op_negx_8_aw, 0xffff, 0x4038, {16, 16, 8, 8, 8}},
        {m68k_op_negx_8_al, 0xffff, 0x4039, {20, 20, 8, 8, 8}},
        {m68k_op_negx_16_aw, 0xffff, 0x4078, {16, 16, 8, 8, 8}},
        {m68k_op_negx_16_al, 0xffff, 0x4079, {20, 20, 8, 8, 8}},
        {m68k_op_negx_32_aw, 0xffff, 0x40b8, {24, 24, 8, 8, 8}},
        {m68k_op_negx_32_al, 0xffff, 0x40b9, {28, 28, 8, 8, 8}},
        {m68k_op_move_16_frs_aw, 0xffff, 0x40f8, {16, 16, 12, 12, 12}},
        {m68k_op_move_16_frs_al, 0xffff, 0x40f9, {20, 20, 12, 12, 12}},
        {m68k_op_clr_8_pi7, 0xffff, 0x421f, {12, 8, 8, 8, 8}},
        {m68k_op_clr_8_pd7, 0xffff, 0x4227, {14, 10, 9, 9, 9}},
        {m68k_op_clr_8_aw, 0xffff, 0x4238, {16, 12, 8, 8, 8}},
        {m68k_op_clr_8_al, 0xffff, 0x4239, {20, 14, 8, 8, 8}},
        {m68k_op_clr_16_aw, 0xffff, 0x4278, {16, 12, 8, 8, 8}},
        {m68k_op_clr_16_al, 0xffff, 0x4279, {20, 14, 8, 8, 8}},
        {m68k_op_clr_32_aw, 0xffff, 0x42b8, {24, 16, 8, 8, 8}},
        {m68k_op_clr_32_al, 0xffff, 0x42b9, {28, 20, 8, 8, 8}},
        {m68k_op_move_16_frc_aw, 0xffff, 0x42f8, {0, 16, 8, 8, 8}},
        {m68k_op_move_16_frc_al, 0xffff, 0x42f9, {0, 20, 8, 8, 8}},
        {m68k_op_neg_8_pi7, 0xffff, 0x441f, {12, 12, 8, 8, 8}},
        {m68k_op_neg_8_pd7, 0xffff, 0x4427, {14, 14, 9, 9, 9}},
        {m68k_op_neg_8_aw, 0xffff, 0x4438, {16, 16, 8, 8, 8}},
        {m68k_op_neg_8_al, 0xffff, 0x4439, {20, 20, 8, 8, 8}},
        {m68k_op_neg_16_aw, 0xffff, 0x4478, {16, 16, 8, 8, 8}},
        {m68k_op_neg_16_al, 0xffff, 0x4479, {20, 20, 8, 8, 8}},
        {m68k_op_neg_32_aw, 0xffff, 0x44b8, {24, 24, 8, 8, 8}},
        {m68k_op_neg_32_al, 0xffff, 0x44b9, {28, 28, 8, 8, 8}},
        {m68k_op_move_16_toc_aw, 0xffff, 0x44f8, {20, 20, 8, 8, 8}},
        {m68k_op_move_16_toc_al, 0xffff, 0x44f9, {24, 24, 8, 8, 8}},
        {m68k_op_move_16_toc_pcdi, 0xffff, 0x44fa, {20, 20, 9, 9, 9}},
        {m68k_op_move_16_toc_pcix, 0xffff, 0x44fb, {22, 22, 11, 11, 11}},
        {m68k_op_move_16_toc_i, 0xffff, 0x44fc, {16, 16, 6, 6, 6}},
        {m68k_op_not_8_pi7, 0xffff, 0x461f, {12, 12, 8, 8, 8}},
        {m68k_op_not_8_pd7, 0xffff, 0x4627, {14, 14, 9, 9, 9}},
        {m68k_op_not_8_aw, 0xffff, 0x4638, {16, 16, 8, 8, 8}},
        {m68k_op_not_8_al, 0xffff, 0x4639, {20, 20, 8, 8, 8}},
        {m68k_op_not_16_aw, 0xffff, 0x4678, {16, 16, 8, 8, 8}},
        {m68k_op_not_16_al, 0xffff, 0x4679, {20, 20, 8, 8, 8}},
        {m68k_op_not_32_aw, 0xffff, 0x46b8, {24, 24, 8, 8, 8}},
        {m68k_op_not_32_al, 0xffff, 0x46b9, {28, 28, 8, 8, 8}},
        {m68k_op_move_16_tos_aw, 0xffff, 0x46f8, {20, 20, 12, 12, 12}},
        {m68k_op_move_16_tos_al, 0xffff, 0x46f9, {24, 24, 12, 12, 12}},
        {m68k_op_move_16_tos_pcdi, 0xffff, 0x46fa, {20, 20, 13, 13, 13}},
        {m68k_op_move_16_tos_pcix, 0xffff, 0x46fb, {22, 22, 15, 15, 15}},
        {m68k_op_move_16_tos_i, 0xffff, 0x46fc, {16, 16, 10, 10, 10}},
        {m68k_op_link_32_a7, 0xffff, 0x480f, {0, 0, 6, 6, 6}},
        {m68k_op_nbcd_8_pi7, 0xffff, 0x481f, {12, 12, 10, 10, 10}},
        {m68k_op_nbcd_8_pd7, 0xffff, 0x4827, {14, 14, 11, 11, 11}},
        {m68k_op_nbcd_8_aw, 0xffff, 0x4838, {16, 16, 10, 10, 10}},
        {m68k_op_nbcd_8_al, 0xffff, 0x4839, {20, 20, 10, 10, 10}},
        {m68k_op_pea_32_aw, 0xffff, 0x4878, {16, 16, 9, 9, 9}},
        {m68k_op_pea_32_al, 0xffff, 0x4879, {20, 20, 9, 9, 9}},
        {m68k_op_pea_32_pcdi, 0xffff, 0x487a, {16, 16, 10, 10, 10}},
        {m68k_op_pea_32_pcix, 0xffff, 0x487b, {20, 20, 12, 12, 12}},
        {m68k_op_movem_16_re_aw, 0xffff, 0x48b8, {12, 12, 8, 8, 8}},
        {m68k_op_movem_16_re_al, 0xffff, 0x48b9, {16, 16, 8, 8, 8}},
        {m68k_op_movem_32_re_aw, 0xffff, 0x48f8, {12, 12, 8, 8, 8}},
        {m68k_op_movem_32_re_al, 0xffff, 0x48f9, {16, 16, 8, 8, 8}},
        {m68k_op_tst_8_pi7, 0xffff, 0x4a1f, {8, 8, 6, 6, 6}},
        {m68k_op_tst_8_pd7, 0xffff, 0x4a27, {10, 10, 7, 7, 7}},
        {m68k_op_tst_8_aw, 0xffff, 0x4a38, {12, 12, 6, 6, 6}},
        {m68k_op_tst_8_al, 0xffff, 0x4a39, {16, 16, 6, 6, 6}},
        {m68k_op_tst_8_pcdi, 0xffff, 0x4a3a, {0, 0, 7, 7, 7}},
        {m68k_op_tst_8_pcix, 0xffff, 0x4a3b, {0, 0, 9, 9, 9}},
        {m68k_op_tst_8_i, 0xffff, 0x4a3c, {0, 0, 6, 6, 6}},
        {m68k_op_tst_16_aw, 0xffff, 0x4a78, {12, 12, 6, 6, 6}},
        {m68k_op_tst_16_al, 0xffff, 0x4a79, {16, 16, 6, 6, 6}},
        {m68k_op_tst_16_pcdi, 0xffff, 0x4a7a, {0, 0, 7, 7, 7}},
        {m68k_op_tst_16_pcix, 0xffff, 0x4a7b, {0, 0, 9, 9, 9}},
        {m68k_op_tst_16_i, 0xffff, 0x4a7c, {0, 0, 6, 6, 6}},
        {m68k_op_tst_32_aw, 0xffff, 0x4ab8, {16, 16, 6, 6, 6}},
        {m68k_op_tst_32_al, 0xffff, 0x4ab9, {20, 20, 6, 6, 6}},
        {m68k_op_tst_32_pcdi, 0xffff, 0x4aba, {0, 0, 7, 7, 7}},
        {m68k_op_tst_32_pcix, 0xffff, 0x4abb, {0, 0, 9, 9, 9}},
        {m68k_op_tst_32_i, 0xffff, 0x4abc, {0, 0, 6, 6, 6}},
        {m68k_op_tas_8_pi7, 0xffff, 0x4adf, {18, 18, 16, 16, 16}},
        {m68k_op_tas_8_pd7, 0xffff, 0x4ae7, {20, 20, 17, 17, 17}},
        {m68k_op_tas_8_aw, 0xffff, 0x4af8, {22, 22, 16, 16, 16}},
        {m68k_op_tas_8_al, 0xffff, 0x4af9, {26, 26, 16, 16, 16}},
        {m68k_op_illegal, 0xffff, 0x4afc, {4, 4, 4, 4, 4}},
        {m68k_op_mull_32_aw, 0xffff, 0x4c38, {0, 0, 47, 47, 47}},
        {m68k_op_mull_32_al, 0xffff, 0x4c39, {0, 0, 47, 47, 47}},
        {m68k_op_mull_32_pcdi, 0xffff, 0x4c3a, {0, 0, 48, 48, 48}},
        {m68k_op_mull_32_pcix, 0xffff, 0x4c3b, {0, 0, 50, 50, 50}},
        {m68k_op_mull_32_i, 0xffff, 0x4c3c, {0, 0, 47, 47, 47}},
        {m68k_op_divl_32_aw, 0xffff, 0x4c78, {0, 0, 88, 88, 88}},
        {m68k_op_divl_32_al, 0xffff, 0x4c79, {0, 0, 88, 88, 88}},
        {m68k_op_divl_32_pcdi, 0xffff, 0x4c7a, {0, 0, 89, 89, 89}},
        {m68k_op_divl_32_pcix, 0xffff, 0x4c7b, {0, 0, 91, 91, 91}},
        {m68k_op_divl_32_i, 0xffff, 0x4c7c, {0, 0, 88, 88, 88}},
        {m68k_op_movem_16_er_aw, 0xffff, 0x4cb8, {16, 16, 12, 12, 12}},
        {m68k_op_movem_16_er_al, 0xffff, 0x4cb9, {20, 20, 12, 12, 12}},
        {m68k_op_movem_16_er_pcdi, 0xffff, 0x4cba, {16, 16, 9, 9, 9}},
        {m68k_op_movem_16_er_pcix, 0xffff, 0x4cbb, {18, 18, 11, 11, 11}},
        {m68k_op_movem_32_er_aw, 0xffff, 0x4cf8, {16, 16, 12, 12, 12}},
        {m68k_op_movem_32_er_al, 0xffff, 0x4cf9, {20, 20, 12, 12, 12}},
        {m68k_op_movem_32_er_pcdi, 0xffff, 0x4cfa, {16, 16, 9, 9, 9}},
        {m68k_op_movem_32_er_pcix, 0xffff, 0x4cfb, {18, 18, 11, 11, 11}},
        {m68k_op_link_16_a7, 0xffff, 0x4e57, {16, 16, 5, 5, 5}},
        {m68k_op_unlk_32_a7, 0xffff, 0x4e5f, {12, 12, 6, 6, 6}},
        {m68k_op_reset, 0xffff, 0x4e70, {0, 0, 0, 0, 0}},
        {m68k_op_nop, 0xffff, 0x4e71, {4, 4, 2, 2, 2}},
        {m68k_op_stop, 0xffff, 0x4e72, {4, 4, 8, 8, 8}},
        {m68k_op_rte_32, 0xffff, 0x4e73, {20, 24, 20, 20, 20}},
        {m68k_op_rtd_32, 0xffff, 0x4e74, {0, 16, 10, 10, 10}},
        {m68k_op_rts_32, 0xffff, 0x4e75, {16, 16, 10, 10, 10}},
        {m68k_op_trapv, 0xffff, 0x4e76, {4, 4, 4, 4, 4}},
        {m68k_op_rtr_32, 0xffff, 0x4e77, {20, 20, 14, 14, 14}},
        {m68k_op_movec_32_cr, 0xffff, 0x4e7a, {0, 12, 6, 6, 6}},
        {m68k_op_movec_32_rc, 0xffff, 0x4e7b, {0, 10, 12, 12, 12}},
        {m68k_op_jsr_32_aw, 0xffff, 0x4eb8, {18, 18, 4, 4, 4}},
        {m68k_op_jsr_32_al, 0xffff, 0x4eb9, {20, 20, 4, 4, 4}},
        {m68k_op_jsr_32_pcdi, 0xffff, 0x4eba, {18, 18, 5, 5, 5}},
        {m68k_op_jsr_32_pcix, 0xffff, 0x4ebb, {22, 22, 7, 7, 7}},
        {m68k_op_jmp_32_aw, 0xffff, 0x4ef8, {10, 10, 4, 4, 4}},
        {m68k_op_jmp_32_al, 0xffff, 0x4ef9, {12, 12, 4, 4, 4}},
        {m68k_op_jmp_32_pcdi, 0xffff, 0x4efa, {10, 10, 5, 5, 5}},
        {m68k_op_jmp_32_pcix, 0xffff, 0x4efb, {14, 14, 7, 7, 7}},
        {m68k_op_st_8_pi7, 0xffff, 0x50df, {12, 12, 10, 10, 10}},
        {m68k_op_st_8_pd7, 0xffff, 0x50e7, {14, 14, 11, 11, 11}},
        {m68k_op_st_8_aw, 0xffff, 0x50f8, {16, 16, 10, 10, 10}},
        {m68k_op_st_8_al, 0xffff, 0x50f9, {20, 20, 10, 10, 10}},
        {m68k_op_trapt_16, 0xffff, 0x50fa, {0, 0, 6, 6, 6}},
        {m68k_op_trapt_32, 0xffff, 0x50fb, {0, 0, 8, 8, 8}},
        {m68k_op_trapt, 0xffff, 0x50fc, {0, 0, 4, 4, 4}},
        {m68k_op_sf_8_pi7, 0xffff, 0x51df, {12, 12, 10, 10, 10}},
        {m68k_op_sf_8_pd7, 0xffff, 0x51e7, {14, 14, 11, 11, 11}},
        {m68k_op_sf_8_aw, 0xffff, 0x51f8, {16, 16, 10, 10, 10}},
        {m68k_op_sf_8_al, 0xffff, 0x51f9, {20, 20, 10, 10, 10}},
        {m68k_op_trapf_16, 0xffff, 0x51fa, {0, 0, 6, 6, 6}},
        {m68k_op_trapf_32, 0xffff, 0x51fb, {0, 0, 8, 8, 8}},
        {m68k_op_trapf, 0xffff, 0x51fc, {0, 0, 4, 4, 4}},
        {m68k_op_shi_8_pi7, 0xffff, 0x52df, {12, 12, 10, 10, 10}},
        {m68k_op_shi_8_pd7, 0xffff, 0x52e7, {14, 14, 11, 11, 11}},
        {m68k_op_shi_8_aw, 0xffff, 0x52f8, {16, 16, 10, 10, 10}},
        {m68k_op_shi_8_al, 0xffff, 0x52f9, {20, 20, 10, 10, 10}},
        {m68k_op_traphi_16, 0xffff, 0x52fa, {0, 0, 6, 6, 6}},
        {m68k_op_traphi_32, 0xffff, 0x52fb, {0, 0, 8, 8, 8}},
        {m68k_op_traphi, 0xffff, 0x52fc, {0, 0, 4, 4, 4}},
        {m68k_op_sls_8_pi7, 0xffff, 0x53df, {12, 12, 10, 10, 10}},
        {m68k_op_sls_8_pd7, 0xffff, 0x53e7, {14, 14, 11, 11, 11}},
        {m68k_op_sls_8_aw, 0xffff, 0x53f8, {16, 16, 10, 10, 10}},
        {m68k_op_sls_8_al, 0xffff, 0x53f9, {20, 20, 10, 10, 10}},
        {m68k_op_trapls_16, 0xffff, 0x53fa, {0, 0, 6, 6, 6}},
        {m68k_op_trapls_32, 0xffff, 0x53fb, {0, 0, 8, 8, 8}},
        {m68k_op_trapls, 0xffff, 0x53fc, {0, 0, 4, 4, 4}},
        {m68k_op_scc_8_pi7, 0xffff, 0x54df, {12, 12, 10, 10, 10}},
        {m68k_op_scc_8_pd7, 0xffff, 0x54e7, {14, 14, 11, 11, 11}},
        {m68k_op_scc_8_aw, 0xffff, 0x54f8, {16, 16, 10, 10, 10}},
        {m68k_op_scc_8_al, 0xffff, 0x54f9, {20, 20, 10, 10, 10}},
        {m68k_op_trapcc_16, 0xffff, 0x54fa, {0, 0, 6, 6, 6}},
        {m68k_op_trapcc_32, 0xffff, 0x54fb, {0, 0, 8, 8, 8}},
        {m68k_op_trapcc, 0xffff, 0x54fc, {0, 0, 4, 4, 4}},
        {m68k_op_scs_8_pi7, 0xffff, 0x55df, {12, 12, 10, 10, 10}},
        {m68k_op_scs_8_pd7, 0xffff, 0x55e7, {14, 14, 11, 11, 11}},
        {m68k_op_scs_8_aw, 0xffff, 0x55f8, {16, 16, 10, 10, 10}},
        {m68k_op_scs_8_al, 0xffff, 0x55f9, {20, 20, 10, 10, 10}},
        {m68k_op_trapcs_16, 0xffff, 0x55fa, {0, 0, 6, 6, 6}},
        {m68k_op_trapcs_32, 0xffff, 0x55fb, {0, 0, 8, 8, 8}},
        {m68k_op_trapcs, 0xffff, 0x55fc, {0, 0, 4, 4, 4}},
        {m68k_op_sne_8_pi7, 0xffff, 0x56df, {12, 12, 10, 10, 10}},
        {m68k_op_sne_8_pd7, 0xffff, 0x56e7, {14, 14, 11, 11, 11}},
        {m68k_op_sne_8_aw, 0xffff, 0x56f8, {16, 16, 10, 10, 10}},
        {m68k_op_sne_8_al, 0xffff, 0x56f9, {20, 20, 10, 10, 10}},
        {m68k_op_trapne_16, 0xffff, 0x56fa, {0, 0, 6, 6, 6}},
        {m68k_op_trapne_32, 0xffff, 0x56fb, {0, 0, 8, 8, 8}},
        {m68k_op_trapne, 0xffff, 0x56fc, {0, 0, 4, 4, 4}},
        {m68k_op_seq_8_pi7, 0xffff, 0x57df, {12, 12, 10, 10, 10}},
        {m68k_op_seq_8_pd7, 0xffff, 0x57e7, {14, 14, 11, 11, 11}},
        {m68k_op_seq_8_aw, 0xffff, 0x57f8, {16, 16, 10, 10, 10}},
        {m68k_op_seq_8_al, 0xffff, 0x57f9, {20, 20, 10, 10, 10}},
        {m68k_op_trapeq_16, 0xffff, 0x57fa, {0, 0, 6, 6, 6}},
        {m68k_op_trapeq_32, 0xffff, 0x57fb, {0, 0, 8, 8, 8}},
        {m68k_op_trapeq, 0xffff, 0x57fc, {0, 0, 4, 4, 4}},
        {m68k_op_svc_8_pi7, 0xffff, 0x58df, {12, 12, 10, 10, 10}},
        {m68k_op_svc_8_pd7, 0xffff, 0x58e7, {14, 14, 11, 11, 11}},
        {m68k_op_svc_8_aw, 0xffff, 0x58f8, {16, 16, 10, 10, 10}},
        {m68k_op_svc_8_al, 0xffff, 0x58f9, {20, 20, 10, 10, 10}},
        {m68k_op_trapvc_16, 0xffff, 0x58fa, {0, 0, 6, 6, 6}},
        {m68k_op_trapvc_32, 0xffff, 0x58fb, {0, 0, 8, 8, 8}},
        {m68k_op_trapvc, 0xffff, 0x58fc, {0, 0, 4, 4, 4}},
        {m68k_op_svs_8_pi7, 0xffff, 0x59df, {12, 12, 10, 10, 10}},
        {m68k_op_svs_8_pd7, 0xffff, 0x59e7, {14, 14, 11, 11, 11}},
        {m68k_op_svs_8_aw, 0xffff, 0x59f8, {16, 16, 10, 10, 10}},
        {m68k_op_svs_8_al, 0xffff, 0x59f9, {20, 20, 10, 10, 10}},
        {m68k_op_trapvs_16, 0xffff, 0x59fa, {0, 0, 6, 6, 6}},
        {m68k_op_trapvs_32, 0xffff, 0x59fb, {0, 0, 8, 8, 8}},
        {m68k_op_trapvs, 0xffff, 0x59fc, {0, 0, 4, 4, 4}},
        {m68k_op_spl_8_pi7, 0xffff, 0x5adf, {12, 12, 10, 10, 10}},
        {m68k_op_spl_8_pd7, 0xffff, 0x5ae7, {14, 14, 11, 11, 11}},
        {m68k_op_spl_8_aw, 0xffff, 0x5af8, {16, 16, 10, 10, 10}},
        {m68k_op_spl_8_al, 0xffff, 0x5af9, {20, 20, 10, 10, 10}},
        {m68k_op_trappl_16, 0xffff, 0x5afa, {0, 0, 6, 6, 6}},
        {m68k_op_trappl_32, 0xffff, 0x5afb, {0, 0, 8, 8, 8}},
        {m68k_op_trappl, 0xffff, 0x5afc, {0, 0, 4, 4, 4}},
        {m68k_op_smi_8_pi7, 0xffff, 0x5bdf, {12, 12, 10, 10, 10}},
        {m68k_op_smi_8_pd7, 0xffff, 0x5be7, {14, 14, 11, 11, 11}},
        {m68k_op_smi_8_aw, 0xffff, 0x5bf8, {16, 16, 10, 10, 10}},
        {m68k_op_smi_8_al, 0xffff, 0x5bf9, {20, 20, 10, 10, 10}},
        {m68k_op_trapmi_16, 0xffff, 0x5bfa, {0, 0, 6, 6, 6}},
        {m68k_op_trapmi_32, 0xffff, 0x5bfb, {0, 0, 8, 8, 8}},
        {m68k_op_trapmi, 0xffff, 0x5bfc, {0, 0, 4, 4, 4}},
        {m68k_op_sge_8_pi7, 0xffff, 0x5cdf, {12, 12, 10, 10, 10}},
        {m68k_op_sge_8_pd7, 0xffff, 0x5ce7, {14, 14, 11, 11, 11}},
        {m68k_op_sge_8_aw, 0xffff, 0x5cf8, {16, 16, 10, 10, 10}},
        {m68k_op_sge_8_al, 0xffff, 0x5cf9, {20, 20, 10, 10, 10}},
        {m68k_op_trapge_16, 0xffff, 0x5cfa, {0, 0, 6, 6, 6}},
        {m68k_op_trapge_32, 0xffff, 0x5cfb, {0, 0, 8, 8, 8}},
        {m68k_op_trapge, 0xffff, 0x5cfc, {0, 0, 4, 4, 4}},
        {m68k_op_slt_8_pi7, 0xffff, 0x5ddf, {12, 12, 10, 10, 10}},
        {m68k_op_slt_8_pd7, 0xffff, 0x5de7, {14, 14, 11, 11, 11}},
        {m68k_op_slt_8_aw, 0xffff, 0x5df8, {16, 16, 10, 10, 10}},
        {m68k_op_slt_8_al, 0xffff, 0x5df9, {20, 20, 10, 10, 10}},
        {m68k_op_traplt_16, 0xffff, 0x5dfa, {0, 0, 6, 6, 6}},
        {m68k_op_traplt_32, 0xffff, 0x5dfb, {0, 0, 8, 8, 8}},
        {m68k_op_traplt, 0xffff, 0x5dfc, {0, 0, 4, 4, 4}},
        {m68k_op_sgt_8_pi7, 0xffff, 0x5edf, {12, 12, 10, 10, 10}},
        {m68k_op_sgt_8_pd7, 0xffff, 0x5ee7, {14, 14, 11, 11, 11}},
        {m68k_op_sgt_8_aw, 0xffff, 0x5ef8, {16, 16, 10, 10, 10}},
        {m68k_op_sgt_8_al, 0xffff, 0x5ef9, {20, 20, 10, 10, 10}},
        {m68k_op_trapgt_16, 0xffff, 0x5efa, {0, 0, 6, 6, 6}},
        {m68k_op_trapgt_32, 0xffff, 0x5efb, {0, 0, 8, 8, 8}},
        {m68k_op_trapgt, 0xffff, 0x5efc, {0, 0, 4, 4, 4}},
        {m68k_op_sle_8_pi7, 0xffff, 0x5fdf, {12, 12, 10, 10, 10}},
        {m68k_op_sle_8_pd7, 0xffff, 0x5fe7, {14, 14, 11, 11, 11}},
        {m68k_op_sle_8_aw, 0xffff, 0x5ff8, {16, 16, 10, 10, 10}},
        {m68k_op_sle_8_al, 0xffff, 0x5ff9, {20, 20, 10, 10, 10}},
        {m68k_op_traple_16, 0xffff, 0x5ffa, {0, 0, 6, 6, 6}},
        {m68k_op_traple_32, 0xffff, 0x5ffb, {0, 0, 8, 8, 8}},
        {m68k_op_traple, 0xffff, 0x5ffc, {0, 0, 4, 4, 4}},
        {m68k_op_bra_16, 0xffff, 0x6000, {10, 10, 10, 10, 10}},
        {m68k_op_bra_32, 0xffff, 0x60ff, {10, 10, 10, 10, 10}},
        {m68k_op_bsr_16, 0xffff, 0x6100, {18, 18, 7, 7, 7}},
        {m68k_op_bsr_32, 0xffff, 0x61ff, {18, 18, 7, 7, 7}},
        {m68k_op_bhi_16, 0xffff, 0x6200, {10, 10, 6, 6, 6}},
        {m68k_op_bhi_32, 0xffff, 0x62ff, {10, 10, 6, 6, 6}},
        {m68k_op_bls_16, 0xffff, 0x6300, {10, 10, 6, 6, 6}},
        {m68k_op_bls_32, 0xffff, 0x63ff, {10, 10, 6, 6, 6}},
        {m68k_op_bcc_16, 0xffff, 0x6400, {10, 10, 6, 6, 6}},
        {m68k_op_bcc_32, 0xffff, 0x64ff, {10, 10, 6, 6, 6}},
        {m68k_op_bcs_16, 0xffff, 0x6500, {10, 10, 6, 6, 6}},
        {m68k_op_bcs_32, 0xffff, 0x65ff, {10, 10, 6, 6, 6}},
        {m68k_op_bne_16, 0xffff, 0x6600, {10, 10, 6, 6, 6}},
        {m68k_op_bne_32, 0xffff, 0x66ff, {10, 10, 6, 6, 6}},
        {m68k_op_beq_16, 0xffff, 0x6700, {10, 10, 6, 6, 6}},
        {m68k_op_beq_32, 0xffff, 0x67ff, {10, 10, 6, 6, 6}},
        {m68k_op_bvc_16, 0xffff, 0x6800, {10, 10, 6, 6, 6}},
        {m68k_op_bvc_32, 0xffff, 0x68ff, {10, 10, 6, 6, 6}},
        {m68k_op_bvs_16, 0xffff, 0x6900, {10, 10, 6, 6, 6}},
        {m68k_op_bvs_32, 0xffff, 0x69ff, {10, 10, 6, 6, 6}},
        {m68k_op_bpl_16, 0xffff, 0x6a00, {10, 10, 6, 6, 6}},
        {m68k_op_bpl_32, 0xffff, 0x6aff, {10, 10, 6, 6, 6}},
        {m68k_op_bmi_16, 0xffff, 0x6b00, {10, 10, 6, 6, 6}},
        {m68k_op_bmi_32, 0xffff, 0x6bff, {10, 10, 6, 6, 6}},
        {m68k_op_bge_16, 0xffff, 0x6c00, {10, 10, 6, 6, 6}},
        {m68k_op_bge_32, 0xffff, 0x6cff, {10, 10, 6, 6, 6}},
        {m68k_op_blt_16, 0xffff, 0x6d00, {10, 10, 6, 6, 6}},
        {m68k_op_blt_32, 0xffff, 0x6dff, {10, 10, 6, 6, 6}},
        {m68k_op_bgt_16, 0xffff, 0x6e00, {10, 10, 6, 6, 6}},
        {m68k_op_bgt_32, 0xffff, 0x6eff, {10, 10, 6, 6, 6}},
        {m68k_op_ble_16, 0xffff, 0x6f00, {10, 10, 6, 6, 6}},
        {m68k_op_ble_32, 0xffff, 0x6fff, {10, 10, 6, 6, 6}},
        {m68k_op_sbcd_8_mm_axy7, 0xffff, 0x8f0f, {18, 18, 16, 16, 16}},
        {m68k_op_pack_16_mm_axy7, 0xffff, 0x8f4f, {0, 0, 13, 13, 13}},
        {m68k_op_unpk_16_mm_axy7, 0xffff, 0x8f8f, {0, 0, 13, 13, 13}},
        {m68k_op_subx_8_mm_axy7, 0xffff, 0x9f0f, {18, 18, 12, 12, 12}},
        {m68k_op_cmpm_8_axy7, 0xffff, 0xbf0f, {12, 12, 9, 9, 9}},
        {m68k_op_abcd_8_mm_axy7, 0xffff, 0xcf0f, {18, 18, 16, 16, 16}},
        {m68k_op_addx_8_mm_axy7, 0xffff, 0xdf0f, {18, 18, 12, 12, 12}},
        {m68k_op_asr_16_aw, 0xffff, 0xe0f8, {16, 16, 9, 9, 9}},
        {m68k_op_asr_16_al, 0xffff, 0xe0f9, {20, 20, 9, 9, 9}},
        {m68k_op_asl_16_aw, 0xffff, 0xe1f8, {16, 16, 10, 10, 10}},
        {m68k_op_asl_16_al, 0xffff, 0xe1f9, {20, 20, 10, 10, 10}},
        {m68k_op_lsr_16_aw, 0xffff, 0xe2f8, {16, 16, 9, 9, 9}},
        {m68k_op_lsr_16_al, 0xffff, 0xe2f9, {20, 20, 9, 9, 9}},
        {m68k_op_lsl_16_aw, 0xffff, 0xe3f8, {16, 16, 9, 9, 9}},
        {m68k_op_lsl_16_al, 0xffff, 0xe3f9, {20, 20, 9, 9, 9}},
        {m68k_op_roxr_16_aw, 0xffff, 0xe4f8, {16, 16, 9, 9, 9}},
        {m68k_op_roxr_16_al, 0xffff, 0xe4f9, {20, 20, 9, 9, 9}},
        {m68k_op_roxl_16_aw, 0xffff, 0xe5f8, {16, 16, 9, 9, 9}},
        {m68k_op_roxl_16_al, 0xffff, 0xe5f9, {20, 20, 9, 9, 9}},
        {m68k_op_ror_16_aw, 0xffff, 0xe6f8, {16, 16, 11, 11, 11}},
        {m68k_op_ror_16_al, 0xffff, 0xe6f9, {20, 20, 11, 11, 11}},
        {m68k_op_rol_16_aw, 0xffff, 0xe7f8, {16, 16, 11, 11, 11}},
        {m68k_op_rol_16_al, 0xffff, 0xe7f9, {20, 20, 11, 11, 11}},
        {m68k_op_bftst_32_aw, 0xffff, 0xe8f8, {0, 0, 17, 17, 17}},
        {m68k_op_bftst_32_al, 0xffff, 0xe8f9, {0, 0, 17, 17, 17}},
        {m68k_op_bftst_32_pcdi, 0xffff, 0xe8fa, {0, 0, 18, 18, 18}},
        {m68k_op_bftst_32_pcix, 0xffff, 0xe8fb, {0, 0, 20, 20, 20}},
        {m68k_op_bfextu_32_aw, 0xffff, 0xe9f8, {0, 0, 19, 19, 19}},
        {m68k_op_bfextu_32_al, 0xffff, 0xe9f9, {0, 0, 19, 19, 19}},
        {m68k_op_bfextu_32_pcdi, 0xffff, 0xe9fa, {0, 0, 20, 20, 20}},
        {m68k_op_bfextu_32_pcix, 0xffff, 0xe9fb, {0, 0, 22, 22, 22}},
        {m68k_op_bfchg_32_aw, 0xffff, 0xeaf8, {0, 0, 24, 24, 24}},
        {m68k_op_bfchg_32_al, 0xffff, 0xeaf9, {0, 0, 24, 24, 24}},
        {m68k_op_bfexts_32_aw, 0xffff, 0xebf8, {0, 0, 19, 19, 19}},
        {m68k_op_bfexts_32_al, 0xffff, 0xebf9, {0, 0, 19, 19, 19}},
        {m68k_op_bfexts_32_pcdi, 0xffff, 0xebfa, {0, 0, 20, 20, 20}},
        {m68k_op_bfexts_32_pcix, 0xffff, 0xebfb, {0, 0, 22, 22, 22}},
        {m68k_op_bfclr_32_aw, 0xffff, 0xecf8, {0, 0, 24, 24, 24}},
        {m68k_op_bfclr_32_al, 0xffff, 0xecf9, {0, 0, 24, 24, 24}},
        {m68k_op_bfffo_32_aw, 0xffff, 0xedf8, {0, 0, 32, 32, 32}},
        {m68k_op_bfffo_32_al, 0xffff, 0xedf9, {0, 0, 32, 32, 32}},
        {m68k_op_bfffo_32_pcdi, 0xffff, 0xedfa, {0, 0, 33, 33, 33}},
        {m68k_op_bfffo_32_pcix, 0xffff, 0xedfb, {0, 0, 35, 35, 35}},
        {m68k_op_bfset_32_aw, 0xffff, 0xeef8, {0, 0, 24, 24, 24}},
        {m68k_op_bfset_32_al, 0xffff, 0xeef9, {0, 0, 24, 24, 24}},
        {m68k_op_bfins_32_aw, 0xffff, 0xeff8, {0, 0, 21, 21, 21}},
        {m68k_op_bfins_32_al, 0xffff, 0xeff9, {0, 0, 21, 21, 21}},
        {m68k_op_pflush_32, 0xffff, 0xf518, {0, 0, 0, 0, 4}},
        {0, 0, 0, {0, 0, 0, 0, 0}}};

/* Build the opcode handler jump table */
void m68ki_build_opcode_table(void)
{
    const opcode_handler_struct* ostruct;
    int cycle_cost;
    int instr;
    int i;
    int j;
    int k;

    for (i = 0; i < 0x10000; i++) {
        /* default to illegal */
        m68ki_instruction_jump_table[i] = m68k_op_illegal;
        for (k = 0; k < NUM_CPU_TYPES; k++) {
            m68ki_cycles[k][i] = 0;
        }
    }

    ostruct = m68k_opcode_handler_table;
    while (ostruct->mask != 0xff00) {
        for (i = 0; i < 0x10000; i++) {
            if ((i & ostruct->mask) == ostruct->match) {
                m68ki_instruction_jump_table[i] = ostruct->opcode_handler;
                for (k = 0; k < NUM_CPU_TYPES; k++) {
                    m68ki_cycles[k][i] = ostruct->cycles[k];
                }
            }
        }
        ostruct++;
    }
    while (ostruct->mask == 0xff00) {
        for (i = 0; i <= 0xff; i++) {
            m68ki_instruction_jump_table[ostruct->match | i] = ostruct->opcode_handler;
            for (k = 0; k < NUM_CPU_TYPES; k++) {
                m68ki_cycles[k][ostruct->match | i] = ostruct->cycles[k];
            }
        }
        ostruct++;
    }
    while (ostruct->mask == 0xf1f8) {
        for (i = 0; i < 8; i++) {
            for (j = 0; j < 8; j++) {
                instr = ostruct->match | (i << 9) | j;
                m68ki_instruction_jump_table[instr] = ostruct->opcode_handler;
                for (k = 0; k < NUM_CPU_TYPES; k++) {
                    m68ki_cycles[k][instr] = ostruct->cycles[k];
                }
                /* SBF: don't add it here or the costs are added twice!
                                // For all shift operations with known shift distance (encoded in instruction word)
                                if((instr & 0xf000) == 0xe000 && (!(instr & 0x20)))
                                {
                                    // On the 68000 and 68010 shift distance affect execution time.
                                    // Add the cycle cost of shifting; 2 times the shift distance
                                    cycle_cost = ((((i-1)&7)+1)<<1);
                                    m68ki_cycles[0][instr] += cycle_cost;
                                    m68ki_cycles[1][instr] += cycle_cost;
                                    // On the 68020 shift distance does not affect execution time
                                    m68ki_cycles[2][instr] += 0;
                                }
                */
            }
        }
        ostruct++;
    }
    while (ostruct->mask == 0xfff0) {
        for (i = 0; i <= 0x0f; i++) {
            m68ki_instruction_jump_table[ostruct->match | i] = ostruct->opcode_handler;
            for (k = 0; k < NUM_CPU_TYPES; k++) {
                m68ki_cycles[k][ostruct->match | i] = ostruct->cycles[k];
            }
        }
        ostruct++;
    }
    while (ostruct->mask == 0xf1ff) {
        for (i = 0; i <= 0x07; i++) {
            m68ki_instruction_jump_table[ostruct->match | (i << 9)] = ostruct->opcode_handler;
            for (k = 0; k < NUM_CPU_TYPES; k++) {
                m68ki_cycles[k][ostruct->match | (i << 9)] = ostruct->cycles[k];
            }
        }
        ostruct++;
    }
    while (ostruct->mask == 0xfff8) {
        for (i = 0; i <= 0x07; i++) {
            m68ki_instruction_jump_table[ostruct->match | i] = ostruct->opcode_handler;
            for (k = 0; k < NUM_CPU_TYPES; k++) {
                m68ki_cycles[k][ostruct->match | i] = ostruct->cycles[k];
            }
        }
        ostruct++;
    }
    while (ostruct->mask == 0xffff) {
        m68ki_instruction_jump_table[ostruct->match] = ostruct->opcode_handler;
        for (k = 0; k < NUM_CPU_TYPES; k++) {
            m68ki_cycles[k][ostruct->match] = ostruct->cycles[k];
        }
        ostruct++;
    }
}

/* ======================================================================== */
/* ============================== END OF FILE ============================= */
/* ======================================================================== */

/* -- End embedded musashi/m68kops.c -- */

/* -- Begin embedded musashi/m68kdasm.c -- */
/* ======================================================================== */
/* ========================= LICENSING & COPYRIGHT ======================== */
/* ======================================================================== */
/*
 *                                  MUSASHI
 *                                Version 3.32
 *
 * A portable Motorola M680x0 processor emulation engine.
 * Copyright Karl Stenerud.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* ======================================================================== */
/* ================================ INCLUDES ============================== */
/* ======================================================================== */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifndef uint32
#define uint32 uint
#endif

#ifndef uint16
#define uint16 unsigned short
#endif

#ifndef DECL_SPEC
#define DECL_SPEC
#endif

/* ======================================================================== */
/* ============================ GENERAL DEFINES =========================== */
/* ======================================================================== */

/* unsigned int and int must be at least 32 bits wide */
#undef uint
#define uint unsigned int

/* Bit Isolation Functions */
#define BIT_0(A) ((A) & 0x00000001)
#define BIT_1(A) ((A) & 0x00000002)
#define BIT_2(A) ((A) & 0x00000004)
#define BIT_3(A) ((A) & 0x00000008)
#define BIT_4(A) ((A) & 0x00000010)
#define BIT_5(A) ((A) & 0x00000020)
#define BIT_6(A) ((A) & 0x00000040)
#define BIT_7(A) ((A) & 0x00000080)
#define BIT_8(A) ((A) & 0x00000100)
#define BIT_9(A) ((A) & 0x00000200)
#define BIT_A(A) ((A) & 0x00000400)
#define BIT_B(A) ((A) & 0x00000800)
#define BIT_C(A) ((A) & 0x00001000)
#define BIT_D(A) ((A) & 0x00002000)
#define BIT_E(A) ((A) & 0x00004000)
#define BIT_F(A) ((A) & 0x00008000)
#define BIT_10(A) ((A) & 0x00010000)
#define BIT_11(A) ((A) & 0x00020000)
#define BIT_12(A) ((A) & 0x00040000)
#define BIT_13(A) ((A) & 0x00080000)
#define BIT_14(A) ((A) & 0x00100000)
#define BIT_15(A) ((A) & 0x00200000)
#define BIT_16(A) ((A) & 0x00400000)
#define BIT_17(A) ((A) & 0x00800000)
#define BIT_18(A) ((A) & 0x01000000)
#define BIT_19(A) ((A) & 0x02000000)
#define BIT_1A(A) ((A) & 0x04000000)
#define BIT_1B(A) ((A) & 0x08000000)
#define BIT_1C(A) ((A) & 0x10000000)
#define BIT_1D(A) ((A) & 0x20000000)
#define BIT_1E(A) ((A) & 0x40000000)
#define BIT_1F(A) ((A) & 0x80000000)

/* These are the CPU types understood by this disassembler */
#define TYPE_68000 1
#define TYPE_68010 2
#define TYPE_68020 4
#define TYPE_68030 8
#define TYPE_68040 16

#define M68000_ONLY TYPE_68000

#define M68010_ONLY TYPE_68010
#define M68010_LESS (TYPE_68000 | TYPE_68010)
#define M68010_PLUS (TYPE_68010 | TYPE_68020 | TYPE_68030 | TYPE_68040)

#define M68020_ONLY TYPE_68020
#define M68020_LESS (TYPE_68010 | TYPE_68020)
#define M68020_PLUS (TYPE_68020 | TYPE_68030 | TYPE_68040)

#define M68030_ONLY TYPE_68030
#define M68030_LESS (TYPE_68010 | TYPE_68020 | TYPE_68030)
#define M68030_PLUS (TYPE_68030 | TYPE_68040)

#define M68040_PLUS TYPE_68040

/* Extension word formats */
#define EXT_8BIT_DISPLACEMENT(A) ((A) & 0xff)
#define EXT_FULL(A) BIT_8(A)
#define EXT_EFFECTIVE_ZERO(A) (((A) & 0xe4) == 0xc4 || ((A) & 0xe2) == 0xc0)
#define EXT_BASE_REGISTER_PRESENT(A) (!BIT_7(A))
#define EXT_INDEX_REGISTER_PRESENT(A) (!BIT_6(A))
#define EXT_INDEX_REGISTER(A) (((A) >> 12) & 7)
#define EXT_INDEX_PRE_POST(A) (EXT_INDEX_PRESENT(A) && (A) & 3)
#define EXT_INDEX_PRE(A) (EXT_INDEX_PRESENT(A) && ((A) & 7) < 4 && ((A) & 7) != 0)
#define EXT_INDEX_POST(A) (EXT_INDEX_PRESENT(A) && ((A) & 7) > 4)
#define EXT_INDEX_SCALE(A) (((A) >> 9) & 3)
#define EXT_INDEX_LONG(A) BIT_B(A)
#define EXT_INDEX_AR(A) BIT_F(A)
#define EXT_BASE_DISPLACEMENT_PRESENT(A) (((A) & 0x30) > 0x10)
#define EXT_BASE_DISPLACEMENT_WORD(A) (((A) & 0x30) == 0x20)
#define EXT_BASE_DISPLACEMENT_LONG(A) (((A) & 0x30) == 0x30)
#define EXT_OUTER_DISPLACEMENT_PRESENT(A) (((A) & 3) > 1 && ((A) & 0x47) < 0x44)
#define EXT_OUTER_DISPLACEMENT_WORD(A) (((A) & 3) == 2 && ((A) & 0x47) < 0x44)
#define EXT_OUTER_DISPLACEMENT_LONG(A) (((A) & 3) == 3 && ((A) & 0x47) < 0x44)

/* Opcode flags */
#if M68K_COMPILE_FOR_MAME == OPT_ON
#define SET_OPCODE_FLAGS(x) g_opcode_type = x;
#define COMBINE_OPCODE_FLAGS(x) ((x) | g_opcode_type | DASMFLAG_SUPPORTED)
#else
#define SET_OPCODE_FLAGS(x)
#define COMBINE_OPCODE_FLAGS(X) (X)
#endif

/* ======================================================================== */
/* =============================== PROTOTYPES ============================= */
/* ======================================================================== */

/* Read data at the PC and increment PC */
uint read_imm_8(void);
uint read_imm_16(void);
uint read_imm_32(void);

/* Read data at the PC but don't imcrement the PC */
uint peek_imm_8(void);
uint peek_imm_16(void);
uint peek_imm_32(void);

/* make signed integers 100% portably */
static int make_int_8(int value);
static int make_int_16(int value);
static int make_int_32(int value);

/* make a string of a hex value */
static char* make_signed_hex_str_8(uint val);
static char* make_signed_hex_str_16(uint val);
static char* make_signed_hex_str_32(uint val);

/* make string of ea mode */
static char* get_ea_mode_str(uint instruction, uint size);

char* get_ea_mode_str_8(uint instruction);
char* get_ea_mode_str_16(uint instruction);
char* get_ea_mode_str_32(uint instruction);

/* make string of immediate value */
static char* get_imm_str_s(uint size);
static char* get_imm_str_u(uint size);

char* get_imm_str_s8(void);
char* get_imm_str_s16(void);
char* get_imm_str_s32(void);

/* Stuff to build the opcode handler jump table */
static void build_opcode_table(void);
static int valid_ea(uint opcode, uint mask);
static int DECL_SPEC compare_nof_true_bits(const void* aptr, const void* bptr);

/* used to build opcode handler jump table */
typedef struct
{
    void (*opcode_handler)(void); /* handler function */
    uint mask;                    /* mask on opcode */
    uint match;                   /* what to match after masking */
    uint ea_mask;                 /* what ea modes are allowed */
} opcode_struct;

/* ======================================================================== */
/* ================================= DATA ================================= */
/* ======================================================================== */

/* Opcode handler jump table */
static void (*g_instruction_table[0x10000])(void);
/* Flag if disassembler initialized */
static int g_initialized = 0;

/* Address mask to simulate address lines */
static unsigned int g_address_mask = 0xffffffff;

static char g_dasm_str[100];   /* string to hold disassembly */
static char g_helper_str[100]; /* string to hold helpful info */
static uint g_cpu_pc;          /* program counter */
static uint g_cpu_ir;          /* instruction register */
static uint g_cpu_type;
static uint g_opcode_type;
static const unsigned char* g_rawop;
static uint g_rawbasepc;

/* used by ops like asr, ror, addq, etc */
static const uint g_3bit_qdata_table[8] = {8, 1, 2, 3, 4, 5, 6, 7};

static const uint g_5bit_data_table[32] =
    {
        32, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31};

static const char* const g_cc[16] =
    {"t", "f", "hi", "ls", "cc", "cs", "ne", "eq", "vc", "vs", "pl", "mi", "ge", "lt", "gt", "le"};

static const char* const g_cpcc[64] =
    {
        /* 000    001    010    011    100    101    110    111 */
        "f", "eq", "ogt", "oge", "olt", "ole", "ogl", "or",     /* 000 */
        "un", "ueq", "ugt", "uge", "ult", "ule", "ne", "t",     /* 001 */
        "sf", "seq", "gt", "ge", "lt", "le", "gl", "gle",       /* 010 */
        "ngle", "ngl", "nle", "nlt", "nge", "ngt", "sne", "st", /* 011 */
        "?", "?", "?", "?", "?", "?", "?", "?",                 /* 100 */
        "?", "?", "?", "?", "?", "?", "?", "?",                 /* 101 */
        "?", "?", "?", "?", "?", "?", "?", "?",                 /* 110 */
        "?", "?", "?", "?", "?", "?", "?", "?"                  /* 111 */
};

static const char* const g_mmuregs[8] =
    {
        "tc", "drp", "srp", "crp", "cal", "val", "sccr", "acr"};

static const char* const g_mmucond[16] =
    {
        "bs", "bc", "ls", "lc", "ss", "sc", "as", "ac",
        "ws", "wc", "is", "ic", "gs", "gc", "cs", "cc"};

/* ======================================================================== */
/* =========================== UTILITY FUNCTIONS ========================== */
/* ======================================================================== */

#define LIMIT_CPU_TYPES(ALLOWED_CPU_TYPES)   \
    if (!(g_cpu_type & ALLOWED_CPU_TYPES)) { \
        if ((g_cpu_ir & 0xf000) == 0xf000)   \
            d68000_1111();                   \
        else                                 \
            d68000_illegal();                \
        return;                              \
    }

static uint dasm_read_imm_8(uint advance)
{
    uint result;
    if (g_rawop) {
        result = g_rawop[g_cpu_pc + 1 - g_rawbasepc];
    } else {
        result = m68k_read_disassembler_16(g_cpu_pc & g_address_mask) & 0xff;
    }
    g_cpu_pc += advance;
    return result;
}

static uint dasm_read_imm_16(uint advance)
{
    uint result;
    if (g_rawop) {
        result = (g_rawop[g_cpu_pc + 0 - g_rawbasepc] << 8) |
                 g_rawop[g_cpu_pc + 1 - g_rawbasepc];
    } else {
        result = m68k_read_disassembler_16(g_cpu_pc & g_address_mask) & 0xffff;
    }
    g_cpu_pc += advance;
    return result;
}

static uint dasm_read_imm_32(uint advance)
{
    uint result;
    if (g_rawop) {
        result = (g_rawop[g_cpu_pc + 0 - g_rawbasepc] << 24) |
                 (g_rawop[g_cpu_pc + 1 - g_rawbasepc] << 16) |
                 (g_rawop[g_cpu_pc + 2 - g_rawbasepc] << 8) |
                 g_rawop[g_cpu_pc + 3 - g_rawbasepc];
    } else {
        result = m68k_read_disassembler_32(g_cpu_pc & g_address_mask) & 0xffffffff;
    }
    g_cpu_pc += advance;
    return result;
}

#define read_imm_8() dasm_read_imm_8(2)
#define read_imm_16() dasm_read_imm_16(2)
#define read_imm_32() dasm_read_imm_32(4)

#define peek_imm_8() dasm_read_imm_8(0)
#define peek_imm_16() dasm_read_imm_16(0)
#define peek_imm_32() dasm_read_imm_32(0)

/* Fake a split interface */
#define get_ea_mode_str_8(instruction) get_ea_mode_str(instruction, 0)
#define get_ea_mode_str_16(instruction) get_ea_mode_str(instruction, 1)
#define get_ea_mode_str_32(instruction) get_ea_mode_str(instruction, 2)

#define get_imm_str_s8() get_imm_str_s(0)
#define get_imm_str_s16() get_imm_str_s(1)
#define get_imm_str_s32() get_imm_str_s(2)

#define get_imm_str_u8() get_imm_str_u(0)
#define get_imm_str_u16() get_imm_str_u(1)
#define get_imm_str_u32() get_imm_str_u(2)

static int sext_7bit_int(int value)
{
    return (value & 0x40) ? (value | 0xffffff80) : (value & 0x7f);
}

/* 100% portable signed int generators */
static int make_int_8(int value)
{
    return (value & 0x80) ? value | ~0xff : value & 0xff;
}

static int make_int_16(int value)
{
    return (value & 0x8000) ? value | ~0xffff : value & 0xffff;
}

static int make_int_32(int value)
{
    return (value & 0x80000000) ? value | ~0xffffffff : value & 0xffffffff;
}

/* Get string representation of hex values */
static char* make_signed_hex_str_8(uint val)
{
    static char str[21];

    val &= 0xff;

    if (val == 0x80) {
        sprintf(str, "-$80");
    } else if (val & 0x80) {
        sprintf(str, "-$%x", (0 - val) & 0x7f);
    } else {
        sprintf(str, "$%x", val & 0x7f);
    }

    return str;
}

static char* make_signed_hex_str_16(uint val)
{
    static char str[21];

    val &= 0xffff;

    if (val == 0x8000) {
        sprintf(str, "-$8000");
    } else if (val & 0x8000) {
        sprintf(str, "-$%x", (0 - val) & 0x7fff);
    } else {
        sprintf(str, "$%x", val & 0x7fff);
    }

    return str;
}

static char* make_signed_hex_str_32(uint val)
{
    static char str[21];

    val &= 0xffffffff;

    if (val == 0x80000000) {
        sprintf(str, "-$80000000");
    } else if (val & 0x80000000) {
        sprintf(str, "-$%x", (0 - val) & 0x7fffffff);
    } else {
        sprintf(str, "$%x", val & 0x7fffffff);
    }

    return str;
}

/* make string of immediate value */
static char* get_imm_str_s(uint size)
{
    static char str[21];
    if (size == 0) {
        sprintf(str, "#%s", make_signed_hex_str_8(read_imm_8()));
    } else if (size == 1) {
        sprintf(str, "#%s", make_signed_hex_str_16(read_imm_16()));
    } else {
        sprintf(str, "#%s", make_signed_hex_str_32(read_imm_32()));
    }
    return str;
}

static char* get_imm_str_u(uint size)
{
    static char str[21];
    if (size == 0) {
        sprintf(str, "#$%x", read_imm_8() & 0xff);
    } else if (size == 1) {
        sprintf(str, "#$%x", read_imm_16() & 0xffff);
    } else {
        sprintf(str, "#$%x", read_imm_32() & 0xffffffff);
    }
    return str;
}

/* Make string of effective address mode */
static char* get_ea_mode_str(uint instruction, uint size)
{
    static char b1[64];
    static char b2[64];
    static char* mode = b2;
    uint extension;
    uint base;
    uint outer;
    char base_reg[4];
    char index_reg[8];
    uint preindex;
    uint postindex;
    uint comma = 0;
    uint temp_value;

    /* Switch buffers so we don't clobber on a double-call to this function */
    mode = mode == b1 ? b2 : b1;

    switch (instruction & 0x3f) {
        case 0x00:
        case 0x01:
        case 0x02:
        case 0x03:
        case 0x04:
        case 0x05:
        case 0x06:
        case 0x07:
            /* data register direct */
            sprintf(mode, "D%d", instruction & 7);
            break;
        case 0x08:
        case 0x09:
        case 0x0a:
        case 0x0b:
        case 0x0c:
        case 0x0d:
        case 0x0e:
        case 0x0f:
            /* address register direct */
            sprintf(mode, "A%d", instruction & 7);
            break;
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
        case 0x14:
        case 0x15:
        case 0x16:
        case 0x17:
            /* address register indirect */
            sprintf(mode, "(A%d)", instruction & 7);
            break;
        case 0x18:
        case 0x19:
        case 0x1a:
        case 0x1b:
        case 0x1c:
        case 0x1d:
        case 0x1e:
        case 0x1f:
            /* address register indirect with postincrement */
            sprintf(mode, "(A%d)+", instruction & 7);
            break;
        case 0x20:
        case 0x21:
        case 0x22:
        case 0x23:
        case 0x24:
        case 0x25:
        case 0x26:
        case 0x27:
            /* address register indirect with predecrement */
            sprintf(mode, "-(A%d)", instruction & 7);
            break;
        case 0x28:
        case 0x29:
        case 0x2a:
        case 0x2b:
        case 0x2c:
        case 0x2d:
        case 0x2e:
        case 0x2f:
            /* address register indirect with displacement*/
            sprintf(mode, "(%s,A%d)", make_signed_hex_str_16(read_imm_16()), instruction & 7);
            break;
        case 0x30:
        case 0x31:
        case 0x32:
        case 0x33:
        case 0x34:
        case 0x35:
        case 0x36:
        case 0x37:
            /* address register indirect with index */
            extension = read_imm_16();

            if (EXT_FULL(extension)) {
                if (EXT_EFFECTIVE_ZERO(extension)) {
                    strcpy(mode, "0");
                    break;
                }
                base = EXT_BASE_DISPLACEMENT_PRESENT(extension) ? (EXT_BASE_DISPLACEMENT_LONG(extension) ? read_imm_32() : read_imm_16()) : 0;
                outer = EXT_OUTER_DISPLACEMENT_PRESENT(extension) ? (EXT_OUTER_DISPLACEMENT_LONG(extension) ? read_imm_32() : read_imm_16()) : 0;
                if (EXT_BASE_REGISTER_PRESENT(extension)) {
                    sprintf(base_reg, "A%d", instruction & 7);
                } else {
                    *base_reg = 0;
                }
                if (EXT_INDEX_REGISTER_PRESENT(extension)) {
                    sprintf(index_reg, "%c%d.%c", EXT_INDEX_AR(extension) ? 'A' : 'D', EXT_INDEX_REGISTER(extension), EXT_INDEX_LONG(extension) ? 'l' : 'w');
                    if (EXT_INDEX_SCALE(extension)) {
                        sprintf(index_reg + strlen(index_reg), "*%d", 1 << EXT_INDEX_SCALE(extension));
                    }
                } else {
                    *index_reg = 0;
                }
                preindex = (extension & 7) > 0 && (extension & 7) < 4;
                postindex = (extension & 7) > 4;

                strcpy(mode, "(");
                if (preindex || postindex) {
                    strcat(mode, "[");
                }
                if (base) {
                    if (EXT_BASE_DISPLACEMENT_LONG(extension)) {
                        strcat(mode, make_signed_hex_str_32(base));
                    } else {
                        strcat(mode, make_signed_hex_str_16(base));
                    }
                    comma = 1;
                }
                if (*base_reg) {
                    if (comma) {
                        strcat(mode, ",");
                    }
                    strcat(mode, base_reg);
                    comma = 1;
                }
                if (postindex) {
                    strcat(mode, "]");
                    comma = 1;
                }
                if (*index_reg) {
                    if (comma) {
                        strcat(mode, ",");
                    }
                    strcat(mode, index_reg);
                    comma = 1;
                }
                if (preindex) {
                    strcat(mode, "]");
                    comma = 1;
                }
                if (outer) {
                    if (comma) {
                        strcat(mode, ",");
                    }
                    strcat(mode, make_signed_hex_str_16(outer));
                }
                strcat(mode, ")");
                break;
            }

            if (EXT_8BIT_DISPLACEMENT(extension) == 0) {
                sprintf(mode, "(A%d,%c%d.%c", instruction & 7, EXT_INDEX_AR(extension) ? 'A' : 'D', EXT_INDEX_REGISTER(extension), EXT_INDEX_LONG(extension) ? 'l' : 'w');
            } else {
                sprintf(mode, "(%s,A%d,%c%d.%c", make_signed_hex_str_8(extension), instruction & 7, EXT_INDEX_AR(extension) ? 'A' : 'D', EXT_INDEX_REGISTER(extension), EXT_INDEX_LONG(extension) ? 'l' : 'w');
            }
            if (EXT_INDEX_SCALE(extension)) {
                sprintf(mode + strlen(mode), "*%d", 1 << EXT_INDEX_SCALE(extension));
            }
            strcat(mode, ")");
            break;
        case 0x38:
            /* absolute short address */
            sprintf(mode, "$%x.w", read_imm_16());
            break;
        case 0x39:
            /* absolute long address */
            sprintf(mode, "$%x.l", read_imm_32());
            break;
        case 0x3a:
            /* program counter with displacement */
            temp_value = read_imm_16();
            sprintf(mode, "(%s,PC)", make_signed_hex_str_16(temp_value));
            sprintf(g_helper_str, "; ($%x)", (make_int_16(temp_value) + g_cpu_pc - 2) & 0xffffffff);
            break;
        case 0x3b:
            /* program counter with index */
            extension = read_imm_16();

            if (EXT_FULL(extension)) {
                if (EXT_EFFECTIVE_ZERO(extension)) {
                    strcpy(mode, "0");
                    break;
                }
                base = EXT_BASE_DISPLACEMENT_PRESENT(extension) ? (EXT_BASE_DISPLACEMENT_LONG(extension) ? read_imm_32() : read_imm_16()) : 0;
                outer = EXT_OUTER_DISPLACEMENT_PRESENT(extension) ? (EXT_OUTER_DISPLACEMENT_LONG(extension) ? read_imm_32() : read_imm_16()) : 0;
                if (EXT_BASE_REGISTER_PRESENT(extension)) {
                    strcpy(base_reg, "PC");
                } else {
                    *base_reg = 0;
                }
                if (EXT_INDEX_REGISTER_PRESENT(extension)) {
                    sprintf(index_reg, "%c%d.%c", EXT_INDEX_AR(extension) ? 'A' : 'D', EXT_INDEX_REGISTER(extension), EXT_INDEX_LONG(extension) ? 'l' : 'w');
                    if (EXT_INDEX_SCALE(extension)) {
                        sprintf(index_reg + strlen(index_reg), "*%d", 1 << EXT_INDEX_SCALE(extension));
                    }
                } else {
                    *index_reg = 0;
                }
                preindex = (extension & 7) > 0 && (extension & 7) < 4;
                postindex = (extension & 7) > 4;

                strcpy(mode, "(");
                if (preindex || postindex) {
                    strcat(mode, "[");
                }
                if (base) {
                    strcat(mode, make_signed_hex_str_16(base));
                    comma = 1;
                }
                if (*base_reg) {
                    if (comma) {
                        strcat(mode, ",");
                    }
                    strcat(mode, base_reg);
                    comma = 1;
                }
                if (postindex) {
                    strcat(mode, "]");
                    comma = 1;
                }
                if (*index_reg) {
                    if (comma) {
                        strcat(mode, ",");
                    }
                    strcat(mode, index_reg);
                    comma = 1;
                }
                if (preindex) {
                    strcat(mode, "]");
                    comma = 1;
                }
                if (outer) {
                    if (comma) {
                        strcat(mode, ",");
                    }
                    strcat(mode, make_signed_hex_str_16(outer));
                }
                strcat(mode, ")");
                break;
            }

            if (EXT_8BIT_DISPLACEMENT(extension) == 0) {
                sprintf(mode, "(PC,%c%d.%c", EXT_INDEX_AR(extension) ? 'A' : 'D', EXT_INDEX_REGISTER(extension), EXT_INDEX_LONG(extension) ? 'l' : 'w');
            } else {
                sprintf(mode, "(%s,PC,%c%d.%c", make_signed_hex_str_8(extension), EXT_INDEX_AR(extension) ? 'A' : 'D', EXT_INDEX_REGISTER(extension), EXT_INDEX_LONG(extension) ? 'l' : 'w');
            }
            if (EXT_INDEX_SCALE(extension)) {
                sprintf(mode + strlen(mode), "*%d", 1 << EXT_INDEX_SCALE(extension));
            }
            strcat(mode, ")");
            break;
        case 0x3c:
            /* Immediate */
            sprintf(mode, "%s", get_imm_str_u(size));
            break;
        default:
            sprintf(mode, "INVALID %x", instruction & 0x3f);
    }
    return mode;
}

/* ======================================================================== */
/* ========================= INSTRUCTION HANDLERS ========================= */
/* ======================================================================== */
/* Instruction handler function names follow this convention:
 *
 * d68000_NAME_EXTENSIONS(void)
 * where NAME is the name of the opcode it handles and EXTENSIONS are any
 * extensions for special instances of that opcode.
 *
 * Examples:
 *   d68000_add_er_8(): add opcode, from effective address to register,
 *                      size = byte
 *
 *   d68000_asr_s_8(): arithmetic shift right, static count, size = byte
 *
 *
 * Common extensions:
 * 8   : size = byte
 * 16  : size = word
 * 32  : size = long
 * rr  : register to register
 * mm  : memory to memory
 * r   : register
 * s   : static
 * er  : effective address -> register
 * re  : register -> effective address
 * ea  : using effective address mode of operation
 * d   : data register direct
 * a   : address register direct
 * ai  : address register indirect
 * pi  : address register indirect with postincrement
 * pd  : address register indirect with predecrement
 * di  : address register indirect with displacement
 * ix  : address register indirect with index
 * aw  : absolute word
 * al  : absolute long
 */

static void d68000_illegal(void)
{
    sprintf(g_dasm_str, "dc.w $%04x; ILLEGAL", g_cpu_ir);
}

static void d68000_1010(void)
{
    sprintf(g_dasm_str, "dc.w    $%04x; opcode 1010", g_cpu_ir);
}

static void d68000_1111(void)
{
    sprintf(g_dasm_str, "dc.w    $%04x; opcode 1111", g_cpu_ir);
}

static void d68000_abcd_rr(void)
{
    sprintf(g_dasm_str, "abcd    D%d, D%d", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_abcd_mm(void)
{
    sprintf(g_dasm_str, "abcd    -(A%d), -(A%d)", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_add_er_8(void)
{
    sprintf(g_dasm_str, "add.b   %s, D%d", get_ea_mode_str_8(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_add_er_16(void)
{
    sprintf(g_dasm_str, "add.w   %s, D%d", get_ea_mode_str_16(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_add_er_32(void)
{
    sprintf(g_dasm_str, "add.l   %s, D%d", get_ea_mode_str_32(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_add_re_8(void)
{
    sprintf(g_dasm_str, "add.b   D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_add_re_16(void)
{
    sprintf(g_dasm_str, "add.w   D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_add_re_32(void)
{
    sprintf(g_dasm_str, "add.l   D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_adda_16(void)
{
    sprintf(g_dasm_str, "adda.w  %s, A%d", get_ea_mode_str_16(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_adda_32(void)
{
    sprintf(g_dasm_str, "adda.l  %s, A%d", get_ea_mode_str_32(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_addi_8(void)
{
    char* str = get_imm_str_s8();
    sprintf(g_dasm_str, "addi.b  %s, %s", str, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_addi_16(void)
{
    char* str = get_imm_str_s16();
    sprintf(g_dasm_str, "addi.w  %s, %s", str, get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_addi_32(void)
{
    char* str = get_imm_str_s32();
    sprintf(g_dasm_str, "addi.l  %s, %s", str, get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_addq_8(void)
{
    sprintf(g_dasm_str, "addq.b  #%d, %s", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_addq_16(void)
{
    sprintf(g_dasm_str, "addq.w  #%d, %s", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_addq_32(void)
{
    sprintf(g_dasm_str, "addq.l  #%d, %s", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_addx_rr_8(void)
{
    sprintf(g_dasm_str, "addx.b  D%d, D%d", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_addx_rr_16(void)
{
    sprintf(g_dasm_str, "addx.w  D%d, D%d", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_addx_rr_32(void)
{
    sprintf(g_dasm_str, "addx.l  D%d, D%d", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_addx_mm_8(void)
{
    sprintf(g_dasm_str, "addx.b  -(A%d), -(A%d)", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_addx_mm_16(void)
{
    sprintf(g_dasm_str, "addx.w  -(A%d), -(A%d)", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_addx_mm_32(void)
{
    sprintf(g_dasm_str, "addx.l  -(A%d), -(A%d)", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_and_er_8(void)
{
    sprintf(g_dasm_str, "and.b   %s, D%d", get_ea_mode_str_8(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_and_er_16(void)
{
    sprintf(g_dasm_str, "and.w   %s, D%d", get_ea_mode_str_16(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_and_er_32(void)
{
    sprintf(g_dasm_str, "and.l   %s, D%d", get_ea_mode_str_32(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_and_re_8(void)
{
    sprintf(g_dasm_str, "and.b   D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_and_re_16(void)
{
    sprintf(g_dasm_str, "and.w   D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_and_re_32(void)
{
    sprintf(g_dasm_str, "and.l   D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_andi_8(void)
{
    char* str = get_imm_str_u8();
    sprintf(g_dasm_str, "andi.b  %s, %s", str, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_andi_16(void)
{
    char* str = get_imm_str_u16();
    sprintf(g_dasm_str, "andi.w  %s, %s", str, get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_andi_32(void)
{
    char* str = get_imm_str_u32();
    sprintf(g_dasm_str, "andi.l  %s, %s", str, get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_andi_to_ccr(void)
{
    sprintf(g_dasm_str, "andi    %s, CCR", get_imm_str_u8());
}

static void d68000_andi_to_sr(void)
{
    sprintf(g_dasm_str, "andi    %s, SR", get_imm_str_u16());
}

static void d68000_asr_s_8(void)
{
    sprintf(g_dasm_str, "asr.b   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_asr_s_16(void)
{
    sprintf(g_dasm_str, "asr.w   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_asr_s_32(void)
{
    sprintf(g_dasm_str, "asr.l   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_asr_r_8(void)
{
    sprintf(g_dasm_str, "asr.b   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_asr_r_16(void)
{
    sprintf(g_dasm_str, "asr.w   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_asr_r_32(void)
{
    sprintf(g_dasm_str, "asr.l   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_asr_ea(void)
{
    sprintf(g_dasm_str, "asr.w   %s", get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_asl_s_8(void)
{
    sprintf(g_dasm_str, "asl.b   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_asl_s_16(void)
{
    sprintf(g_dasm_str, "asl.w   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_asl_s_32(void)
{
    sprintf(g_dasm_str, "asl.l   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_asl_r_8(void)
{
    sprintf(g_dasm_str, "asl.b   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_asl_r_16(void)
{
    sprintf(g_dasm_str, "asl.w   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_asl_r_32(void)
{
    sprintf(g_dasm_str, "asl.l   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_asl_ea(void)
{
    sprintf(g_dasm_str, "asl.w   %s", get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_bcc_8(void)
{
    uint temp_pc = g_cpu_pc;
    sprintf(g_dasm_str, "b%-2s     $%x", g_cc[(g_cpu_ir >> 8) & 0xf], temp_pc + make_int_8(g_cpu_ir));
}

static void d68000_bcc_16(void)
{
    uint temp_pc = g_cpu_pc;
    sprintf(g_dasm_str, "b%-2s     $%x", g_cc[(g_cpu_ir >> 8) & 0xf], temp_pc + make_int_16(read_imm_16()));
}

static void d68020_bcc_32(void)
{
    uint temp_pc = g_cpu_pc;
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "b%-2s     $%x; (2+)", g_cc[(g_cpu_ir >> 8) & 0xf], temp_pc + read_imm_32());
}

static void d68000_bchg_r(void)
{
    sprintf(g_dasm_str, "bchg    D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_bchg_s(void)
{
    char* str = get_imm_str_u8();
    sprintf(g_dasm_str, "bchg    %s, %s", str, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_bclr_r(void)
{
    sprintf(g_dasm_str, "bclr    D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_bclr_s(void)
{
    char* str = get_imm_str_u8();
    sprintf(g_dasm_str, "bclr    %s, %s", str, get_ea_mode_str_8(g_cpu_ir));
}

static void d68010_bkpt(void)
{
    LIMIT_CPU_TYPES(M68010_PLUS);
    sprintf(g_dasm_str, "bkpt #%d; (1+)", g_cpu_ir & 7);
}

static void d68020_bfchg(void)
{
    uint extension;
    char offset[3];
    char width[3];

    LIMIT_CPU_TYPES(M68020_PLUS);

    extension = read_imm_16();

    if (BIT_B(extension)) {
        sprintf(offset, "D%d", (extension >> 6) & 7);
    } else {
        sprintf(offset, "%d", (extension >> 6) & 31);
    }
    if (BIT_5(extension)) {
        sprintf(width, "D%d", extension & 7);
    } else {
        sprintf(width, "%d", g_5bit_data_table[extension & 31]);
    }
    sprintf(g_dasm_str, "bfchg   %s {%s:%s}; (2+)", get_ea_mode_str_8(g_cpu_ir), offset, width);
}

static void d68020_bfclr(void)
{
    uint extension;
    char offset[3];
    char width[3];

    LIMIT_CPU_TYPES(M68020_PLUS);

    extension = read_imm_16();

    if (BIT_B(extension)) {
        sprintf(offset, "D%d", (extension >> 6) & 7);
    } else {
        sprintf(offset, "%d", (extension >> 6) & 31);
    }
    if (BIT_5(extension)) {
        sprintf(width, "D%d", extension & 7);
    } else {
        sprintf(width, "%d", g_5bit_data_table[extension & 31]);
    }
    sprintf(g_dasm_str, "bfclr   %s {%s:%s}; (2+)", get_ea_mode_str_8(g_cpu_ir), offset, width);
}

static void d68020_bfexts(void)
{
    uint extension;
    char offset[3];
    char width[3];

    LIMIT_CPU_TYPES(M68020_PLUS);

    extension = read_imm_16();

    if (BIT_B(extension)) {
        sprintf(offset, "D%d", (extension >> 6) & 7);
    } else {
        sprintf(offset, "%d", (extension >> 6) & 31);
    }
    if (BIT_5(extension)) {
        sprintf(width, "D%d", extension & 7);
    } else {
        sprintf(width, "%d", g_5bit_data_table[extension & 31]);
    }
    sprintf(g_dasm_str, "bfexts  %s {%s:%s}, D%d; (2+)", get_ea_mode_str_8(g_cpu_ir), offset, width, (extension >> 12) & 7);
}

static void d68020_bfextu(void)
{
    uint extension;
    char offset[3];
    char width[3];

    LIMIT_CPU_TYPES(M68020_PLUS);

    extension = read_imm_16();

    if (BIT_B(extension)) {
        sprintf(offset, "D%d", (extension >> 6) & 7);
    } else {
        sprintf(offset, "%d", (extension >> 6) & 31);
    }
    if (BIT_5(extension)) {
        sprintf(width, "D%d", extension & 7);
    } else {
        sprintf(width, "%d", g_5bit_data_table[extension & 31]);
    }
    sprintf(g_dasm_str, "bfextu  %s {%s:%s}, D%d; (2+)", get_ea_mode_str_8(g_cpu_ir), offset, width, (extension >> 12) & 7);
}

static void d68020_bfffo(void)
{
    uint extension;
    char offset[3];
    char width[3];

    LIMIT_CPU_TYPES(M68020_PLUS);

    extension = read_imm_16();

    if (BIT_B(extension)) {
        sprintf(offset, "D%d", (extension >> 6) & 7);
    } else {
        sprintf(offset, "%d", (extension >> 6) & 31);
    }
    if (BIT_5(extension)) {
        sprintf(width, "D%d", extension & 7);
    } else {
        sprintf(width, "%d", g_5bit_data_table[extension & 31]);
    }
    sprintf(g_dasm_str, "bfffo   %s {%s:%s}, D%d; (2+)", get_ea_mode_str_8(g_cpu_ir), offset, width, (extension >> 12) & 7);
}

static void d68020_bfins(void)
{
    uint extension;
    char offset[3];
    char width[3];

    LIMIT_CPU_TYPES(M68020_PLUS);

    extension = read_imm_16();

    if (BIT_B(extension)) {
        sprintf(offset, "D%d", (extension >> 6) & 7);
    } else {
        sprintf(offset, "%d", (extension >> 6) & 31);
    }
    if (BIT_5(extension)) {
        sprintf(width, "D%d", extension & 7);
    } else {
        sprintf(width, "%d", g_5bit_data_table[extension & 31]);
    }
    sprintf(g_dasm_str, "bfins   D%d, %s {%s:%s}; (2+)", (extension >> 12) & 7, get_ea_mode_str_8(g_cpu_ir), offset, width);
}

static void d68020_bfset(void)
{
    uint extension;
    char offset[3];
    char width[3];

    LIMIT_CPU_TYPES(M68020_PLUS);

    extension = read_imm_16();

    if (BIT_B(extension)) {
        sprintf(offset, "D%d", (extension >> 6) & 7);
    } else {
        sprintf(offset, "%d", (extension >> 6) & 31);
    }
    if (BIT_5(extension)) {
        sprintf(width, "D%d", extension & 7);
    } else {
        sprintf(width, "%d", g_5bit_data_table[extension & 31]);
    }
    sprintf(g_dasm_str, "bfset   %s {%s:%s}; (2+)", get_ea_mode_str_8(g_cpu_ir), offset, width);
}

static void d68020_bftst(void)
{
    uint extension;
    char offset[3];
    char width[3];

    LIMIT_CPU_TYPES(M68020_PLUS);

    extension = read_imm_16();

    if (BIT_B(extension)) {
        sprintf(offset, "D%d", (extension >> 6) & 7);
    } else {
        sprintf(offset, "%d", (extension >> 6) & 31);
    }
    if (BIT_5(extension)) {
        sprintf(width, "D%d", extension & 7);
    } else {
        sprintf(width, "%d", g_5bit_data_table[extension & 31]);
    }
    sprintf(g_dasm_str, "bftst   %s {%s:%s}; (2+)", get_ea_mode_str_8(g_cpu_ir), offset, width);
}

static void d68000_bra_8(void)
{
    uint temp_pc = g_cpu_pc;
    sprintf(g_dasm_str, "bra     $%x", temp_pc + make_int_8(g_cpu_ir));
}

static void d68000_bra_16(void)
{
    uint temp_pc = g_cpu_pc;
    sprintf(g_dasm_str, "bra     $%x", temp_pc + make_int_16(read_imm_16()));
}

static void d68020_bra_32(void)
{
    uint temp_pc = g_cpu_pc;
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "bra     $%x; (2+)", temp_pc + read_imm_32());
}

static void d68000_bset_r(void)
{
    sprintf(g_dasm_str, "bset    D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_bset_s(void)
{
    char* str = get_imm_str_u8();
    sprintf(g_dasm_str, "bset    %s, %s", str, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_bsr_8(void)
{
    uint temp_pc = g_cpu_pc;
    sprintf(g_dasm_str, "bsr     $%x", temp_pc + make_int_8(g_cpu_ir));
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OVER);
}

static void d68000_bsr_16(void)
{
    uint temp_pc = g_cpu_pc;
    sprintf(g_dasm_str, "bsr     $%x", temp_pc + make_int_16(read_imm_16()));
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OVER);
}

static void d68020_bsr_32(void)
{
    uint temp_pc = g_cpu_pc;
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "bsr     $%x; (2+)", temp_pc + read_imm_32());
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OVER);
}

static void d68000_btst_r(void)
{
    sprintf(g_dasm_str, "btst    D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_btst_s(void)
{
    char* str = get_imm_str_u8();
    sprintf(g_dasm_str, "btst    %s, %s", str, get_ea_mode_str_8(g_cpu_ir));
}

static void d68020_callm(void)
{
    char* str;
    LIMIT_CPU_TYPES(M68020_ONLY);
    str = get_imm_str_u8();

    sprintf(g_dasm_str, "callm   %s, %s; (2)", str, get_ea_mode_str_8(g_cpu_ir));
}

static void d68020_cas_8(void)
{
    uint extension;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension = read_imm_16();
    sprintf(g_dasm_str, "cas.b   D%d, D%d, %s; (2+)", extension & 7, (extension >> 6) & 7, get_ea_mode_str_8(g_cpu_ir));
}

static void d68020_cas_16(void)
{
    uint extension;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension = read_imm_16();
    sprintf(g_dasm_str, "cas.w   D%d, D%d, %s; (2+)", extension & 7, (extension >> 6) & 7, get_ea_mode_str_16(g_cpu_ir));
}

static void d68020_cas_32(void)
{
    uint extension;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension = read_imm_16();
    sprintf(g_dasm_str, "cas.l   D%d, D%d, %s; (2+)", extension & 7, (extension >> 6) & 7, get_ea_mode_str_32(g_cpu_ir));
}

static void d68020_cas2_16(void)
{
    /* CAS2 Dc1:Dc2,Du1:Dc2:(Rn1):(Rn2)
    f e d c b a 9 8 7 6 5 4 3 2 1 0
     DARn1  0 0 0  Du1  0 0 0  Dc1
     DARn2  0 0 0  Du2  0 0 0  Dc2
    */

    uint extension;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension = read_imm_32();
    sprintf(g_dasm_str, "cas2.w  D%d:D%d, D%d:D%d, (%c%d):(%c%d); (2+)",
            (extension >> 16) & 7, extension & 7, (extension >> 22) & 7, (extension >> 6) & 7,
            BIT_1F(extension) ? 'A' : 'D', (extension >> 28) & 7,
            BIT_F(extension) ? 'A' : 'D', (extension >> 12) & 7);
}

static void d68020_cas2_32(void)
{
    uint extension;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension = read_imm_32();
    sprintf(g_dasm_str, "cas2.l  D%d:D%d, D%d:D%d, (%c%d):(%c%d); (2+)",
            (extension >> 16) & 7, extension & 7, (extension >> 22) & 7, (extension >> 6) & 7,
            BIT_1F(extension) ? 'A' : 'D', (extension >> 28) & 7,
            BIT_F(extension) ? 'A' : 'D', (extension >> 12) & 7);
}

static void d68000_chk_16(void)
{
    sprintf(g_dasm_str, "chk.w   %s, D%d", get_ea_mode_str_16(g_cpu_ir), (g_cpu_ir >> 9) & 7);
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OVER);
}

static void d68020_chk_32(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "chk.l   %s, D%d; (2+)", get_ea_mode_str_32(g_cpu_ir), (g_cpu_ir >> 9) & 7);
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OVER);
}

static void d68020_chk2_cmp2_8(void)
{
    uint extension;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension = read_imm_16();
    sprintf(g_dasm_str, "%s.b  %s, %c%d; (2+)", BIT_B(extension) ? "chk2" : "cmp2", get_ea_mode_str_8(g_cpu_ir), BIT_F(extension) ? 'A' : 'D', (extension >> 12) & 7);
}

static void d68020_chk2_cmp2_16(void)
{
    uint extension;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension = read_imm_16();
    sprintf(g_dasm_str, "%s.w  %s, %c%d; (2+)", BIT_B(extension) ? "chk2" : "cmp2", get_ea_mode_str_16(g_cpu_ir), BIT_F(extension) ? 'A' : 'D', (extension >> 12) & 7);
}

static void d68020_chk2_cmp2_32(void)
{
    uint extension;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension = read_imm_16();
    sprintf(g_dasm_str, "%s.l  %s, %c%d; (2+)", BIT_B(extension) ? "chk2" : "cmp2", get_ea_mode_str_32(g_cpu_ir), BIT_F(extension) ? 'A' : 'D', (extension >> 12) & 7);
}

static void d68040_cinv(void)
{
    LIMIT_CPU_TYPES(M68040_PLUS);
    switch ((g_cpu_ir >> 3) & 3) {
        case 0:
            sprintf(g_dasm_str, "cinv (illegal scope); (4)");
            break;
        case 1:
            sprintf(g_dasm_str, "cinvl   %d, (A%d); (4)", (g_cpu_ir >> 6) & 3, g_cpu_ir & 7);
            break;
        case 2:
            sprintf(g_dasm_str, "cinvp   %d, (A%d); (4)", (g_cpu_ir >> 6) & 3, g_cpu_ir & 7);
            break;
        case 3:
            sprintf(g_dasm_str, "cinva   %d; (4)", (g_cpu_ir >> 6) & 3);
            break;
    }
}

static void d68000_clr_8(void)
{
    sprintf(g_dasm_str, "clr.b   %s", get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_clr_16(void)
{
    sprintf(g_dasm_str, "clr.w   %s", get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_clr_32(void)
{
    sprintf(g_dasm_str, "clr.l   %s", get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_cmp_8(void)
{
    sprintf(g_dasm_str, "cmp.b   %s, D%d", get_ea_mode_str_8(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_cmp_16(void)
{
    sprintf(g_dasm_str, "cmp.w   %s, D%d", get_ea_mode_str_16(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_cmp_32(void)
{
    sprintf(g_dasm_str, "cmp.l   %s, D%d", get_ea_mode_str_32(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_cmpa_16(void)
{
    sprintf(g_dasm_str, "cmpa.w  %s, A%d", get_ea_mode_str_16(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_cmpa_32(void)
{
    sprintf(g_dasm_str, "cmpa.l  %s, A%d", get_ea_mode_str_32(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_cmpi_8(void)
{
    char* str = get_imm_str_s8();
    sprintf(g_dasm_str, "cmpi.b  %s, %s", str, get_ea_mode_str_8(g_cpu_ir));
}

static void d68020_cmpi_pcdi_8(void)
{
    char* str;
    LIMIT_CPU_TYPES(M68010_PLUS);
    str = get_imm_str_s8();
    sprintf(g_dasm_str, "cmpi.b  %s, %s; (2+)", str, get_ea_mode_str_8(g_cpu_ir));
}

static void d68020_cmpi_pcix_8(void)
{
    char* str;
    LIMIT_CPU_TYPES(M68010_PLUS);
    str = get_imm_str_s8();
    sprintf(g_dasm_str, "cmpi.b  %s, %s; (2+)", str, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_cmpi_16(void)
{
    char* str;
    str = get_imm_str_s16();
    sprintf(g_dasm_str, "cmpi.w  %s, %s", str, get_ea_mode_str_16(g_cpu_ir));
}

static void d68020_cmpi_pcdi_16(void)
{
    char* str;
    LIMIT_CPU_TYPES(M68010_PLUS);
    str = get_imm_str_s16();
    sprintf(g_dasm_str, "cmpi.w  %s, %s; (2+)", str, get_ea_mode_str_16(g_cpu_ir));
}

static void d68020_cmpi_pcix_16(void)
{
    char* str;
    LIMIT_CPU_TYPES(M68010_PLUS);
    str = get_imm_str_s16();
    sprintf(g_dasm_str, "cmpi.w  %s, %s; (2+)", str, get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_cmpi_32(void)
{
    char* str;
    str = get_imm_str_s32();
    sprintf(g_dasm_str, "cmpi.l  %s, %s", str, get_ea_mode_str_32(g_cpu_ir));
}

static void d68020_cmpi_pcdi_32(void)
{
    char* str;
    LIMIT_CPU_TYPES(M68010_PLUS);
    str = get_imm_str_s32();
    sprintf(g_dasm_str, "cmpi.l  %s, %s; (2+)", str, get_ea_mode_str_32(g_cpu_ir));
}

static void d68020_cmpi_pcix_32(void)
{
    char* str;
    LIMIT_CPU_TYPES(M68010_PLUS);
    str = get_imm_str_s32();
    sprintf(g_dasm_str, "cmpi.l  %s, %s; (2+)", str, get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_cmpm_8(void)
{
    sprintf(g_dasm_str, "cmpm.b  (A%d)+, (A%d)+", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_cmpm_16(void)
{
    sprintf(g_dasm_str, "cmpm.w  (A%d)+, (A%d)+", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_cmpm_32(void)
{
    sprintf(g_dasm_str, "cmpm.l  (A%d)+, (A%d)+", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68020_cpbcc_16(void)
{
    uint extension;
    uint new_pc = g_cpu_pc;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension = read_imm_16();
    new_pc += make_int_16(read_imm_16());
    sprintf(g_dasm_str, "%db%-4s  %s; %x (extension = %x) (2-3)", (g_cpu_ir >> 9) & 7, g_cpcc[g_cpu_ir & 0x3f], get_imm_str_s16(), new_pc, extension);
}

static void d68020_cpbcc_32(void)
{
    uint extension;
    uint new_pc = g_cpu_pc;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension = read_imm_16();
    new_pc += read_imm_32();
    sprintf(g_dasm_str, "%db%-4s  %s; %x (extension = %x) (2-3)", (g_cpu_ir >> 9) & 7, g_cpcc[g_cpu_ir & 0x3f], get_imm_str_s16(), new_pc, extension);
}

static void d68020_cpdbcc(void)
{
    uint extension1;
    uint extension2;
    uint new_pc = g_cpu_pc;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension1 = read_imm_16();
    extension2 = read_imm_16();
    new_pc += make_int_16(read_imm_16());
    sprintf(g_dasm_str, "%ddb%-4s D%d,%s; %x (extension = %x) (2-3)", (g_cpu_ir >> 9) & 7, g_cpcc[extension1 & 0x3f], g_cpu_ir & 7, get_imm_str_s16(), new_pc, extension2);
}

static void d68020_cpgen(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "%dgen    %s; (2-3)", (g_cpu_ir >> 9) & 7, get_imm_str_u32());
}

static void d68020_cprestore(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    if (((g_cpu_ir >> 9) & 7) == 1) {
        sprintf(g_dasm_str, "frestore %s", get_ea_mode_str_8(g_cpu_ir));
    } else {
        sprintf(g_dasm_str, "%drestore %s; (2-3)", (g_cpu_ir >> 9) & 7, get_ea_mode_str_8(g_cpu_ir));
    }
}

static void d68020_cpsave(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    if (((g_cpu_ir >> 9) & 7) == 1) {
        sprintf(g_dasm_str, "fsave   %s", get_ea_mode_str_8(g_cpu_ir));
    } else {
        sprintf(g_dasm_str, "%dsave   %s; (2-3)", (g_cpu_ir >> 9) & 7, get_ea_mode_str_8(g_cpu_ir));
    }
}

static void d68020_cpscc(void)
{
    uint extension1;
    uint extension2;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension1 = read_imm_16();
    extension2 = read_imm_16();
    sprintf(g_dasm_str, "%ds%-4s  %s; (extension = %x) (2-3)", (g_cpu_ir >> 9) & 7, g_cpcc[extension1 & 0x3f], get_ea_mode_str_8(g_cpu_ir), extension2);
}

static void d68020_cptrapcc_0(void)
{
    uint extension1;
    uint extension2;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension1 = read_imm_16();
    extension2 = read_imm_16();
    sprintf(g_dasm_str, "%dtrap%-4s; (extension = %x) (2-3)", (g_cpu_ir >> 9) & 7, g_cpcc[extension1 & 0x3f], extension2);
}

static void d68020_cptrapcc_16(void)
{
    uint extension1;
    uint extension2;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension1 = read_imm_16();
    extension2 = read_imm_16();
    sprintf(g_dasm_str, "%dtrap%-4s %s; (extension = %x) (2-3)", (g_cpu_ir >> 9) & 7, g_cpcc[extension1 & 0x3f], get_imm_str_u16(), extension2);
}

static void d68020_cptrapcc_32(void)
{
    uint extension1;
    uint extension2;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension1 = read_imm_16();
    extension2 = read_imm_16();
    sprintf(g_dasm_str, "%dtrap%-4s %s; (extension = %x) (2-3)", (g_cpu_ir >> 9) & 7, g_cpcc[extension1 & 0x3f], get_imm_str_u32(), extension2);
}

static void d68040_cpush(void)
{
    LIMIT_CPU_TYPES(M68040_PLUS);
    switch ((g_cpu_ir >> 3) & 3) {
        case 0:
            sprintf(g_dasm_str, "cpush (illegal scope); (4)");
            break;
        case 1:
            sprintf(g_dasm_str, "cpushl  %d, (A%d); (4)", (g_cpu_ir >> 6) & 3, g_cpu_ir & 7);
            break;
        case 2:
            sprintf(g_dasm_str, "cpushp  %d, (A%d); (4)", (g_cpu_ir >> 6) & 3, g_cpu_ir & 7);
            break;
        case 3:
            sprintf(g_dasm_str, "cpusha  %d; (4)", (g_cpu_ir >> 6) & 3);
            break;
    }
}

static void d68000_dbra(void)
{
    uint temp_pc = g_cpu_pc;
    sprintf(g_dasm_str, "dbra    D%d, $%x", g_cpu_ir & 7, temp_pc + make_int_16(read_imm_16()));
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OVER);
}

static void d68000_dbcc(void)
{
    uint temp_pc = g_cpu_pc;
    sprintf(g_dasm_str, "db%-2s    D%d, $%x", g_cc[(g_cpu_ir >> 8) & 0xf], g_cpu_ir & 7, temp_pc + make_int_16(read_imm_16()));
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OVER);
}

static void d68000_divs(void)
{
    sprintf(g_dasm_str, "divs.w  %s, D%d", get_ea_mode_str_16(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_divu(void)
{
    sprintf(g_dasm_str, "divu.w  %s, D%d", get_ea_mode_str_16(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68020_divl(void)
{
    uint extension;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension = read_imm_16();

    if (BIT_A(extension)) {
        sprintf(g_dasm_str, "div%c.l  %s, D%d:D%d; (2+)", BIT_B(extension) ? 's' : 'u', get_ea_mode_str_32(g_cpu_ir), extension & 7, (extension >> 12) & 7);
    } else if ((extension & 7) == ((extension >> 12) & 7)) {
        sprintf(g_dasm_str, "div%c.l  %s, D%d; (2+)", BIT_B(extension) ? 's' : 'u', get_ea_mode_str_32(g_cpu_ir), (extension >> 12) & 7);
    } else {
        sprintf(g_dasm_str, "div%cl.l %s, D%d:D%d; (2+)", BIT_B(extension) ? 's' : 'u', get_ea_mode_str_32(g_cpu_ir), extension & 7, (extension >> 12) & 7);
    }
}

static void d68000_eor_8(void)
{
    sprintf(g_dasm_str, "eor.b   D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_eor_16(void)
{
    sprintf(g_dasm_str, "eor.w   D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_eor_32(void)
{
    sprintf(g_dasm_str, "eor.l   D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_eori_8(void)
{
    char* str = get_imm_str_u8();
    sprintf(g_dasm_str, "eori.b  %s, %s", str, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_eori_16(void)
{
    char* str = get_imm_str_u16();
    sprintf(g_dasm_str, "eori.w  %s, %s", str, get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_eori_32(void)
{
    char* str = get_imm_str_u32();
    sprintf(g_dasm_str, "eori.l  %s, %s", str, get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_eori_to_ccr(void)
{
    sprintf(g_dasm_str, "eori    %s, CCR", get_imm_str_u8());
}

static void d68000_eori_to_sr(void)
{
    sprintf(g_dasm_str, "eori    %s, SR", get_imm_str_u16());
}

static void d68000_exg_dd(void)
{
    sprintf(g_dasm_str, "exg     D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_exg_aa(void)
{
    sprintf(g_dasm_str, "exg     A%d, A%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_exg_da(void)
{
    sprintf(g_dasm_str, "exg     D%d, A%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_ext_16(void)
{
    sprintf(g_dasm_str, "ext.w   D%d", g_cpu_ir & 7);
}

static void d68000_ext_32(void)
{
    sprintf(g_dasm_str, "ext.l   D%d", g_cpu_ir & 7);
}

static void d68020_extb_32(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "extb.l  D%d; (2+)", g_cpu_ir & 7);
}

static void d68040_fpu(void)
{
    char float_data_format[8][3] =
        {
            ".l", ".s", ".x", ".p", ".w", ".d", ".b", ".p"};

    char mnemonic[40];
    uint32 w2, src, dst_reg;
    LIMIT_CPU_TYPES(M68030_PLUS);
    w2 = read_imm_16();

    src = (w2 >> 10) & 0x7;
    dst_reg = (w2 >> 7) & 0x7;

    // special override for FMOVECR
    if ((((w2 >> 13) & 0x7) == 2) && (((w2 >> 10) & 0x7) == 7)) {
        sprintf(g_dasm_str, "fmovecr   #$%0x, fp%d", (w2 & 0x7f), dst_reg);
        return;
    }

    switch ((w2 >> 13) & 0x7) {
        case 0x0:
        case 0x2: {
            switch (w2 & 0x7f) {
                case 0x00:
                    sprintf(mnemonic, "fmove");
                    break;
                case 0x01:
                    sprintf(mnemonic, "fint");
                    break;
                case 0x02:
                    sprintf(mnemonic, "fsinh");
                    break;
                case 0x03:
                    sprintf(mnemonic, "fintrz");
                    break;
                case 0x04:
                    sprintf(mnemonic, "fsqrt");
                    break;
                case 0x06:
                    sprintf(mnemonic, "flognp1");
                    break;
                case 0x08:
                    sprintf(mnemonic, "fetoxm1");
                    break;
                case 0x09:
                    sprintf(mnemonic, "ftanh1");
                    break;
                case 0x0a:
                    sprintf(mnemonic, "fatan");
                    break;
                case 0x0c:
                    sprintf(mnemonic, "fasin");
                    break;
                case 0x0d:
                    sprintf(mnemonic, "fatanh");
                    break;
                case 0x0e:
                    sprintf(mnemonic, "fsin");
                    break;
                case 0x0f:
                    sprintf(mnemonic, "ftan");
                    break;
                case 0x10:
                    sprintf(mnemonic, "fetox");
                    break;
                case 0x11:
                    sprintf(mnemonic, "ftwotox");
                    break;
                case 0x12:
                    sprintf(mnemonic, "ftentox");
                    break;
                case 0x14:
                    sprintf(mnemonic, "flogn");
                    break;
                case 0x15:
                    sprintf(mnemonic, "flog10");
                    break;
                case 0x16:
                    sprintf(mnemonic, "flog2");
                    break;
                case 0x18:
                    sprintf(mnemonic, "fabs");
                    break;
                case 0x19:
                    sprintf(mnemonic, "fcosh");
                    break;
                case 0x1a:
                    sprintf(mnemonic, "fneg");
                    break;
                case 0x1c:
                    sprintf(mnemonic, "facos");
                    break;
                case 0x1d:
                    sprintf(mnemonic, "fcos");
                    break;
                case 0x1e:
                    sprintf(mnemonic, "fgetexp");
                    break;
                case 0x1f:
                    sprintf(mnemonic, "fgetman");
                    break;
                case 0x20:
                    sprintf(mnemonic, "fdiv");
                    break;
                case 0x21:
                    sprintf(mnemonic, "fmod");
                    break;
                case 0x22:
                    sprintf(mnemonic, "fadd");
                    break;
                case 0x23:
                    sprintf(mnemonic, "fmul");
                    break;
                case 0x24:
                    sprintf(mnemonic, "fsgldiv");
                    break;
                case 0x25:
                    sprintf(mnemonic, "frem");
                    break;
                case 0x26:
                    sprintf(mnemonic, "fscale");
                    break;
                case 0x27:
                    sprintf(mnemonic, "fsglmul");
                    break;
                case 0x28:
                    sprintf(mnemonic, "fsub");
                    break;
                case 0x30:
                case 0x31:
                case 0x32:
                case 0x33:
                case 0x34:
                case 0x35:
                case 0x36:
                case 0x37:
                    sprintf(mnemonic, "fsincos");
                    break;
                case 0x38:
                    sprintf(mnemonic, "fcmp");
                    break;
                case 0x3a:
                    sprintf(mnemonic, "ftst");
                    break;
                case 0x41:
                    sprintf(mnemonic, "fssqrt");
                    break;
                case 0x44:
                    sprintf(mnemonic, "fdmoved");
                    break;
                case 0x45:
                    sprintf(mnemonic, "fdsqrt");
                    break;
                case 0x58:
                    sprintf(mnemonic, "fsabs");
                    break;
                case 0x5a:
                    sprintf(mnemonic, "fsneg");
                    break;
                case 0x5c:
                    sprintf(mnemonic, "fdabs");
                    break;
                case 0x5e:
                    sprintf(mnemonic, "fdneg");
                    break;
                case 0x60:
                    sprintf(mnemonic, "fsdiv");
                    break;
                case 0x62:
                    sprintf(mnemonic, "fsadd");
                    break;
                case 0x63:
                    sprintf(mnemonic, "fsmul");
                    break;
                case 0x64:
                    sprintf(mnemonic, "fddiv");
                    break;
                case 0x66:
                    sprintf(mnemonic, "fdadd");
                    break;
                case 0x67:
                    sprintf(mnemonic, "fdmul");
                    break;
                case 0x68:
                    sprintf(mnemonic, "fssub");
                    break;
                case 0x6c:
                    sprintf(mnemonic, "fdsub");
                    break;

                default:
                    sprintf(mnemonic, "FPU (?)");
                    break;
            }

            if (w2 & 0x4000) {
                sprintf(g_dasm_str, "%s%s   %s, FP%d", mnemonic, float_data_format[src], get_ea_mode_str_32(g_cpu_ir), dst_reg);
            } else {
                sprintf(g_dasm_str, "%s.x   FP%d, FP%d", mnemonic, src, dst_reg);
            }
            break;
        }

        case 0x3: {
            switch ((w2 >> 10) & 7) {
                case 3: // packed decimal w/fixed k-factor
                    sprintf(g_dasm_str, "fmove%s   FP%d, %s {#%d}", float_data_format[(w2 >> 10) & 7], dst_reg, get_ea_mode_str_32(g_cpu_ir), sext_7bit_int(w2 & 0x7f));
                    break;

                case 7: // packed decimal w/dynamic k-factor (register)
                    sprintf(g_dasm_str, "fmove%s   FP%d, %s {D%d}", float_data_format[(w2 >> 10) & 7], dst_reg, get_ea_mode_str_32(g_cpu_ir), (w2 >> 4) & 7);
                    break;

                default:
                    sprintf(g_dasm_str, "fmove%s   FP%d, %s", float_data_format[(w2 >> 10) & 7], dst_reg, get_ea_mode_str_32(g_cpu_ir));
                    break;
            }
            break;
        }

        case 0x4: // ea to control
        {
            sprintf(g_dasm_str, "fmovem.l   %s, ", get_ea_mode_str_32(g_cpu_ir));
            if (w2 & 0x1000) {
                strcat(g_dasm_str, "fpcr");
            }
            if (w2 & 0x0800) {
                strcat(g_dasm_str, "/fpsr");
            }
            if (w2 & 0x0400) {
                strcat(g_dasm_str, "/fpiar");
            }
            break;
        }

        case 0x5: // control to ea
        {

            strcpy(g_dasm_str, "fmovem.l   ");
            if (w2 & 0x1000) {
                strcat(g_dasm_str, "fpcr");
            }
            if (w2 & 0x0800) {
                strcat(g_dasm_str, "/fpsr");
            }
            if (w2 & 0x0400) {
                strcat(g_dasm_str, "/fpiar");
            }
            strcat(g_dasm_str, ", ");
            strcat(g_dasm_str, get_ea_mode_str_32(g_cpu_ir));
            break;
        }

        case 0x6: // memory to FPU, list
        {
            char temp[32];

            if ((w2 >> 11) & 1) // dynamic register list
            {
                sprintf(g_dasm_str, "fmovem.x   %s, D%d", get_ea_mode_str_32(g_cpu_ir), (w2 >> 4) & 7);
            } else // static register list
            {
                int i;

                sprintf(g_dasm_str, "fmovem.x   %s, ", get_ea_mode_str_32(g_cpu_ir));

                for (i = 0; i < 8; i++) {
                    if (w2 & (1 << i)) {
                        if ((w2 >> 12) & 1) // postincrement or control
                        {
                            sprintf(temp, "FP%d ", 7 - i);
                        } else // predecrement
                        {
                            sprintf(temp, "FP%d ", i);
                        }
                        strcat(g_dasm_str, temp);
                    }
                }
            }
            break;
        }

        case 0x7: // FPU to memory, list
        {
            char temp[32];

            if ((w2 >> 11) & 1) // dynamic register list
            {
                sprintf(g_dasm_str, "fmovem.x   D%d, %s", (w2 >> 4) & 7, get_ea_mode_str_32(g_cpu_ir));
            } else // static register list
            {
                int i;

                sprintf(g_dasm_str, "fmovem.x   ");

                for (i = 0; i < 8; i++) {
                    if (w2 & (1 << i)) {
                        if ((w2 >> 12) & 1) // postincrement or control
                        {
                            sprintf(temp, "FP%d ", 7 - i);
                        } else // predecrement
                        {
                            sprintf(temp, "FP%d ", i);
                        }
                        strcat(g_dasm_str, temp);
                    }
                }

                strcat(g_dasm_str, ", ");
                strcat(g_dasm_str, get_ea_mode_str_32(g_cpu_ir));
            }
            break;
        }

        default: {
            sprintf(g_dasm_str, "FPU (?) ");
            break;
        }
    }
}

static void d68000_jmp(void)
{
    sprintf(g_dasm_str, "jmp     %s", get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_jsr(void)
{
    sprintf(g_dasm_str, "jsr     %s", get_ea_mode_str_32(g_cpu_ir));
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OVER);
}

static void d68000_lea(void)
{
    sprintf(g_dasm_str, "lea     %s, A%d", get_ea_mode_str_32(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_link_16(void)
{
    sprintf(g_dasm_str, "link    A%d, %s", g_cpu_ir & 7, get_imm_str_s16());
}

static void d68020_link_32(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "link    A%d, %s; (2+)", g_cpu_ir & 7, get_imm_str_s32());
}

static void d68000_lsr_s_8(void)
{
    sprintf(g_dasm_str, "lsr.b   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_lsr_s_16(void)
{
    sprintf(g_dasm_str, "lsr.w   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_lsr_s_32(void)
{
    sprintf(g_dasm_str, "lsr.l   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_lsr_r_8(void)
{
    sprintf(g_dasm_str, "lsr.b   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_lsr_r_16(void)
{
    sprintf(g_dasm_str, "lsr.w   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_lsr_r_32(void)
{
    sprintf(g_dasm_str, "lsr.l   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_lsr_ea(void)
{
    sprintf(g_dasm_str, "lsr.w   %s", get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_lsl_s_8(void)
{
    sprintf(g_dasm_str, "lsl.b   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_lsl_s_16(void)
{
    sprintf(g_dasm_str, "lsl.w   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_lsl_s_32(void)
{
    sprintf(g_dasm_str, "lsl.l   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_lsl_r_8(void)
{
    sprintf(g_dasm_str, "lsl.b   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_lsl_r_16(void)
{
    sprintf(g_dasm_str, "lsl.w   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_lsl_r_32(void)
{
    sprintf(g_dasm_str, "lsl.l   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_lsl_ea(void)
{
    sprintf(g_dasm_str, "lsl.w   %s", get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_move_8(void)
{
    char* str = get_ea_mode_str_8(g_cpu_ir);
    sprintf(g_dasm_str, "move.b  %s, %s", str, get_ea_mode_str_8(((g_cpu_ir >> 9) & 7) | ((g_cpu_ir >> 3) & 0x38)));
}

static void d68000_move_16(void)
{
    char* str = get_ea_mode_str_16(g_cpu_ir);
    sprintf(g_dasm_str, "move.w  %s, %s", str, get_ea_mode_str_16(((g_cpu_ir >> 9) & 7) | ((g_cpu_ir >> 3) & 0x38)));
}

static void d68000_move_32(void)
{
    char* str = get_ea_mode_str_32(g_cpu_ir);
    sprintf(g_dasm_str, "move.l  %s, %s", str, get_ea_mode_str_32(((g_cpu_ir >> 9) & 7) | ((g_cpu_ir >> 3) & 0x38)));
}

static void d68000_movea_16(void)
{
    sprintf(g_dasm_str, "movea.w %s, A%d", get_ea_mode_str_16(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_movea_32(void)
{
    sprintf(g_dasm_str, "movea.l %s, A%d", get_ea_mode_str_32(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_move_to_ccr(void)
{
    sprintf(g_dasm_str, "move    %s, CCR", get_ea_mode_str_8(g_cpu_ir));
}

static void d68010_move_fr_ccr(void)
{
    LIMIT_CPU_TYPES(M68010_PLUS);
    sprintf(g_dasm_str, "move    CCR, %s; (1+)", get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_move_fr_sr(void)
{
    sprintf(g_dasm_str, "move    SR, %s", get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_move_to_sr(void)
{
    sprintf(g_dasm_str, "move    %s, SR", get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_move_fr_usp(void)
{
    sprintf(g_dasm_str, "move    USP, A%d", g_cpu_ir & 7);
}

static void d68000_move_to_usp(void)
{
    sprintf(g_dasm_str, "move    A%d, USP", g_cpu_ir & 7);
}

static void d68010_movec(void)
{
    uint extension;
    const char* reg_name;
    const char* processor;
    LIMIT_CPU_TYPES(M68010_PLUS);
    extension = read_imm_16();

    switch (extension & 0xfff) {
        case 0x000:
            reg_name = "SFC";
            processor = "1+";
            break;
        case 0x001:
            reg_name = "DFC";
            processor = "1+";
            break;
        case 0x800:
            reg_name = "USP";
            processor = "1+";
            break;
        case 0x801:
            reg_name = "VBR";
            processor = "1+";
            break;
        case 0x002:
            reg_name = "CACR";
            processor = "2+";
            break;
        case 0x802:
            reg_name = "CAAR";
            processor = "2,3";
            break;
        case 0x803:
            reg_name = "MSP";
            processor = "2+";
            break;
        case 0x804:
            reg_name = "ISP";
            processor = "2+";
            break;
        case 0x003:
            reg_name = "TC";
            processor = "4+";
            break;
        case 0x004:
            reg_name = "ITT0";
            processor = "4+";
            break;
        case 0x005:
            reg_name = "ITT1";
            processor = "4+";
            break;
        case 0x006:
            reg_name = "DTT0";
            processor = "4+";
            break;
        case 0x007:
            reg_name = "DTT1";
            processor = "4+";
            break;
        case 0x805:
            reg_name = "MMUSR";
            processor = "4+";
            break;
        case 0x806:
            reg_name = "URP";
            processor = "4+";
            break;
        case 0x807:
            reg_name = "SRP";
            processor = "4+";
            break;
        default:
            reg_name = make_signed_hex_str_16(extension & 0xfff);
            processor = "?";
    }

    if (BIT_0(g_cpu_ir)) {
        sprintf(g_dasm_str, "movec %c%d, %s; (%s)", BIT_F(extension) ? 'A' : 'D', (extension >> 12) & 7, reg_name, processor);
    } else {
        sprintf(g_dasm_str, "movec %s, %c%d; (%s)", reg_name, BIT_F(extension) ? 'A' : 'D', (extension >> 12) & 7, processor);
    }
}

static void d68000_movem_pd_16(void)
{
    uint data = read_imm_16();
    char buffer[40];
    uint first;
    uint run_length;
    uint i;

    buffer[0] = 0;
    for (i = 0; i < 8; i++) {
        if (data & (1 << (15 - i))) {
            first = i;
            run_length = 0;
            while (i < 7 && (data & (1 << (15 - (i + 1))))) {
                i++;
                run_length++;
            }
            if (buffer[0] != 0) {
                strcat(buffer, "/");
            }
            sprintf(buffer + strlen(buffer), "D%d", first);
            if (run_length > 0) {
                sprintf(buffer + strlen(buffer), "-D%d", first + run_length);
            }
        }
    }
    for (i = 0; i < 8; i++) {
        if (data & (1 << (7 - i))) {
            first = i;
            run_length = 0;
            while (i < 7 && (data & (1 << (7 - (i + 1))))) {
                i++;
                run_length++;
            }
            if (buffer[0] != 0) {
                strcat(buffer, "/");
            }
            sprintf(buffer + strlen(buffer), "A%d", first);
            if (run_length > 0) {
                sprintf(buffer + strlen(buffer), "-A%d", first + run_length);
            }
        }
    }
    sprintf(g_dasm_str, "movem.w %s, %s", buffer, get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_movem_pd_32(void)
{
    uint data = read_imm_16();
    char buffer[40];
    uint first;
    uint run_length;
    uint i;

    buffer[0] = 0;
    for (i = 0; i < 8; i++) {
        if (data & (1 << (15 - i))) {
            first = i;
            run_length = 0;
            while (i < 7 && (data & (1 << (15 - (i + 1))))) {
                i++;
                run_length++;
            }
            if (buffer[0] != 0) {
                strcat(buffer, "/");
            }
            sprintf(buffer + strlen(buffer), "D%d", first);
            if (run_length > 0) {
                sprintf(buffer + strlen(buffer), "-D%d", first + run_length);
            }
        }
    }
    for (i = 0; i < 8; i++) {
        if (data & (1 << (7 - i))) {
            first = i;
            run_length = 0;
            while (i < 7 && (data & (1 << (7 - (i + 1))))) {
                i++;
                run_length++;
            }
            if (buffer[0] != 0) {
                strcat(buffer, "/");
            }
            sprintf(buffer + strlen(buffer), "A%d", first);
            if (run_length > 0) {
                sprintf(buffer + strlen(buffer), "-A%d", first + run_length);
            }
        }
    }
    sprintf(g_dasm_str, "movem.l %s, %s", buffer, get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_movem_er_16(void)
{
    uint data = read_imm_16();
    char buffer[40];
    uint first;
    uint run_length;
    uint i;

    buffer[0] = 0;
    for (i = 0; i < 8; i++) {
        if (data & (1 << i)) {
            first = i;
            run_length = 0;
            while (i < 7 && (data & (1 << (i + 1)))) {
                i++;
                run_length++;
            }
            if (buffer[0] != 0) {
                strcat(buffer, "/");
            }
            sprintf(buffer + strlen(buffer), "D%d", first);
            if (run_length > 0) {
                sprintf(buffer + strlen(buffer), "-D%d", first + run_length);
            }
        }
    }
    for (i = 0; i < 8; i++) {
        if (data & (1 << (i + 8))) {
            first = i;
            run_length = 0;
            while (i < 7 && (data & (1 << (i + 8 + 1)))) {
                i++;
                run_length++;
            }
            if (buffer[0] != 0) {
                strcat(buffer, "/");
            }
            sprintf(buffer + strlen(buffer), "A%d", first);
            if (run_length > 0) {
                sprintf(buffer + strlen(buffer), "-A%d", first + run_length);
            }
        }
    }
    sprintf(g_dasm_str, "movem.w %s, %s", get_ea_mode_str_16(g_cpu_ir), buffer);
}

static void d68000_movem_er_32(void)
{
    uint data = read_imm_16();
    char buffer[40];
    uint first;
    uint run_length;
    uint i;

    buffer[0] = 0;
    for (i = 0; i < 8; i++) {
        if (data & (1 << i)) {
            first = i;
            run_length = 0;
            while (i < 7 && (data & (1 << (i + 1)))) {
                i++;
                run_length++;
            }
            if (buffer[0] != 0) {
                strcat(buffer, "/");
            }
            sprintf(buffer + strlen(buffer), "D%d", first);
            if (run_length > 0) {
                sprintf(buffer + strlen(buffer), "-D%d", first + run_length);
            }
        }
    }
    for (i = 0; i < 8; i++) {
        if (data & (1 << (i + 8))) {
            first = i;
            run_length = 0;
            while (i < 7 && (data & (1 << (i + 8 + 1)))) {
                i++;
                run_length++;
            }
            if (buffer[0] != 0) {
                strcat(buffer, "/");
            }
            sprintf(buffer + strlen(buffer), "A%d", first);
            if (run_length > 0) {
                sprintf(buffer + strlen(buffer), "-A%d", first + run_length);
            }
        }
    }
    sprintf(g_dasm_str, "movem.l %s, %s", get_ea_mode_str_32(g_cpu_ir), buffer);
}

static void d68000_movem_re_16(void)
{
    uint data = read_imm_16();
    char buffer[40];
    uint first;
    uint run_length;
    uint i;

    buffer[0] = 0;
    for (i = 0; i < 8; i++) {
        if (data & (1 << i)) {
            first = i;
            run_length = 0;
            while (i < 7 && (data & (1 << (i + 1)))) {
                i++;
                run_length++;
            }
            if (buffer[0] != 0) {
                strcat(buffer, "/");
            }
            sprintf(buffer + strlen(buffer), "D%d", first);
            if (run_length > 0) {
                sprintf(buffer + strlen(buffer), "-D%d", first + run_length);
            }
        }
    }
    for (i = 0; i < 8; i++) {
        if (data & (1 << (i + 8))) {
            first = i;
            run_length = 0;
            while (i < 7 && (data & (1 << (i + 8 + 1)))) {
                i++;
                run_length++;
            }
            if (buffer[0] != 0) {
                strcat(buffer, "/");
            }
            sprintf(buffer + strlen(buffer), "A%d", first);
            if (run_length > 0) {
                sprintf(buffer + strlen(buffer), "-A%d", first + run_length);
            }
        }
    }
    sprintf(g_dasm_str, "movem.w %s, %s", buffer, get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_movem_re_32(void)
{
    uint data = read_imm_16();
    char buffer[40];
    uint first;
    uint run_length;
    uint i;

    buffer[0] = 0;
    for (i = 0; i < 8; i++) {
        if (data & (1 << i)) {
            first = i;
            run_length = 0;
            while (i < 7 && (data & (1 << (i + 1)))) {
                i++;
                run_length++;
            }
            if (buffer[0] != 0) {
                strcat(buffer, "/");
            }
            sprintf(buffer + strlen(buffer), "D%d", first);
            if (run_length > 0) {
                sprintf(buffer + strlen(buffer), "-D%d", first + run_length);
            }
        }
    }
    for (i = 0; i < 8; i++) {
        if (data & (1 << (i + 8))) {
            first = i;
            run_length = 0;
            while (i < 7 && (data & (1 << (i + 8 + 1)))) {
                i++;
                run_length++;
            }
            if (buffer[0] != 0) {
                strcat(buffer, "/");
            }
            sprintf(buffer + strlen(buffer), "A%d", first);
            if (run_length > 0) {
                sprintf(buffer + strlen(buffer), "-A%d", first + run_length);
            }
        }
    }
    sprintf(g_dasm_str, "movem.l %s, %s", buffer, get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_movep_re_16(void)
{
    sprintf(g_dasm_str, "movep.w D%d, ($%x,A%d)", (g_cpu_ir >> 9) & 7, read_imm_16(), g_cpu_ir & 7);
}

static void d68000_movep_re_32(void)
{
    sprintf(g_dasm_str, "movep.l D%d, ($%x,A%d)", (g_cpu_ir >> 9) & 7, read_imm_16(), g_cpu_ir & 7);
}

static void d68000_movep_er_16(void)
{
    sprintf(g_dasm_str, "movep.w ($%x,A%d), D%d", read_imm_16(), g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_movep_er_32(void)
{
    sprintf(g_dasm_str, "movep.l ($%x,A%d), D%d", read_imm_16(), g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68010_moves_8(void)
{
    uint extension;
    LIMIT_CPU_TYPES(M68010_PLUS);
    extension = read_imm_16();
    if (BIT_B(extension)) {
        sprintf(g_dasm_str, "moves.b %c%d, %s; (1+)", BIT_F(extension) ? 'A' : 'D', (extension >> 12) & 7, get_ea_mode_str_8(g_cpu_ir));
    } else {
        sprintf(g_dasm_str, "moves.b %s, %c%d; (1+)", get_ea_mode_str_8(g_cpu_ir), BIT_F(extension) ? 'A' : 'D', (extension >> 12) & 7);
    }
}

static void d68010_moves_16(void)
{
    uint extension;
    LIMIT_CPU_TYPES(M68010_PLUS);
    extension = read_imm_16();
    if (BIT_B(extension)) {
        sprintf(g_dasm_str, "moves.w %c%d, %s; (1+)", BIT_F(extension) ? 'A' : 'D', (extension >> 12) & 7, get_ea_mode_str_16(g_cpu_ir));
    } else {
        sprintf(g_dasm_str, "moves.w %s, %c%d; (1+)", get_ea_mode_str_16(g_cpu_ir), BIT_F(extension) ? 'A' : 'D', (extension >> 12) & 7);
    }
}

static void d68010_moves_32(void)
{
    uint extension;
    LIMIT_CPU_TYPES(M68010_PLUS);
    extension = read_imm_16();
    if (BIT_B(extension)) {
        sprintf(g_dasm_str, "moves.l %c%d, %s; (1+)", BIT_F(extension) ? 'A' : 'D', (extension >> 12) & 7, get_ea_mode_str_32(g_cpu_ir));
    } else {
        sprintf(g_dasm_str, "moves.l %s, %c%d; (1+)", get_ea_mode_str_32(g_cpu_ir), BIT_F(extension) ? 'A' : 'D', (extension >> 12) & 7);
    }
}

static void d68000_moveq(void)
{
    sprintf(g_dasm_str, "moveq   #%s, D%d", make_signed_hex_str_8(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68040_move16_pi_pi(void)
{
    LIMIT_CPU_TYPES(M68040_PLUS);
    sprintf(g_dasm_str, "move16  (A%d)+, (A%d)+; (4)", g_cpu_ir & 7, (read_imm_16() >> 12) & 7);
}

static void d68040_move16_pi_al(void)
{
    LIMIT_CPU_TYPES(M68040_PLUS);
    sprintf(g_dasm_str, "move16  (A%d)+, %s; (4)", g_cpu_ir & 7, get_imm_str_u32());
}

static void d68040_move16_al_pi(void)
{
    LIMIT_CPU_TYPES(M68040_PLUS);
    sprintf(g_dasm_str, "move16  %s, (A%d)+; (4)", get_imm_str_u32(), g_cpu_ir & 7);
}

static void d68040_move16_ai_al(void)
{
    LIMIT_CPU_TYPES(M68040_PLUS);
    sprintf(g_dasm_str, "move16  (A%d), %s; (4)", g_cpu_ir & 7, get_imm_str_u32());
}

static void d68040_move16_al_ai(void)
{
    LIMIT_CPU_TYPES(M68040_PLUS);
    sprintf(g_dasm_str, "move16  %s, (A%d); (4)", get_imm_str_u32(), g_cpu_ir & 7);
}

static void d68000_muls(void)
{
    sprintf(g_dasm_str, "muls.w  %s, D%d", get_ea_mode_str_16(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_mulu(void)
{
    sprintf(g_dasm_str, "mulu.w  %s, D%d", get_ea_mode_str_16(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68020_mull(void)
{
    uint extension;
    LIMIT_CPU_TYPES(M68020_PLUS);
    extension = read_imm_16();

    if (BIT_A(extension)) {
        sprintf(g_dasm_str, "mul%c.l %s, D%d:D%d; (2+)", BIT_B(extension) ? 's' : 'u', get_ea_mode_str_32(g_cpu_ir), extension & 7, (extension >> 12) & 7);
    } else {
        sprintf(g_dasm_str, "mul%c.l  %s, D%d; (2+)", BIT_B(extension) ? 's' : 'u', get_ea_mode_str_32(g_cpu_ir), (extension >> 12) & 7);
    }
}

static void d68000_nbcd(void)
{
    sprintf(g_dasm_str, "nbcd    %s", get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_neg_8(void)
{
    sprintf(g_dasm_str, "neg.b   %s", get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_neg_16(void)
{
    sprintf(g_dasm_str, "neg.w   %s", get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_neg_32(void)
{
    sprintf(g_dasm_str, "neg.l   %s", get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_negx_8(void)
{
    sprintf(g_dasm_str, "negx.b  %s", get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_negx_16(void)
{
    sprintf(g_dasm_str, "negx.w  %s", get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_negx_32(void)
{
    sprintf(g_dasm_str, "negx.l  %s", get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_nop(void)
{
    sprintf(g_dasm_str, "nop");
}

static void d68000_not_8(void)
{
    sprintf(g_dasm_str, "not.b   %s", get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_not_16(void)
{
    sprintf(g_dasm_str, "not.w   %s", get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_not_32(void)
{
    sprintf(g_dasm_str, "not.l   %s", get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_or_er_8(void)
{
    sprintf(g_dasm_str, "or.b    %s, D%d", get_ea_mode_str_8(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_or_er_16(void)
{
    sprintf(g_dasm_str, "or.w    %s, D%d", get_ea_mode_str_16(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_or_er_32(void)
{
    sprintf(g_dasm_str, "or.l    %s, D%d", get_ea_mode_str_32(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_or_re_8(void)
{
    sprintf(g_dasm_str, "or.b    D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_or_re_16(void)
{
    sprintf(g_dasm_str, "or.w    D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_or_re_32(void)
{
    sprintf(g_dasm_str, "or.l    D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_ori_8(void)
{
    char* str = get_imm_str_u8();
    sprintf(g_dasm_str, "ori.b   %s, %s", str, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_ori_16(void)
{
    char* str = get_imm_str_u16();
    sprintf(g_dasm_str, "ori.w   %s, %s", str, get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_ori_32(void)
{
    char* str = get_imm_str_u32();
    sprintf(g_dasm_str, "ori.l   %s, %s", str, get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_ori_to_ccr(void)
{
    sprintf(g_dasm_str, "ori     %s, CCR", get_imm_str_u8());
}

static void d68000_ori_to_sr(void)
{
    sprintf(g_dasm_str, "ori     %s, SR", get_imm_str_u16());
}

static void d68020_pack_rr(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "pack    D%d, D%d, %s; (2+)", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7, get_imm_str_u16());
}

static void d68020_pack_mm(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "pack    -(A%d), -(A%d), %s; (2+)", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7, get_imm_str_u16());
}

static void d68000_pea(void)
{
    sprintf(g_dasm_str, "pea     %s", get_ea_mode_str_32(g_cpu_ir));
}

// this is a 68040-specific form of PFLUSH
static void d68040_pflush(void)
{
    LIMIT_CPU_TYPES(M68040_PLUS);

    if (g_cpu_ir & 0x10) {
        sprintf(g_dasm_str, "pflusha%s", (g_cpu_ir & 8) ? "" : "n");
    } else {
        sprintf(g_dasm_str, "pflush%s(A%d)", (g_cpu_ir & 8) ? "" : "n", g_cpu_ir & 7);
    }
}

static void d68000_reset(void)
{
    sprintf(g_dasm_str, "reset");
}

static void d68000_ror_s_8(void)
{
    sprintf(g_dasm_str, "ror.b   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_ror_s_16(void)
{
    sprintf(g_dasm_str, "ror.w   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_ror_s_32(void)
{
    sprintf(g_dasm_str, "ror.l   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_ror_r_8(void)
{
    sprintf(g_dasm_str, "ror.b   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_ror_r_16(void)
{
    sprintf(g_dasm_str, "ror.w   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_ror_r_32(void)
{
    sprintf(g_dasm_str, "ror.l   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_ror_ea(void)
{
    sprintf(g_dasm_str, "ror.w   %s", get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_rol_s_8(void)
{
    sprintf(g_dasm_str, "rol.b   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_rol_s_16(void)
{
    sprintf(g_dasm_str, "rol.w   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_rol_s_32(void)
{
    sprintf(g_dasm_str, "rol.l   #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_rol_r_8(void)
{
    sprintf(g_dasm_str, "rol.b   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_rol_r_16(void)
{
    sprintf(g_dasm_str, "rol.w   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_rol_r_32(void)
{
    sprintf(g_dasm_str, "rol.l   D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_rol_ea(void)
{
    sprintf(g_dasm_str, "rol.w   %s", get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_roxr_s_8(void)
{
    sprintf(g_dasm_str, "roxr.b  #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_roxr_s_16(void)
{
    sprintf(g_dasm_str, "roxr.w  #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_roxr_s_32(void)
{
    sprintf(g_dasm_str, "roxr.l  #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_roxr_r_8(void)
{
    sprintf(g_dasm_str, "roxr.b  D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_roxr_r_16(void)
{
    sprintf(g_dasm_str, "roxr.w  D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_roxr_r_32(void)
{
    sprintf(g_dasm_str, "roxr.l  D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_roxr_ea(void)
{
    sprintf(g_dasm_str, "roxr.w  %s", get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_roxl_s_8(void)
{
    sprintf(g_dasm_str, "roxl.b  #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_roxl_s_16(void)
{
    sprintf(g_dasm_str, "roxl.w  #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_roxl_s_32(void)
{
    sprintf(g_dasm_str, "roxl.l  #%d, D%d", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], g_cpu_ir & 7);
}

static void d68000_roxl_r_8(void)
{
    sprintf(g_dasm_str, "roxl.b  D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_roxl_r_16(void)
{
    sprintf(g_dasm_str, "roxl.w  D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_roxl_r_32(void)
{
    sprintf(g_dasm_str, "roxl.l  D%d, D%d", (g_cpu_ir >> 9) & 7, g_cpu_ir & 7);
}

static void d68000_roxl_ea(void)
{
    sprintf(g_dasm_str, "roxl.w  %s", get_ea_mode_str_32(g_cpu_ir));
}

static void d68010_rtd(void)
{
    LIMIT_CPU_TYPES(M68010_PLUS);
    sprintf(g_dasm_str, "rtd     %s; (1+)", get_imm_str_s16());
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OUT);
}

static void d68000_rte(void)
{
    sprintf(g_dasm_str, "rte");
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OUT);
}

static void d68020_rtm(void)
{
    LIMIT_CPU_TYPES(M68020_ONLY);
    sprintf(g_dasm_str, "rtm     %c%d; (2+)", BIT_3(g_cpu_ir) ? 'A' : 'D', g_cpu_ir & 7);
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OUT);
}

static void d68000_rtr(void)
{
    sprintf(g_dasm_str, "rtr");
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OUT);
}

static void d68000_rts(void)
{
    sprintf(g_dasm_str, "rts");
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OUT);
}

static void d68000_sbcd_rr(void)
{
    sprintf(g_dasm_str, "sbcd    D%d, D%d", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_sbcd_mm(void)
{
    sprintf(g_dasm_str, "sbcd    -(A%d), -(A%d)", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_scc(void)
{
    sprintf(g_dasm_str, "s%-2s     %s", g_cc[(g_cpu_ir >> 8) & 0xf], get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_stop(void)
{
    sprintf(g_dasm_str, "stop    %s", get_imm_str_s16());
}

static void d68000_sub_er_8(void)
{
    sprintf(g_dasm_str, "sub.b   %s, D%d", get_ea_mode_str_8(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_sub_er_16(void)
{
    sprintf(g_dasm_str, "sub.w   %s, D%d", get_ea_mode_str_16(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_sub_er_32(void)
{
    sprintf(g_dasm_str, "sub.l   %s, D%d", get_ea_mode_str_32(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_sub_re_8(void)
{
    sprintf(g_dasm_str, "sub.b   D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_sub_re_16(void)
{
    sprintf(g_dasm_str, "sub.w   D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_sub_re_32(void)
{
    sprintf(g_dasm_str, "sub.l   D%d, %s", (g_cpu_ir >> 9) & 7, get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_suba_16(void)
{
    sprintf(g_dasm_str, "suba.w  %s, A%d", get_ea_mode_str_16(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_suba_32(void)
{
    sprintf(g_dasm_str, "suba.l  %s, A%d", get_ea_mode_str_32(g_cpu_ir), (g_cpu_ir >> 9) & 7);
}

static void d68000_subi_8(void)
{
    char* str = get_imm_str_s8();
    sprintf(g_dasm_str, "subi.b  %s, %s", str, get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_subi_16(void)
{
    char* str = get_imm_str_s16();
    sprintf(g_dasm_str, "subi.w  %s, %s", str, get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_subi_32(void)
{
    char* str = get_imm_str_s32();
    sprintf(g_dasm_str, "subi.l  %s, %s", str, get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_subq_8(void)
{
    sprintf(g_dasm_str, "subq.b  #%d, %s", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_subq_16(void)
{
    sprintf(g_dasm_str, "subq.w  #%d, %s", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_subq_32(void)
{
    sprintf(g_dasm_str, "subq.l  #%d, %s", g_3bit_qdata_table[(g_cpu_ir >> 9) & 7], get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_subx_rr_8(void)
{
    sprintf(g_dasm_str, "subx.b  D%d, D%d", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_subx_rr_16(void)
{
    sprintf(g_dasm_str, "subx.w  D%d, D%d", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_subx_rr_32(void)
{
    sprintf(g_dasm_str, "subx.l  D%d, D%d", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_subx_mm_8(void)
{
    sprintf(g_dasm_str, "subx.b  -(A%d), -(A%d)", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_subx_mm_16(void)
{
    sprintf(g_dasm_str, "subx.w  -(A%d), -(A%d)", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_subx_mm_32(void)
{
    sprintf(g_dasm_str, "subx.l  -(A%d), -(A%d)", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7);
}

static void d68000_swap(void)
{
    sprintf(g_dasm_str, "swap    D%d", g_cpu_ir & 7);
}

static void d68000_tas(void)
{
    sprintf(g_dasm_str, "tas     %s", get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_trap(void)
{
    sprintf(g_dasm_str, "trap    #$%x", g_cpu_ir & 0xf);
}

static void d68020_trapcc_0(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "trap%-2s; (2+)", g_cc[(g_cpu_ir >> 8) & 0xf]);
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OVER);
}

static void d68020_trapcc_16(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "trap%-2s  %s; (2+)", g_cc[(g_cpu_ir >> 8) & 0xf], get_imm_str_u16());
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OVER);
}

static void d68020_trapcc_32(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "trap%-2s  %s; (2+)", g_cc[(g_cpu_ir >> 8) & 0xf], get_imm_str_u32());
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OVER);
}

static void d68000_trapv(void)
{
    sprintf(g_dasm_str, "trapv");
    SET_OPCODE_FLAGS(DASMFLAG_STEP_OVER);
}

static void d68000_tst_8(void)
{
    sprintf(g_dasm_str, "tst.b   %s", get_ea_mode_str_8(g_cpu_ir));
}

static void d68020_tst_pcdi_8(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "tst.b   %s; (2+)", get_ea_mode_str_8(g_cpu_ir));
}

static void d68020_tst_pcix_8(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "tst.b   %s; (2+)", get_ea_mode_str_8(g_cpu_ir));
}

static void d68020_tst_i_8(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "tst.b   %s; (2+)", get_ea_mode_str_8(g_cpu_ir));
}

static void d68000_tst_16(void)
{
    sprintf(g_dasm_str, "tst.w   %s", get_ea_mode_str_16(g_cpu_ir));
}

static void d68020_tst_a_16(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "tst.w   %s; (2+)", get_ea_mode_str_16(g_cpu_ir));
}

static void d68020_tst_pcdi_16(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "tst.w   %s; (2+)", get_ea_mode_str_16(g_cpu_ir));
}

static void d68020_tst_pcix_16(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "tst.w   %s; (2+)", get_ea_mode_str_16(g_cpu_ir));
}

static void d68020_tst_i_16(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "tst.w   %s; (2+)", get_ea_mode_str_16(g_cpu_ir));
}

static void d68000_tst_32(void)
{
    sprintf(g_dasm_str, "tst.l   %s", get_ea_mode_str_32(g_cpu_ir));
}

static void d68020_tst_a_32(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "tst.l   %s; (2+)", get_ea_mode_str_32(g_cpu_ir));
}

static void d68020_tst_pcdi_32(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "tst.l   %s; (2+)", get_ea_mode_str_32(g_cpu_ir));
}

static void d68020_tst_pcix_32(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "tst.l   %s; (2+)", get_ea_mode_str_32(g_cpu_ir));
}

static void d68020_tst_i_32(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "tst.l   %s; (2+)", get_ea_mode_str_32(g_cpu_ir));
}

static void d68000_unlk(void)
{
    sprintf(g_dasm_str, "unlk    A%d", g_cpu_ir & 7);
}

static void d68020_unpk_rr(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "unpk    D%d, D%d, %s; (2+)", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7, get_imm_str_u16());
}

static void d68020_unpk_mm(void)
{
    LIMIT_CPU_TYPES(M68020_PLUS);
    sprintf(g_dasm_str, "unpk    -(A%d), -(A%d), %s; (2+)", g_cpu_ir & 7, (g_cpu_ir >> 9) & 7, get_imm_str_u16());
}

// PFLUSH:  001xxx0xxxxxxxxx
// PLOAD:   001000x0000xxxxx
// PVALID1: 0010100000000000
// PVALID2: 0010110000000xxx
// PMOVE 1: 010xxxx000000000
// PMOVE 2: 011xxxx0000xxx00
// PMOVE 3: 011xxxx000000000
// PTEST:   100xxxxxxxxxxxxx
// PFLUSHR:  1010000000000000
static void d68851_p000(void)
{
    char* str;
    uint modes = read_imm_16();

    // do this after fetching the second PMOVE word so we properly get the 3rd if necessary
    str = get_ea_mode_str_32(g_cpu_ir);

    if ((modes & 0xfde0) == 0x2000) // PLOAD
    {
        if (modes & 0x0200) {
            sprintf(g_dasm_str, "pload  #%d, %s", (modes >> 10) & 7, str);
        } else {
            sprintf(g_dasm_str, "pload  %s, #%d", str, (modes >> 10) & 7);
        }
        return;
    }

    if ((modes & 0xe200) == 0x2000) // PFLUSH
    {
        sprintf(g_dasm_str, "pflushr %x, %x, %s", modes & 0x1f, (modes >> 5) & 0xf, str);
        return;
    }

    if (modes == 0xa000) // PFLUSHR
    {
        sprintf(g_dasm_str, "pflushr %s", str);
    }

    if (modes == 0x2800) // PVALID (FORMAT 1)
    {
        sprintf(g_dasm_str, "pvalid VAL, %s", str);
        return;
    }

    if ((modes & 0xfff8) == 0x2c00) // PVALID (FORMAT 2)
    {
        sprintf(g_dasm_str, "pvalid A%d, %s", modes & 0xf, str);
        return;
    }

    if ((modes & 0xe000) == 0x8000) // PTEST
    {
        sprintf(g_dasm_str, "ptest #%d, %s", modes & 0x1f, str);
        return;
    }

    switch ((modes >> 13) & 0x7) {
        case 0: // MC68030/040 form with FD bit
        case 2: // MC68881 form, FD never set
            if (modes & 0x0100) {
                if (modes & 0x0200) {
                    sprintf(g_dasm_str, "pmovefd  %s, %s", g_mmuregs[(modes >> 10) & 7], str);
                } else {
                    sprintf(g_dasm_str, "pmovefd  %s, %s", str, g_mmuregs[(modes >> 10) & 7]);
                }
            } else {
                if (modes & 0x0200) {
                    sprintf(g_dasm_str, "pmove  %s, %s", g_mmuregs[(modes >> 10) & 7], str);
                } else {
                    sprintf(g_dasm_str, "pmove  %s, %s", str, g_mmuregs[(modes >> 10) & 7]);
                }
            }
            break;

        case 3: // MC68030 to/from status reg
            if (modes & 0x0200) {
                sprintf(g_dasm_str, "pmove  mmusr, %s", str);
            } else {
                sprintf(g_dasm_str, "pmove  %s, mmusr", str);
            }
            break;

        default:
            sprintf(g_dasm_str, "pmove [unknown form] %s", str);
            break;
    }
}

static void d68851_pbcc16(void)
{
    uint32 temp_pc = g_cpu_pc;

    sprintf(g_dasm_str, "pb%s %x", g_mmucond[g_cpu_ir & 0xf], temp_pc + make_int_16(read_imm_16()));
}

static void d68851_pbcc32(void)
{
    uint32 temp_pc = g_cpu_pc;

    sprintf(g_dasm_str, "pb%s %x", g_mmucond[g_cpu_ir & 0xf], temp_pc + make_int_32(read_imm_32()));
}

static void d68851_pdbcc(void)
{
    uint32 temp_pc = g_cpu_pc;
    uint16 modes = read_imm_16();

    sprintf(g_dasm_str, "pb%s %x", g_mmucond[modes & 0xf], temp_pc + make_int_16(read_imm_16()));
}

// PScc:  0000000000xxxxxx
static void d68851_p001(void)
{
    sprintf(g_dasm_str, "MMU 001 group");
}

/* ======================================================================== */
/* ======================= INSTRUCTION TABLE BUILDER ====================== */
/* ======================================================================== */

/* EA Masks:
800 = data register direct
400 = address register direct
200 = address register indirect
100 = ARI postincrement
 80 = ARI pre-decrement
 40 = ARI displacement
 20 = ARI index
 10 = absolute short
  8 = absolute long
  4 = immediate / sr
  2 = pc displacement
  1 = pc idx
*/

static const opcode_struct g_opcode_info[] =
    {
        /*  opcode handler             mask    match   ea mask */
        {d68000_1010, 0xf000, 0xa000, 0x000},
        {d68000_1111, 0xf000, 0xf000, 0x000},
        {d68000_abcd_rr, 0xf1f8, 0xc100, 0x000},
        {d68000_abcd_mm, 0xf1f8, 0xc108, 0x000},
        {d68000_add_er_8, 0xf1c0, 0xd000, 0xbff},
        {d68000_add_er_16, 0xf1c0, 0xd040, 0xfff},
        {d68000_add_er_32, 0xf1c0, 0xd080, 0xfff},
        {d68000_add_re_8, 0xf1c0, 0xd100, 0x3f8},
        {d68000_add_re_16, 0xf1c0, 0xd140, 0x3f8},
        {d68000_add_re_32, 0xf1c0, 0xd180, 0x3f8},
        {d68000_adda_16, 0xf1c0, 0xd0c0, 0xfff},
        {d68000_adda_32, 0xf1c0, 0xd1c0, 0xfff},
        {d68000_addi_8, 0xffc0, 0x0600, 0xbf8},
        {d68000_addi_16, 0xffc0, 0x0640, 0xbf8},
        {d68000_addi_32, 0xffc0, 0x0680, 0xbf8},
        {d68000_addq_8, 0xf1c0, 0x5000, 0xbf8},
        {d68000_addq_16, 0xf1c0, 0x5040, 0xff8},
        {d68000_addq_32, 0xf1c0, 0x5080, 0xff8},
        {d68000_addx_rr_8, 0xf1f8, 0xd100, 0x000},
        {d68000_addx_rr_16, 0xf1f8, 0xd140, 0x000},
        {d68000_addx_rr_32, 0xf1f8, 0xd180, 0x000},
        {d68000_addx_mm_8, 0xf1f8, 0xd108, 0x000},
        {d68000_addx_mm_16, 0xf1f8, 0xd148, 0x000},
        {d68000_addx_mm_32, 0xf1f8, 0xd188, 0x000},
        {d68000_and_er_8, 0xf1c0, 0xc000, 0xbff},
        {d68000_and_er_16, 0xf1c0, 0xc040, 0xbff},
        {d68000_and_er_32, 0xf1c0, 0xc080, 0xbff},
        {d68000_and_re_8, 0xf1c0, 0xc100, 0x3f8},
        {d68000_and_re_16, 0xf1c0, 0xc140, 0x3f8},
        {d68000_and_re_32, 0xf1c0, 0xc180, 0x3f8},
        {d68000_andi_to_ccr, 0xffff, 0x023c, 0x000},
        {d68000_andi_to_sr, 0xffff, 0x027c, 0x000},
        {d68000_andi_8, 0xffc0, 0x0200, 0xbf8},
        {d68000_andi_16, 0xffc0, 0x0240, 0xbf8},
        {d68000_andi_32, 0xffc0, 0x0280, 0xbf8},
        {d68000_asr_s_8, 0xf1f8, 0xe000, 0x000},
        {d68000_asr_s_16, 0xf1f8, 0xe040, 0x000},
        {d68000_asr_s_32, 0xf1f8, 0xe080, 0x000},
        {d68000_asr_r_8, 0xf1f8, 0xe020, 0x000},
        {d68000_asr_r_16, 0xf1f8, 0xe060, 0x000},
        {d68000_asr_r_32, 0xf1f8, 0xe0a0, 0x000},
        {d68000_asr_ea, 0xffc0, 0xe0c0, 0x3f8},
        {d68000_asl_s_8, 0xf1f8, 0xe100, 0x000},
        {d68000_asl_s_16, 0xf1f8, 0xe140, 0x000},
        {d68000_asl_s_32, 0xf1f8, 0xe180, 0x000},
        {d68000_asl_r_8, 0xf1f8, 0xe120, 0x000},
        {d68000_asl_r_16, 0xf1f8, 0xe160, 0x000},
        {d68000_asl_r_32, 0xf1f8, 0xe1a0, 0x000},
        {d68000_asl_ea, 0xffc0, 0xe1c0, 0x3f8},
        {d68000_bcc_8, 0xf000, 0x6000, 0x000},
        {d68000_bcc_16, 0xf0ff, 0x6000, 0x000},
        {d68020_bcc_32, 0xf0ff, 0x60ff, 0x000},
        {d68000_bchg_r, 0xf1c0, 0x0140, 0xbf8},
        {d68000_bchg_s, 0xffc0, 0x0840, 0xbf8},
        {d68000_bclr_r, 0xf1c0, 0x0180, 0xbf8},
        {d68000_bclr_s, 0xffc0, 0x0880, 0xbf8},
        {d68020_bfchg, 0xffc0, 0xeac0, 0xa78},
        {d68020_bfclr, 0xffc0, 0xecc0, 0xa78},
        {d68020_bfexts, 0xffc0, 0xebc0, 0xa7b},
        {d68020_bfextu, 0xffc0, 0xe9c0, 0xa7b},
        {d68020_bfffo, 0xffc0, 0xedc0, 0xa7b},
        {d68020_bfins, 0xffc0, 0xefc0, 0xa78},
        {d68020_bfset, 0xffc0, 0xeec0, 0xa78},
        {d68020_bftst, 0xffc0, 0xe8c0, 0xa7b},
        {d68010_bkpt, 0xfff8, 0x4848, 0x000},
        {d68000_bra_8, 0xff00, 0x6000, 0x000},
        {d68000_bra_16, 0xffff, 0x6000, 0x000},
        {d68020_bra_32, 0xffff, 0x60ff, 0x000},
        {d68000_bset_r, 0xf1c0, 0x01c0, 0xbf8},
        {d68000_bset_s, 0xffc0, 0x08c0, 0xbf8},
        {d68000_bsr_8, 0xff00, 0x6100, 0x000},
        {d68000_bsr_16, 0xffff, 0x6100, 0x000},
        {d68020_bsr_32, 0xffff, 0x61ff, 0x000},
        {d68000_btst_r, 0xf1c0, 0x0100, 0xbff},
        {d68000_btst_s, 0xffc0, 0x0800, 0xbfb},
        {d68020_callm, 0xffc0, 0x06c0, 0x27b},
        {d68020_cas_8, 0xffc0, 0x0ac0, 0x3f8},
        {d68020_cas_16, 0xffc0, 0x0cc0, 0x3f8},
        {d68020_cas_32, 0xffc0, 0x0ec0, 0x3f8},
        {d68020_cas2_16, 0xffff, 0x0cfc, 0x000},
        {d68020_cas2_32, 0xffff, 0x0efc, 0x000},
        {d68000_chk_16, 0xf1c0, 0x4180, 0xbff},
        {d68020_chk_32, 0xf1c0, 0x4100, 0xbff},
        {d68020_chk2_cmp2_8, 0xffc0, 0x00c0, 0x27b},
        {d68020_chk2_cmp2_16, 0xffc0, 0x02c0, 0x27b},
        {d68020_chk2_cmp2_32, 0xffc0, 0x04c0, 0x27b},
        {d68040_cinv, 0xff20, 0xf400, 0x000},
        {d68000_clr_8, 0xffc0, 0x4200, 0xbf8},
        {d68000_clr_16, 0xffc0, 0x4240, 0xbf8},
        {d68000_clr_32, 0xffc0, 0x4280, 0xbf8},
        {d68000_cmp_8, 0xf1c0, 0xb000, 0xbff},
        {d68000_cmp_16, 0xf1c0, 0xb040, 0xfff},
        {d68000_cmp_32, 0xf1c0, 0xb080, 0xfff},
        {d68000_cmpa_16, 0xf1c0, 0xb0c0, 0xfff},
        {d68000_cmpa_32, 0xf1c0, 0xb1c0, 0xfff},
        {d68000_cmpi_8, 0xffc0, 0x0c00, 0xbf8},
        {d68020_cmpi_pcdi_8, 0xffff, 0x0c3a, 0x000},
        {d68020_cmpi_pcix_8, 0xffff, 0x0c3b, 0x000},
        {d68000_cmpi_16, 0xffc0, 0x0c40, 0xbf8},
        {d68020_cmpi_pcdi_16, 0xffff, 0x0c7a, 0x000},
        {d68020_cmpi_pcix_16, 0xffff, 0x0c7b, 0x000},
        {d68000_cmpi_32, 0xffc0, 0x0c80, 0xbf8},
        {d68020_cmpi_pcdi_32, 0xffff, 0x0cba, 0x000},
        {d68020_cmpi_pcix_32, 0xffff, 0x0cbb, 0x000},
        {d68000_cmpm_8, 0xf1f8, 0xb108, 0x000},
        {d68000_cmpm_16, 0xf1f8, 0xb148, 0x000},
        {d68000_cmpm_32, 0xf1f8, 0xb188, 0x000},
        {d68020_cpbcc_16, 0xf1c0, 0xf080, 0x000},
        {d68020_cpbcc_32, 0xf1c0, 0xf0c0, 0x000},
        {d68020_cpdbcc, 0xf1f8, 0xf048, 0x000},
        {d68020_cpgen, 0xf1c0, 0xf000, 0x000},
        {d68020_cprestore, 0xf1c0, 0xf140, 0x37f},
        {d68020_cpsave, 0xf1c0, 0xf100, 0x2f8},
        {d68020_cpscc, 0xf1c0, 0xf040, 0xbf8},
        {d68020_cptrapcc_0, 0xf1ff, 0xf07c, 0x000},
        {d68020_cptrapcc_16, 0xf1ff, 0xf07a, 0x000},
        {d68020_cptrapcc_32, 0xf1ff, 0xf07b, 0x000},
        {d68040_cpush, 0xff20, 0xf420, 0x000},
        {d68000_dbcc, 0xf0f8, 0x50c8, 0x000},
        {d68000_dbra, 0xfff8, 0x51c8, 0x000},
        {d68000_divs, 0xf1c0, 0x81c0, 0xbff},
        {d68000_divu, 0xf1c0, 0x80c0, 0xbff},
        {d68020_divl, 0xffc0, 0x4c40, 0xbff},
        {d68000_eor_8, 0xf1c0, 0xb100, 0xbf8},
        {d68000_eor_16, 0xf1c0, 0xb140, 0xbf8},
        {d68000_eor_32, 0xf1c0, 0xb180, 0xbf8},
        {d68000_eori_to_ccr, 0xffff, 0x0a3c, 0x000},
        {d68000_eori_to_sr, 0xffff, 0x0a7c, 0x000},
        {d68000_eori_8, 0xffc0, 0x0a00, 0xbf8},
        {d68000_eori_16, 0xffc0, 0x0a40, 0xbf8},
        {d68000_eori_32, 0xffc0, 0x0a80, 0xbf8},
        {d68000_exg_dd, 0xf1f8, 0xc140, 0x000},
        {d68000_exg_aa, 0xf1f8, 0xc148, 0x000},
        {d68000_exg_da, 0xf1f8, 0xc188, 0x000},
        {d68020_extb_32, 0xfff8, 0x49c0, 0x000},
        {d68000_ext_16, 0xfff8, 0x4880, 0x000},
        {d68000_ext_32, 0xfff8, 0x48c0, 0x000},
        {d68040_fpu, 0xffc0, 0xf200, 0x000},
        {d68000_illegal, 0xffff, 0x4afc, 0x000},
        {d68000_jmp, 0xffc0, 0x4ec0, 0x27b},
        {d68000_jsr, 0xffc0, 0x4e80, 0x27b},
        {d68000_lea, 0xf1c0, 0x41c0, 0x27b},
        {d68000_link_16, 0xfff8, 0x4e50, 0x000},
        {d68020_link_32, 0xfff8, 0x4808, 0x000},
        {d68000_lsr_s_8, 0xf1f8, 0xe008, 0x000},
        {d68000_lsr_s_16, 0xf1f8, 0xe048, 0x000},
        {d68000_lsr_s_32, 0xf1f8, 0xe088, 0x000},
        {d68000_lsr_r_8, 0xf1f8, 0xe028, 0x000},
        {d68000_lsr_r_16, 0xf1f8, 0xe068, 0x000},
        {d68000_lsr_r_32, 0xf1f8, 0xe0a8, 0x000},
        {d68000_lsr_ea, 0xffc0, 0xe2c0, 0x3f8},
        {d68000_lsl_s_8, 0xf1f8, 0xe108, 0x000},
        {d68000_lsl_s_16, 0xf1f8, 0xe148, 0x000},
        {d68000_lsl_s_32, 0xf1f8, 0xe188, 0x000},
        {d68000_lsl_r_8, 0xf1f8, 0xe128, 0x000},
        {d68000_lsl_r_16, 0xf1f8, 0xe168, 0x000},
        {d68000_lsl_r_32, 0xf1f8, 0xe1a8, 0x000},
        {d68000_lsl_ea, 0xffc0, 0xe3c0, 0x3f8},
        {d68000_move_8, 0xf000, 0x1000, 0xbff},
        {d68000_move_16, 0xf000, 0x3000, 0xfff},
        {d68000_move_32, 0xf000, 0x2000, 0xfff},
        {d68000_movea_16, 0xf1c0, 0x3040, 0xfff},
        {d68000_movea_32, 0xf1c0, 0x2040, 0xfff},
        {d68000_move_to_ccr, 0xffc0, 0x44c0, 0xbff},
        {d68010_move_fr_ccr, 0xffc0, 0x42c0, 0xbf8},
        {d68000_move_to_sr, 0xffc0, 0x46c0, 0xbff},
        {d68000_move_fr_sr, 0xffc0, 0x40c0, 0xbf8},
        {d68000_move_to_usp, 0xfff8, 0x4e60, 0x000},
        {d68000_move_fr_usp, 0xfff8, 0x4e68, 0x000},
        {d68010_movec, 0xfffe, 0x4e7a, 0x000},
        {d68000_movem_pd_16, 0xfff8, 0x48a0, 0x000},
        {d68000_movem_pd_32, 0xfff8, 0x48e0, 0x000},
        {d68000_movem_re_16, 0xffc0, 0x4880, 0x2f8},
        {d68000_movem_re_32, 0xffc0, 0x48c0, 0x2f8},
        {d68000_movem_er_16, 0xffc0, 0x4c80, 0x37b},
        {d68000_movem_er_32, 0xffc0, 0x4cc0, 0x37b},
        {d68000_movep_er_16, 0xf1f8, 0x0108, 0x000},
        {d68000_movep_er_32, 0xf1f8, 0x0148, 0x000},
        {d68000_movep_re_16, 0xf1f8, 0x0188, 0x000},
        {d68000_movep_re_32, 0xf1f8, 0x01c8, 0x000},
        {d68010_moves_8, 0xffc0, 0x0e00, 0x3f8},
        {d68010_moves_16, 0xffc0, 0x0e40, 0x3f8},
        {d68010_moves_32, 0xffc0, 0x0e80, 0x3f8},
        {d68000_moveq, 0xf100, 0x7000, 0x000},
        {d68040_move16_pi_pi, 0xfff8, 0xf620, 0x000},
        {d68040_move16_pi_al, 0xfff8, 0xf600, 0x000},
        {d68040_move16_al_pi, 0xfff8, 0xf608, 0x000},
        {d68040_move16_ai_al, 0xfff8, 0xf610, 0x000},
        {d68040_move16_al_ai, 0xfff8, 0xf618, 0x000},
        {d68000_muls, 0xf1c0, 0xc1c0, 0xbff},
        {d68000_mulu, 0xf1c0, 0xc0c0, 0xbff},
        {d68020_mull, 0xffc0, 0x4c00, 0xbff},
        {d68000_nbcd, 0xffc0, 0x4800, 0xbf8},
        {d68000_neg_8, 0xffc0, 0x4400, 0xbf8},
        {d68000_neg_16, 0xffc0, 0x4440, 0xbf8},
        {d68000_neg_32, 0xffc0, 0x4480, 0xbf8},
        {d68000_negx_8, 0xffc0, 0x4000, 0xbf8},
        {d68000_negx_16, 0xffc0, 0x4040, 0xbf8},
        {d68000_negx_32, 0xffc0, 0x4080, 0xbf8},
        {d68000_nop, 0xffff, 0x4e71, 0x000},
        {d68000_not_8, 0xffc0, 0x4600, 0xbf8},
        {d68000_not_16, 0xffc0, 0x4640, 0xbf8},
        {d68000_not_32, 0xffc0, 0x4680, 0xbf8},
        {d68000_or_er_8, 0xf1c0, 0x8000, 0xbff},
        {d68000_or_er_16, 0xf1c0, 0x8040, 0xbff},
        {d68000_or_er_32, 0xf1c0, 0x8080, 0xbff},
        {d68000_or_re_8, 0xf1c0, 0x8100, 0x3f8},
        {d68000_or_re_16, 0xf1c0, 0x8140, 0x3f8},
        {d68000_or_re_32, 0xf1c0, 0x8180, 0x3f8},
        {d68000_ori_to_ccr, 0xffff, 0x003c, 0x000},
        {d68000_ori_to_sr, 0xffff, 0x007c, 0x000},
        {d68000_ori_8, 0xffc0, 0x0000, 0xbf8},
        {d68000_ori_16, 0xffc0, 0x0040, 0xbf8},
        {d68000_ori_32, 0xffc0, 0x0080, 0xbf8},
        {d68020_pack_rr, 0xf1f8, 0x8140, 0x000},
        {d68020_pack_mm, 0xf1f8, 0x8148, 0x000},
        {d68000_pea, 0xffc0, 0x4840, 0x27b},
        {d68040_pflush, 0xffe0, 0xf500, 0x000},
        {d68000_reset, 0xffff, 0x4e70, 0x000},
        {d68000_ror_s_8, 0xf1f8, 0xe018, 0x000},
        {d68000_ror_s_16, 0xf1f8, 0xe058, 0x000},
        {d68000_ror_s_32, 0xf1f8, 0xe098, 0x000},
        {d68000_ror_r_8, 0xf1f8, 0xe038, 0x000},
        {d68000_ror_r_16, 0xf1f8, 0xe078, 0x000},
        {d68000_ror_r_32, 0xf1f8, 0xe0b8, 0x000},
        {d68000_ror_ea, 0xffc0, 0xe6c0, 0x3f8},
        {d68000_rol_s_8, 0xf1f8, 0xe118, 0x000},
        {d68000_rol_s_16, 0xf1f8, 0xe158, 0x000},
        {d68000_rol_s_32, 0xf1f8, 0xe198, 0x000},
        {d68000_rol_r_8, 0xf1f8, 0xe138, 0x000},
        {d68000_rol_r_16, 0xf1f8, 0xe178, 0x000},
        {d68000_rol_r_32, 0xf1f8, 0xe1b8, 0x000},
        {d68000_rol_ea, 0xffc0, 0xe7c0, 0x3f8},
        {d68000_roxr_s_8, 0xf1f8, 0xe010, 0x000},
        {d68000_roxr_s_16, 0xf1f8, 0xe050, 0x000},
        {d68000_roxr_s_32, 0xf1f8, 0xe090, 0x000},
        {d68000_roxr_r_8, 0xf1f8, 0xe030, 0x000},
        {d68000_roxr_r_16, 0xf1f8, 0xe070, 0x000},
        {d68000_roxr_r_32, 0xf1f8, 0xe0b0, 0x000},
        {d68000_roxr_ea, 0xffc0, 0xe4c0, 0x3f8},
        {d68000_roxl_s_8, 0xf1f8, 0xe110, 0x000},
        {d68000_roxl_s_16, 0xf1f8, 0xe150, 0x000},
        {d68000_roxl_s_32, 0xf1f8, 0xe190, 0x000},
        {d68000_roxl_r_8, 0xf1f8, 0xe130, 0x000},
        {d68000_roxl_r_16, 0xf1f8, 0xe170, 0x000},
        {d68000_roxl_r_32, 0xf1f8, 0xe1b0, 0x000},
        {d68000_roxl_ea, 0xffc0, 0xe5c0, 0x3f8},
        {d68010_rtd, 0xffff, 0x4e74, 0x000},
        {d68000_rte, 0xffff, 0x4e73, 0x000},
        {d68020_rtm, 0xfff0, 0x06c0, 0x000},
        {d68000_rtr, 0xffff, 0x4e77, 0x000},
        {d68000_rts, 0xffff, 0x4e75, 0x000},
        {d68000_sbcd_rr, 0xf1f8, 0x8100, 0x000},
        {d68000_sbcd_mm, 0xf1f8, 0x8108, 0x000},
        {d68000_scc, 0xf0c0, 0x50c0, 0xbf8},
        {d68000_stop, 0xffff, 0x4e72, 0x000},
        {d68000_sub_er_8, 0xf1c0, 0x9000, 0xbff},
        {d68000_sub_er_16, 0xf1c0, 0x9040, 0xfff},
        {d68000_sub_er_32, 0xf1c0, 0x9080, 0xfff},
        {d68000_sub_re_8, 0xf1c0, 0x9100, 0x3f8},
        {d68000_sub_re_16, 0xf1c0, 0x9140, 0x3f8},
        {d68000_sub_re_32, 0xf1c0, 0x9180, 0x3f8},
        {d68000_suba_16, 0xf1c0, 0x90c0, 0xfff},
        {d68000_suba_32, 0xf1c0, 0x91c0, 0xfff},
        {d68000_subi_8, 0xffc0, 0x0400, 0xbf8},
        {d68000_subi_16, 0xffc0, 0x0440, 0xbf8},
        {d68000_subi_32, 0xffc0, 0x0480, 0xbf8},
        {d68000_subq_8, 0xf1c0, 0x5100, 0xbf8},
        {d68000_subq_16, 0xf1c0, 0x5140, 0xff8},
        {d68000_subq_32, 0xf1c0, 0x5180, 0xff8},
        {d68000_subx_rr_8, 0xf1f8, 0x9100, 0x000},
        {d68000_subx_rr_16, 0xf1f8, 0x9140, 0x000},
        {d68000_subx_rr_32, 0xf1f8, 0x9180, 0x000},
        {d68000_subx_mm_8, 0xf1f8, 0x9108, 0x000},
        {d68000_subx_mm_16, 0xf1f8, 0x9148, 0x000},
        {d68000_subx_mm_32, 0xf1f8, 0x9188, 0x000},
        {d68000_swap, 0xfff8, 0x4840, 0x000},
        {d68000_tas, 0xffc0, 0x4ac0, 0xbf8},
        {d68000_trap, 0xfff0, 0x4e40, 0x000},
        {d68020_trapcc_0, 0xf0ff, 0x50fc, 0x000},
        {d68020_trapcc_16, 0xf0ff, 0x50fa, 0x000},
        {d68020_trapcc_32, 0xf0ff, 0x50fb, 0x000},
        {d68000_trapv, 0xffff, 0x4e76, 0x000},
        {d68000_tst_8, 0xffc0, 0x4a00, 0xbf8},
        {d68020_tst_pcdi_8, 0xffff, 0x4a3a, 0x000},
        {d68020_tst_pcix_8, 0xffff, 0x4a3b, 0x000},
        {d68020_tst_i_8, 0xffff, 0x4a3c, 0x000},
        {d68000_tst_16, 0xffc0, 0x4a40, 0xbf8},
        {d68020_tst_a_16, 0xfff8, 0x4a48, 0x000},
        {d68020_tst_pcdi_16, 0xffff, 0x4a7a, 0x000},
        {d68020_tst_pcix_16, 0xffff, 0x4a7b, 0x000},
        {d68020_tst_i_16, 0xffff, 0x4a7c, 0x000},
        {d68000_tst_32, 0xffc0, 0x4a80, 0xbf8},
        {d68020_tst_a_32, 0xfff8, 0x4a88, 0x000},
        {d68020_tst_pcdi_32, 0xffff, 0x4aba, 0x000},
        {d68020_tst_pcix_32, 0xffff, 0x4abb, 0x000},
        {d68020_tst_i_32, 0xffff, 0x4abc, 0x000},
        {d68000_unlk, 0xfff8, 0x4e58, 0x000},
        {d68020_unpk_rr, 0xf1f8, 0x8180, 0x000},
        {d68020_unpk_mm, 0xf1f8, 0x8188, 0x000},
        {d68851_p000, 0xffc0, 0xf000, 0x000},
        {d68851_pbcc16, 0xffc0, 0xf080, 0x000},
        {d68851_pbcc32, 0xffc0, 0xf0c0, 0x000},
        {d68851_pdbcc, 0xfff8, 0xf048, 0x000},
        {d68851_p001, 0xffc0, 0xf040, 0x000},
        {0, 0, 0, 0}};

/* Check if opcode is using a valid ea mode */
static int valid_ea(uint opcode, uint mask)
{
    if (mask == 0) {
        return 1;
    }

    switch (opcode & 0x3f) {
        case 0x00:
        case 0x01:
        case 0x02:
        case 0x03:
        case 0x04:
        case 0x05:
        case 0x06:
        case 0x07:
            return (mask & 0x800) != 0;
        case 0x08:
        case 0x09:
        case 0x0a:
        case 0x0b:
        case 0x0c:
        case 0x0d:
        case 0x0e:
        case 0x0f:
            return (mask & 0x400) != 0;
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
        case 0x14:
        case 0x15:
        case 0x16:
        case 0x17:
            return (mask & 0x200) != 0;
        case 0x18:
        case 0x19:
        case 0x1a:
        case 0x1b:
        case 0x1c:
        case 0x1d:
        case 0x1e:
        case 0x1f:
            return (mask & 0x100) != 0;
        case 0x20:
        case 0x21:
        case 0x22:
        case 0x23:
        case 0x24:
        case 0x25:
        case 0x26:
        case 0x27:
            return (mask & 0x080) != 0;
        case 0x28:
        case 0x29:
        case 0x2a:
        case 0x2b:
        case 0x2c:
        case 0x2d:
        case 0x2e:
        case 0x2f:
            return (mask & 0x040) != 0;
        case 0x30:
        case 0x31:
        case 0x32:
        case 0x33:
        case 0x34:
        case 0x35:
        case 0x36:
        case 0x37:
            return (mask & 0x020) != 0;
        case 0x38:
            return (mask & 0x010) != 0;
        case 0x39:
            return (mask & 0x008) != 0;
        case 0x3a:
            return (mask & 0x002) != 0;
        case 0x3b:
            return (mask & 0x001) != 0;
        case 0x3c:
            return (mask & 0x004) != 0;
    }
    return 0;
}

/* Used by qsort */
static int DECL_SPEC compare_nof_true_bits(const void* aptr, const void* bptr)
{
    uint a = ((const opcode_struct*)aptr)->mask;
    uint b = ((const opcode_struct*)bptr)->mask;

    a = ((a & 0xAAAA) >> 1) + (a & 0x5555);
    a = ((a & 0xCCCC) >> 2) + (a & 0x3333);
    a = ((a & 0xF0F0) >> 4) + (a & 0x0F0F);
    a = ((a & 0xFF00) >> 8) + (a & 0x00FF);

    b = ((b & 0xAAAA) >> 1) + (b & 0x5555);
    b = ((b & 0xCCCC) >> 2) + (b & 0x3333);
    b = ((b & 0xF0F0) >> 4) + (b & 0x0F0F);
    b = ((b & 0xFF00) >> 8) + (b & 0x00FF);

    return b - a; /* reversed to get greatest to least sorting */
}

/* build the opcode handler jump table */
static void build_opcode_table(void)
{
    uint i;
    uint opcode;
    opcode_struct* ostruct;
    opcode_struct opcode_info[ARRAY_LENGTH(g_opcode_info)];

    memcpy(opcode_info, g_opcode_info, sizeof(g_opcode_info));
    qsort((void*)opcode_info, ARRAY_LENGTH(opcode_info) - 1, sizeof(opcode_info[0]), compare_nof_true_bits);

    for (i = 0; i < 0x10000; i++) {
        g_instruction_table[i] = d68000_illegal; /* default to illegal */
        opcode = i;
        /* search through opcode info for a match */
        for (ostruct = opcode_info; ostruct->opcode_handler != 0; ostruct++) {
            /* match opcode mask and allowed ea modes */
            if ((opcode & ostruct->mask) == ostruct->match) {
                /* Handle destination ea for move instructions */
                if ((ostruct->opcode_handler == d68000_move_8 ||
                     ostruct->opcode_handler == d68000_move_16 ||
                     ostruct->opcode_handler == d68000_move_32) &&
                    !valid_ea(((opcode >> 9) & 7) | ((opcode >> 3) & 0x38), 0xbf8)) {
                    continue;
                }
                if (valid_ea(opcode, ostruct->ea_mask)) {
                    g_instruction_table[i] = ostruct->opcode_handler;
                    break;
                }
            }
        }
    }
}

/* ======================================================================== */
/* ================================= API ================================== */
/* ======================================================================== */

/* Disasemble one instruction at pc and store in str_buff */
unsigned int m68k_disassemble(char* str_buff, unsigned int pc, unsigned int cpu_type)
{
    if (!g_initialized) {
        build_opcode_table();
        g_initialized = 1;
    }
    switch (cpu_type) {
        case M68K_CPU_TYPE_68000:
            g_cpu_type = TYPE_68000;
            g_address_mask = 0x00ffffff;
            break;
        case M68K_CPU_TYPE_68010:
            g_cpu_type = TYPE_68010;
            g_address_mask = 0x00ffffff;
            break;
        case M68K_CPU_TYPE_68EC020:
            g_cpu_type = TYPE_68020;
            g_address_mask = 0x00ffffff;
            break;
        case M68K_CPU_TYPE_68020:
            g_cpu_type = TYPE_68020;
            g_address_mask = 0xffffffff;
            break;
        case M68K_CPU_TYPE_68EC030:
        case M68K_CPU_TYPE_68030:
            g_cpu_type = TYPE_68030;
            g_address_mask = 0xffffffff;
            break;
        case M68K_CPU_TYPE_68040:
        case M68K_CPU_TYPE_68EC040:
        case M68K_CPU_TYPE_68LC040:
            g_cpu_type = TYPE_68040;
            g_address_mask = 0xffffffff;
            break;
        default:
            return 0;
    }

    g_cpu_pc = pc;
    g_helper_str[0] = 0;
    g_cpu_ir = read_imm_16();
    g_opcode_type = 0;
    g_instruction_table[g_cpu_ir]();
    sprintf(str_buff, "%s%s", g_dasm_str, g_helper_str);
    return COMBINE_OPCODE_FLAGS(g_cpu_pc - pc);
}

char* m68ki_disassemble_quick(unsigned int pc, unsigned int cpu_type)
{
    static char buff[100];
    buff[0] = 0;
    m68k_disassemble(buff, pc, cpu_type);
    return buff;
}

unsigned int m68k_disassemble_raw(char* str_buff, unsigned int pc, const unsigned char* opdata, const unsigned char* argdata, unsigned int cpu_type)
{
    unsigned int result;
    (void)argdata;

    g_rawop = opdata;
    g_rawbasepc = pc;
    result = m68k_disassemble(str_buff, pc, cpu_type);
    g_rawop = NULL;
    return result;
}

/* Check if the instruction is a valid one */
unsigned int m68k_is_valid_instruction(unsigned int instruction, unsigned int cpu_type)
{
    if (!g_initialized) {
        build_opcode_table();
        g_initialized = 1;
    }

    instruction &= 0xffff;
    if (g_instruction_table[instruction] == d68000_illegal) {
        return 0;
    }

    switch (cpu_type) {
        case M68K_CPU_TYPE_68000:
            if (g_instruction_table[instruction] == d68010_bkpt) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68010_move_fr_ccr) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68010_movec) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68010_moves_8) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68010_moves_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68010_moves_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68010_rtd) {
                return 0;
            }
            // Fallthrough
        case M68K_CPU_TYPE_68010:
            if (g_instruction_table[instruction] == d68020_bcc_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_bfchg) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_bfclr) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_bfexts) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_bfextu) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_bfffo) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_bfins) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_bfset) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_bftst) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_bra_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_bsr_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_callm) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cas_8) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cas_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cas_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cas2_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cas2_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_chk_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_chk2_cmp2_8) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_chk2_cmp2_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_chk2_cmp2_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cmpi_pcdi_8) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cmpi_pcix_8) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cmpi_pcdi_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cmpi_pcix_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cmpi_pcdi_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cmpi_pcix_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cpbcc_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cpbcc_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cpdbcc) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cpgen) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cprestore) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cpsave) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cpscc) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cptrapcc_0) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cptrapcc_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cptrapcc_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_divl) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_extb_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_link_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_mull) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_pack_rr) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_pack_mm) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_rtm) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_trapcc_0) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_trapcc_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_trapcc_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_tst_pcdi_8) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_tst_pcix_8) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_tst_i_8) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_tst_a_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_tst_pcdi_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_tst_pcix_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_tst_i_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_tst_a_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_tst_pcdi_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_tst_pcix_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_tst_i_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_unpk_rr) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_unpk_mm) {
                return 0;
            }
            // Fallthrough
        case M68K_CPU_TYPE_68EC020:
        case M68K_CPU_TYPE_68020:
        case M68K_CPU_TYPE_68030:
        case M68K_CPU_TYPE_68EC030:
            if (g_instruction_table[instruction] == d68040_cinv) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68040_cpush) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68040_move16_pi_pi) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68040_move16_pi_al) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68040_move16_al_pi) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68040_move16_ai_al) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68040_move16_al_ai) {
                return 0;
            }
            // Fallthrough
        case M68K_CPU_TYPE_68040:
        case M68K_CPU_TYPE_68EC040:
        case M68K_CPU_TYPE_68LC040:
            if (g_instruction_table[instruction] == d68020_cpbcc_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cpbcc_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cpdbcc) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cpgen) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cprestore) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cpsave) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cpscc) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cptrapcc_0) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cptrapcc_16) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68020_cptrapcc_32) {
                return 0;
            }
            if (g_instruction_table[instruction] == d68040_pflush) {
                return 0;
            }
    }
    if (cpu_type != M68K_CPU_TYPE_68020 && cpu_type != M68K_CPU_TYPE_68EC020 &&
        (g_instruction_table[instruction] == d68020_callm ||
         g_instruction_table[instruction] == d68020_rtm)) {
        return 0;
    }

    return 1;
}

// f028 2215 0008

/* ======================================================================== */
/* ============================== END OF FILE ============================= */
/* ======================================================================== */
/* -- End embedded musashi/m68kdasm.c -- */

/* -- Begin embedded musashi/softfloat.c -- */

/*============================================================================

This C source file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
Package, Release 2b.

Written by John R. Hauser.  This work was made possible in part by the
International Computer Science Institute, located at Suite 600, 1947 Center
Street, Berkeley, California 94704.  Funding was partially provided by the
National Science Foundation under grant MIP-9311980.  The original version
of this code was written as part of a project to build a fixed-point vector
processor in collaboration with the University of California at Berkeley,
overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
arithmetic/SoftFloat.html'.

THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.

Derivative works are acceptable, even for commercial purposes, so long as
(1) the source code for the derivative work includes prominent notice that
the work is derivative, and (2) the source code includes prominent notice with
these four paragraphs for those parts of this code that are retained.

=============================================================================*/

/*----------------------------------------------------------------------------
| Floating-point rounding mode, extended double-precision rounding precision,
| and exception flags.
*----------------------------------------------------------------------------*/
int8 float_exception_flags = 0;
#ifdef FLOATX80
int8 floatx80_rounding_precision = 80;
#endif

int8 float_rounding_mode = float_round_nearest_even;

/*----------------------------------------------------------------------------
| Functions and definitions to determine:  (1) whether tininess for underflow
| is detected before or after rounding by default, (2) what (if anything)
| happens when exceptions are raised, (3) how signaling NaNs are distinguished
| from quiet NaNs, (4) the default generated quiet NaNs, and (5) how NaNs
| are propagated from function inputs to output.  These details are target-
| specific.
*----------------------------------------------------------------------------*/
/* -- Begin embedded musashi/softfloat/softfloat-specialize -- */

/*============================================================================

This C source fragment is part of the SoftFloat IEC/IEEE Floating-point
Arithmetic Package, Release 2b.

Written by John R. Hauser.  This work was made possible in part by the
International Computer Science Institute, located at Suite 600, 1947 Center
Street, Berkeley, California 94704.  Funding was partially provided by the
National Science Foundation under grant MIP-9311980.  The original version
of this code was written as part of a project to build a fixed-point vector
processor in collaboration with the University of California at Berkeley,
overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
arithmetic/SoftFloat.html'.

THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.

Derivative works are acceptable, even for commercial purposes, so long as
(1) the source code for the derivative work includes prominent notice that
the work is derivative, and (2) the source code includes prominent notice with
these four paragraphs for those parts of this code that are retained.

=============================================================================*/

flag float32_is_nan(float32 a);
flag float64_is_nan(float64 a);
flag floatx80_is_nan(floatx80 a);
floatx80 propagateFloatx80NaN(floatx80 a, floatx80 b);
flag float128_is_nan(float128 a);

/*----------------------------------------------------------------------------
| Underflow tininess-detection mode, statically initialized to default value.
| (The declaration in `softfloat.h' must match the `int8' type here.)
*----------------------------------------------------------------------------*/
int8 float_detect_tininess = float_tininess_after_rounding;

/*----------------------------------------------------------------------------
| Raises the exceptions specified by `flags'.  Floating-point traps can be
| defined here if desired.  It is currently not possible for such a trap to
| substitute a result value.  If traps are not implemented, this routine
| should be simply `float_exception_flags |= flags;'.
*----------------------------------------------------------------------------*/

void float_raise(int8 flags)
{

    float_exception_flags |= flags;
}

/*----------------------------------------------------------------------------
| Internal canonical NaN format.
*----------------------------------------------------------------------------*/
typedef struct
{
    flag sign;
    bits64 high, low;
} commonNaNT;

/*----------------------------------------------------------------------------
| The pattern for a default generated single-precision NaN.
*----------------------------------------------------------------------------*/
#define float32_default_nan 0xFFFFFFFF

/*----------------------------------------------------------------------------
| Returns 1 if the single-precision floating-point value `a' is a NaN;
| otherwise returns 0.
*----------------------------------------------------------------------------*/

flag float32_is_nan(float32 a)
{

    return (0xFF000000 < (bits32)(a << 1));
}

/*----------------------------------------------------------------------------
| Returns 1 if the single-precision floating-point value `a' is a signaling
| NaN; otherwise returns 0.
*----------------------------------------------------------------------------*/

flag float32_is_signaling_nan(float32 a)
{

    return (((a >> 22) & 0x1FF) == 0x1FE) && (a & 0x003FFFFF);
}

/*----------------------------------------------------------------------------
| Returns the result of converting the single-precision floating-point NaN
| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
| exception is raised.
*----------------------------------------------------------------------------*/

static commonNaNT float32ToCommonNaN(float32 a)
{
    commonNaNT z;

    if (float32_is_signaling_nan(a)) {
        float_raise(float_flag_invalid);
    }
    z.sign = a >> 31;
    z.low = 0;
    z.high = ((bits64)a) << 41;
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of converting the canonical NaN `a' to the single-
| precision floating-point format.
*----------------------------------------------------------------------------*/

static float32 commonNaNToFloat32(commonNaNT a)
{

    return (((bits32)a.sign) << 31) | 0x7FC00000 | (a.high >> 41);
}

/*----------------------------------------------------------------------------
| Takes two single-precision floating-point values `a' and `b', one of which
| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a
| signaling NaN, the invalid exception is raised.
*----------------------------------------------------------------------------*/

static float32 propagateFloat32NaN(float32 a, float32 b)
{
    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;

    aIsNaN = float32_is_nan(a);
    aIsSignalingNaN = float32_is_signaling_nan(a);
    bIsNaN = float32_is_nan(b);
    bIsSignalingNaN = float32_is_signaling_nan(b);
    a |= 0x00400000;
    b |= 0x00400000;
    if (aIsSignalingNaN | bIsSignalingNaN) {
        float_raise(float_flag_invalid);
    }
    if (aIsNaN) {
        return (aIsSignalingNaN & bIsNaN) ? b : a;
    } else {
        return b;
    }
}

/*----------------------------------------------------------------------------
| The pattern for a default generated double-precision NaN.
*----------------------------------------------------------------------------*/
#define float64_default_nan LIT64(0xFFFFFFFFFFFFFFFF)

/*----------------------------------------------------------------------------
| Returns 1 if the double-precision floating-point value `a' is a NaN;
| otherwise returns 0.
*----------------------------------------------------------------------------*/

flag float64_is_nan(float64 a)
{

    return (LIT64(0xFFE0000000000000) < (bits64)(a << 1));
}

/*----------------------------------------------------------------------------
| Returns 1 if the double-precision floating-point value `a' is a signaling
| NaN; otherwise returns 0.
*----------------------------------------------------------------------------*/

flag float64_is_signaling_nan(float64 a)
{

    return (((a >> 51) & 0xFFF) == 0xFFE) && (a & LIT64(0x0007FFFFFFFFFFFF));
}

/*----------------------------------------------------------------------------
| Returns the result of converting the double-precision floating-point NaN
| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
| exception is raised.
*----------------------------------------------------------------------------*/

static commonNaNT float64ToCommonNaN(float64 a)
{
    commonNaNT z;

    if (float64_is_signaling_nan(a)) {
        float_raise(float_flag_invalid);
    }
    z.sign = a >> 63;
    z.low = 0;
    z.high = a << 12;
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of converting the canonical NaN `a' to the double-
| precision floating-point format.
*----------------------------------------------------------------------------*/

static float64 commonNaNToFloat64(commonNaNT a)
{

    return (((bits64)a.sign) << 63) | LIT64(0x7FF8000000000000) | (a.high >> 12);
}

/*----------------------------------------------------------------------------
| Takes two double-precision floating-point values `a' and `b', one of which
| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a
| signaling NaN, the invalid exception is raised.
*----------------------------------------------------------------------------*/

static float64 propagateFloat64NaN(float64 a, float64 b)
{
    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;

    aIsNaN = float64_is_nan(a);
    aIsSignalingNaN = float64_is_signaling_nan(a);
    bIsNaN = float64_is_nan(b);
    bIsSignalingNaN = float64_is_signaling_nan(b);
    a |= LIT64(0x0008000000000000);
    b |= LIT64(0x0008000000000000);
    if (aIsSignalingNaN | bIsSignalingNaN) {
        float_raise(float_flag_invalid);
    }
    if (aIsNaN) {
        return (aIsSignalingNaN & bIsNaN) ? b : a;
    } else {
        return b;
    }
}

#ifdef FLOATX80

/*----------------------------------------------------------------------------
| The pattern for a default generated extended double-precision NaN.  The
| `high' and `low' values hold the most- and least-significant bits,
| respectively.
*----------------------------------------------------------------------------*/
#define floatx80_default_nan_high 0xFFFF
#define floatx80_default_nan_low LIT64(0xFFFFFFFFFFFFFFFF)

/*----------------------------------------------------------------------------
| Returns 1 if the extended double-precision floating-point value `a' is a
| NaN; otherwise returns 0.
*----------------------------------------------------------------------------*/

flag floatx80_is_nan(floatx80 a)
{

    return ((a.high & 0x7FFF) == 0x7FFF) && (bits64)(a.low << 1);
}

/*----------------------------------------------------------------------------
| Returns 1 if the extended double-precision floating-point value `a' is a
| signaling NaN; otherwise returns 0.
*----------------------------------------------------------------------------*/

flag floatx80_is_signaling_nan(floatx80 a)
{
    bits64 aLow;

    aLow = a.low & ~LIT64(0x4000000000000000);
    return ((a.high & 0x7FFF) == 0x7FFF) && (bits64)(aLow << 1) && (a.low == aLow);
}

/*----------------------------------------------------------------------------
| Returns the result of converting the extended double-precision floating-
| point NaN `a' to the canonical NaN format.  If `a' is a signaling NaN, the
| invalid exception is raised.
*----------------------------------------------------------------------------*/

static commonNaNT floatx80ToCommonNaN(floatx80 a)
{
    commonNaNT z;

    if (floatx80_is_signaling_nan(a)) {
        float_raise(float_flag_invalid);
    }
    z.sign = a.high >> 15;
    z.low = 0;
    z.high = a.low << 1;
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of converting the canonical NaN `a' to the extended
| double-precision floating-point format.
*----------------------------------------------------------------------------*/

static floatx80 commonNaNToFloatx80(commonNaNT a)
{
    floatx80 z;

    z.low = LIT64(0xC000000000000000) | (a.high >> 1);
    z.high = (((bits16)a.sign) << 15) | 0x7FFF;
    return z;
}

/*----------------------------------------------------------------------------
| Takes two extended double-precision floating-point values `a' and `b', one
| of which is a NaN, and returns the appropriate NaN result.  If either `a' or
| `b' is a signaling NaN, the invalid exception is raised.
*----------------------------------------------------------------------------*/

floatx80 propagateFloatx80NaN(floatx80 a, floatx80 b)
{
    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;

    aIsNaN = floatx80_is_nan(a);
    aIsSignalingNaN = floatx80_is_signaling_nan(a);
    bIsNaN = floatx80_is_nan(b);
    bIsSignalingNaN = floatx80_is_signaling_nan(b);
    a.low |= LIT64(0xC000000000000000);
    b.low |= LIT64(0xC000000000000000);
    if (aIsSignalingNaN | bIsSignalingNaN) {
        float_raise(float_flag_invalid);
    }
    if (aIsNaN) {
        return (aIsSignalingNaN & bIsNaN) ? b : a;
    } else {
        return b;
    }
}

#define EXP_BIAS 0x3FFF

/*----------------------------------------------------------------------------
| Returns the fraction bits of the extended double-precision floating-point
| value `a'.
*----------------------------------------------------------------------------*/

static inline bits64 extractFloatx80Frac(floatx80 a)
{

    return a.low;
}

/*----------------------------------------------------------------------------
| Returns the exponent bits of the extended double-precision floating-point
| value `a'.
*----------------------------------------------------------------------------*/

static inline int32 extractFloatx80Exp(floatx80 a)
{

    return a.high & 0x7FFF;
}

/*----------------------------------------------------------------------------
| Returns the sign bit of the extended double-precision floating-point value
| `a'.
*----------------------------------------------------------------------------*/

static inline flag extractFloatx80Sign(floatx80 a)
{

    return a.high >> 15;
}

#endif

#ifdef FLOAT128

/*----------------------------------------------------------------------------
| The pattern for a default generated quadruple-precision NaN.  The `high' and
| `low' values hold the most- and least-significant bits, respectively.
*----------------------------------------------------------------------------*/
#define float128_default_nan_high LIT64(0xFFFFFFFFFFFFFFFF)
#define float128_default_nan_low LIT64(0xFFFFFFFFFFFFFFFF)

/*----------------------------------------------------------------------------
| Returns 1 if the quadruple-precision floating-point value `a' is a NaN;
| otherwise returns 0.
*----------------------------------------------------------------------------*/

flag float128_is_nan(float128 a)
{

    return (LIT64(0xFFFE000000000000) <= (bits64)(a.high << 1)) && (a.low || (a.high & LIT64(0x0000FFFFFFFFFFFF)));
}

/*----------------------------------------------------------------------------
| Returns 1 if the quadruple-precision floating-point value `a' is a
| signaling NaN; otherwise returns 0.
*----------------------------------------------------------------------------*/

flag float128_is_signaling_nan(float128 a)
{

    return (((a.high >> 47) & 0xFFFF) == 0xFFFE) && (a.low || (a.high & LIT64(0x00007FFFFFFFFFFF)));
}

/*----------------------------------------------------------------------------
| Returns the result of converting the quadruple-precision floating-point NaN
| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
| exception is raised.
*----------------------------------------------------------------------------*/

static commonNaNT float128ToCommonNaN(float128 a)
{
    commonNaNT z;

    if (float128_is_signaling_nan(a)) {
        float_raise(float_flag_invalid);
    }
    z.sign = a.high >> 63;
    shortShift128Left(a.high, a.low, 16, &z.high, &z.low);
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of converting the canonical NaN `a' to the quadruple-
| precision floating-point format.
*----------------------------------------------------------------------------*/

static float128 commonNaNToFloat128(commonNaNT a)
{
    float128 z;

    shift128Right(a.high, a.low, 16, &z.high, &z.low);
    z.high |= (((bits64)a.sign) << 63) | LIT64(0x7FFF800000000000);
    return z;
}

/*----------------------------------------------------------------------------
| Takes two quadruple-precision floating-point values `a' and `b', one of
| which is a NaN, and returns the appropriate NaN result.  If either `a' or
| `b' is a signaling NaN, the invalid exception is raised.
*----------------------------------------------------------------------------*/

static float128 propagateFloat128NaN(float128 a, float128 b)
{
    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;

    aIsNaN = float128_is_nan(a);
    aIsSignalingNaN = float128_is_signaling_nan(a);
    bIsNaN = float128_is_nan(b);
    bIsSignalingNaN = float128_is_signaling_nan(b);
    a.high |= LIT64(0x0000800000000000);
    b.high |= LIT64(0x0000800000000000);
    if (aIsSignalingNaN | bIsSignalingNaN) {
        float_raise(float_flag_invalid);
    }
    if (aIsNaN) {
        return (aIsSignalingNaN & bIsNaN) ? b : a;
    } else {
        return b;
    }
}

#endif

/* -- End embedded musashi/softfloat/softfloat-specialize -- */

/*----------------------------------------------------------------------------
| Takes a 64-bit fixed-point value `absZ' with binary point between bits 6
| and 7, and returns the properly rounded 32-bit integer corresponding to the
| input.  If `zSign' is 1, the input is negated before being converted to an
| integer.  Bit 63 of `absZ' must be zero.  Ordinarily, the fixed-point input
| is simply rounded to an integer, with the inexact exception raised if the
| input cannot be represented exactly as an integer.  However, if the fixed-
| point input is too large, the invalid exception is raised and the largest
| positive or negative integer is returned.
*----------------------------------------------------------------------------*/

static int32 roundAndPackInt32(flag zSign, bits64 absZ)
{
    int8 roundingMode;
    flag roundNearestEven;
    int8 roundIncrement, roundBits;
    int32 z;

    roundingMode = float_rounding_mode;
    roundNearestEven = (roundingMode == float_round_nearest_even);
    roundIncrement = 0x40;
    if (!roundNearestEven) {
        if (roundingMode == float_round_to_zero) {
            roundIncrement = 0;
        } else {
            roundIncrement = 0x7F;
            if (zSign) {
                if (roundingMode == float_round_up) {
                    roundIncrement = 0;
                }
            } else {
                if (roundingMode == float_round_down) {
                    roundIncrement = 0;
                }
            }
        }
    }
    roundBits = absZ & 0x7F;
    absZ = (absZ + roundIncrement) >> 7;
    absZ &= ~(((roundBits ^ 0x40) == 0) & roundNearestEven);
    z = absZ;
    if (zSign) {
        z = -z;
    }
    if ((absZ >> 32) || (z && ((z < 0) ^ zSign))) {
        float_raise(float_flag_invalid);
        return zSign ? (sbits32)0x80000000 : 0x7FFFFFFF;
    }
    if (roundBits) {
        float_exception_flags |= float_flag_inexact;
    }
    return z;
}

/*----------------------------------------------------------------------------
| Takes the 128-bit fixed-point value formed by concatenating `absZ0' and
| `absZ1', with binary point between bits 63 and 64 (between the input words),
| and returns the properly rounded 64-bit integer corresponding to the input.
| If `zSign' is 1, the input is negated before being converted to an integer.
| Ordinarily, the fixed-point input is simply rounded to an integer, with
| the inexact exception raised if the input cannot be represented exactly as
| an integer.  However, if the fixed-point input is too large, the invalid
| exception is raised and the largest positive or negative integer is
| returned.
*----------------------------------------------------------------------------*/

static int64 roundAndPackInt64(flag zSign, bits64 absZ0, bits64 absZ1)
{
    int8 roundingMode;
    flag roundNearestEven, increment;
    int64 z;

    roundingMode = float_rounding_mode;
    roundNearestEven = (roundingMode == float_round_nearest_even);
    increment = ((sbits64)absZ1 < 0);
    if (!roundNearestEven) {
        if (roundingMode == float_round_to_zero) {
            increment = 0;
        } else {
            if (zSign) {
                increment = (roundingMode == float_round_down) && absZ1;
            } else {
                increment = (roundingMode == float_round_up) && absZ1;
            }
        }
    }
    if (increment) {
        ++absZ0;
        if (absZ0 == 0) {
            goto overflow;
        }
        absZ0 &= ~(((bits64)(absZ1 << 1) == 0) & roundNearestEven);
    }
    z = absZ0;
    if (zSign) {
        z = -z;
    }
    if (z && ((z < 0) ^ zSign)) {
    overflow:
        float_raise(float_flag_invalid);
        return zSign ? (sbits64)LIT64(0x8000000000000000)
                     : (sbits64)LIT64(0x7FFFFFFFFFFFFFFF);
    }
    if (absZ1) {
        float_exception_flags |= float_flag_inexact;
    }
    return z;
}

/*----------------------------------------------------------------------------
| Returns the fraction bits of the single-precision floating-point value `a'.
*----------------------------------------------------------------------------*/

static inline bits32 extractFloat32Frac(float32 a)
{
    return a & 0x007FFFFF;
}

/*----------------------------------------------------------------------------
| Returns the exponent bits of the single-precision floating-point value `a'.
*----------------------------------------------------------------------------*/

static inline int16 extractFloat32Exp(float32 a)
{
    return (a >> 23) & 0xFF;
}

/*----------------------------------------------------------------------------
| Returns the sign bit of the single-precision floating-point value `a'.
*----------------------------------------------------------------------------*/

static inline flag extractFloat32Sign(float32 a)
{
    return a >> 31;
}

/*----------------------------------------------------------------------------
| Normalizes the subnormal single-precision floating-point value represented
| by the denormalized significand `aSig'.  The normalized exponent and
| significand are stored at the locations pointed to by `zExpPtr' and
| `zSigPtr', respectively.
*----------------------------------------------------------------------------*/

static void
normalizeFloat32Subnormal(bits32 aSig, int16* zExpPtr, bits32* zSigPtr)
{
    int8 shiftCount;

    shiftCount = countLeadingZeros32(aSig) - 8;
    *zSigPtr = aSig << shiftCount;
    *zExpPtr = 1 - shiftCount;
}

/*----------------------------------------------------------------------------
| Packs the sign `zSign', exponent `zExp', and significand `zSig' into a
| single-precision floating-point value, returning the result.  After being
| shifted into the proper positions, the three fields are simply added
| together to form the result.  This means that any integer portion of `zSig'
| will be added into the exponent.  Since a properly normalized significand
| will have an integer portion equal to 1, the `zExp' input should be 1 less
| than the desired result exponent whenever `zSig' is a complete, normalized
| significand.
*----------------------------------------------------------------------------*/

static inline float32 packFloat32(flag zSign, int16 zExp, bits32 zSig)
{
    return (((bits32)zSign) << 31) + (((bits32)zExp) << 23) + zSig;
}

/*----------------------------------------------------------------------------
| Takes an abstract floating-point value having sign `zSign', exponent `zExp',
| and significand `zSig', and returns the proper single-precision floating-
| point value corresponding to the abstract input.  Ordinarily, the abstract
| value is simply rounded and packed into the single-precision format, with
| the inexact exception raised if the abstract input cannot be represented
| exactly.  However, if the abstract value is too large, the overflow and
| inexact exceptions are raised and an infinity or maximal finite value is
| returned.  If the abstract value is too small, the input value is rounded to
| a subnormal number, and the underflow and inexact exceptions are raised if
| the abstract input cannot be represented exactly as a subnormal single-
| precision floating-point number.
|     The input significand `zSig' has its binary point between bits 30
| and 29, which is 7 bits to the left of the usual location.  This shifted
| significand must be normalized or smaller.  If `zSig' is not normalized,
| `zExp' must be 0; in that case, the result returned is a subnormal number,
| and it must not require rounding.  In the usual case that `zSig' is
| normalized, `zExp' must be 1 less than the ``true'' floating-point exponent.
| The handling of underflow and overflow follows the IEC/IEEE Standard for
| Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

static float32 roundAndPackFloat32(flag zSign, int16 zExp, bits32 zSig)
{
    int8 roundingMode;
    flag roundNearestEven;
    int8 roundIncrement, roundBits;
    flag isTiny;

    roundingMode = float_rounding_mode;
    roundNearestEven = (roundingMode == float_round_nearest_even);
    roundIncrement = 0x40;
    if (!roundNearestEven) {
        if (roundingMode == float_round_to_zero) {
            roundIncrement = 0;
        } else {
            roundIncrement = 0x7F;
            if (zSign) {
                if (roundingMode == float_round_up) {
                    roundIncrement = 0;
                }
            } else {
                if (roundingMode == float_round_down) {
                    roundIncrement = 0;
                }
            }
        }
    }
    roundBits = zSig & 0x7F;
    if (0xFD <= (bits16)zExp) {
        if ((0xFD < zExp) || ((zExp == 0xFD) && ((sbits32)(zSig + roundIncrement) < 0))) {
            float_raise(float_flag_overflow | float_flag_inexact);
            return packFloat32(zSign, 0xFF, 0) - (roundIncrement == 0);
        }
        if (zExp < 0) {
            isTiny =
                (float_detect_tininess == float_tininess_before_rounding) || (zExp < -1) || (zSig + roundIncrement < 0x80000000);
            shift32RightJamming(zSig, -zExp, &zSig);
            zExp = 0;
            roundBits = zSig & 0x7F;
            if (isTiny && roundBits) {
                float_raise(float_flag_underflow);
            }
        }
    }
    if (roundBits) {
        float_exception_flags |= float_flag_inexact;
    }
    zSig = (zSig + roundIncrement) >> 7;
    zSig &= ~(((roundBits ^ 0x40) == 0) & roundNearestEven);
    if (zSig == 0) {
        zExp = 0;
    }
    return packFloat32(zSign, zExp, zSig);
}

/*----------------------------------------------------------------------------
| Takes an abstract floating-point value having sign `zSign', exponent `zExp',
| and significand `zSig', and returns the proper single-precision floating-
| point value corresponding to the abstract input.  This routine is just like
| `roundAndPackFloat32' except that `zSig' does not have to be normalized.
| Bit 31 of `zSig' must be zero, and `zExp' must be 1 less than the ``true''
| floating-point exponent.
*----------------------------------------------------------------------------*/

static float32
normalizeRoundAndPackFloat32(flag zSign, int16 zExp, bits32 zSig)
{
    int8 shiftCount;

    shiftCount = countLeadingZeros32(zSig) - 1;
    return roundAndPackFloat32(zSign, zExp - shiftCount, zSig << shiftCount);
}

/*----------------------------------------------------------------------------
| Returns the fraction bits of the double-precision floating-point value `a'.
*----------------------------------------------------------------------------*/

static inline bits64 extractFloat64Frac(float64 a)
{
    return a & LIT64(0x000FFFFFFFFFFFFF);
}

/*----------------------------------------------------------------------------
| Returns the exponent bits of the double-precision floating-point value `a'.
*----------------------------------------------------------------------------*/

static inline int16 extractFloat64Exp(float64 a)
{
    return (a >> 52) & 0x7FF;
}

/*----------------------------------------------------------------------------
| Returns the sign bit of the double-precision floating-point value `a'.
*----------------------------------------------------------------------------*/

static inline flag extractFloat64Sign(float64 a)
{
    return a >> 63;
}

/*----------------------------------------------------------------------------
| Normalizes the subnormal double-precision floating-point value represented
| by the denormalized significand `aSig'.  The normalized exponent and
| significand are stored at the locations pointed to by `zExpPtr' and
| `zSigPtr', respectively.
*----------------------------------------------------------------------------*/

static void
normalizeFloat64Subnormal(bits64 aSig, int16* zExpPtr, bits64* zSigPtr)
{
    int8 shiftCount;

    shiftCount = countLeadingZeros64(aSig) - 11;
    *zSigPtr = aSig << shiftCount;
    *zExpPtr = 1 - shiftCount;
}

/*----------------------------------------------------------------------------
| Packs the sign `zSign', exponent `zExp', and significand `zSig' into a
| double-precision floating-point value, returning the result.  After being
| shifted into the proper positions, the three fields are simply added
| together to form the result.  This means that any integer portion of `zSig'
| will be added into the exponent.  Since a properly normalized significand
| will have an integer portion equal to 1, the `zExp' input should be 1 less
| than the desired result exponent whenever `zSig' is a complete, normalized
| significand.
*----------------------------------------------------------------------------*/

static inline float64 packFloat64(flag zSign, int16 zExp, bits64 zSig)
{
    return (((bits64)zSign) << 63) + (((bits64)zExp) << 52) + zSig;
}

/*----------------------------------------------------------------------------
| Takes an abstract floating-point value having sign `zSign', exponent `zExp',
| and significand `zSig', and returns the proper double-precision floating-
| point value corresponding to the abstract input.  Ordinarily, the abstract
| value is simply rounded and packed into the double-precision format, with
| the inexact exception raised if the abstract input cannot be represented
| exactly.  However, if the abstract value is too large, the overflow and
| inexact exceptions are raised and an infinity or maximal finite value is
| returned.  If the abstract value is too small, the input value is rounded
| to a subnormal number, and the underflow and inexact exceptions are raised
| if the abstract input cannot be represented exactly as a subnormal double-
| precision floating-point number.
|     The input significand `zSig' has its binary point between bits 62
| and 61, which is 10 bits to the left of the usual location.  This shifted
| significand must be normalized or smaller.  If `zSig' is not normalized,
| `zExp' must be 0; in that case, the result returned is a subnormal number,
| and it must not require rounding.  In the usual case that `zSig' is
| normalized, `zExp' must be 1 less than the ``true'' floating-point exponent.
| The handling of underflow and overflow follows the IEC/IEEE Standard for
| Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

static float64 roundAndPackFloat64(flag zSign, int16 zExp, bits64 zSig)
{
    int8 roundingMode;
    flag roundNearestEven;
    int16 roundIncrement, roundBits;
    flag isTiny;

    roundingMode = float_rounding_mode;
    roundNearestEven = (roundingMode == float_round_nearest_even);
    roundIncrement = 0x200;
    if (!roundNearestEven) {
        if (roundingMode == float_round_to_zero) {
            roundIncrement = 0;
        } else {
            roundIncrement = 0x3FF;
            if (zSign) {
                if (roundingMode == float_round_up) {
                    roundIncrement = 0;
                }
            } else {
                if (roundingMode == float_round_down) {
                    roundIncrement = 0;
                }
            }
        }
    }
    roundBits = zSig & 0x3FF;
    if (0x7FD <= (bits16)zExp) {
        if ((0x7FD < zExp) || ((zExp == 0x7FD) && ((sbits64)(zSig + roundIncrement) < 0))) {
            float_raise(float_flag_overflow | float_flag_inexact);
            return packFloat64(zSign, 0x7FF, 0) - (roundIncrement == 0);
        }
        if (zExp < 0) {
            isTiny =
                (float_detect_tininess == float_tininess_before_rounding) || (zExp < -1) || (zSig + roundIncrement < LIT64(0x8000000000000000));
            shift64RightJamming(zSig, -zExp, &zSig);
            zExp = 0;
            roundBits = zSig & 0x3FF;
            if (isTiny && roundBits) {
                float_raise(float_flag_underflow);
            }
        }
    }
    if (roundBits) {
        float_exception_flags |= float_flag_inexact;
    }
    zSig = (zSig + roundIncrement) >> 10;
    zSig &= ~(((roundBits ^ 0x200) == 0) & roundNearestEven);
    if (zSig == 0) {
        zExp = 0;
    }
    return packFloat64(zSign, zExp, zSig);
}

/*----------------------------------------------------------------------------
| Takes an abstract floating-point value having sign `zSign', exponent `zExp',
| and significand `zSig', and returns the proper double-precision floating-
| point value corresponding to the abstract input.  This routine is just like
| `roundAndPackFloat64' except that `zSig' does not have to be normalized.
| Bit 63 of `zSig' must be zero, and `zExp' must be 1 less than the ``true''
| floating-point exponent.
*----------------------------------------------------------------------------*/

static float64
normalizeRoundAndPackFloat64(flag zSign, int16 zExp, bits64 zSig)
{
    int8 shiftCount;

    shiftCount = countLeadingZeros64(zSig) - 1;
    return roundAndPackFloat64(zSign, zExp - shiftCount, zSig << shiftCount);
}

#ifdef FLOATX80

/*----------------------------------------------------------------------------
| Normalizes the subnormal extended double-precision floating-point value
| represented by the denormalized significand `aSig'.  The normalized exponent
| and significand are stored at the locations pointed to by `zExpPtr' and
| `zSigPtr', respectively.
*----------------------------------------------------------------------------*/

static void
normalizeFloatx80Subnormal(bits64 aSig, int32* zExpPtr, bits64* zSigPtr)
{
    int8 shiftCount;

    shiftCount = countLeadingZeros64(aSig);
    *zSigPtr = aSig << shiftCount;
    *zExpPtr = 1 - shiftCount;
}

/*----------------------------------------------------------------------------
| Takes an abstract floating-point value having sign `zSign', exponent `zExp',
| and extended significand formed by the concatenation of `zSig0' and `zSig1',
| and returns the proper extended double-precision floating-point value
| corresponding to the abstract input.  Ordinarily, the abstract value is
| rounded and packed into the extended double-precision format, with the
| inexact exception raised if the abstract input cannot be represented
| exactly.  However, if the abstract value is too large, the overflow and
| inexact exceptions are raised and an infinity or maximal finite value is
| returned.  If the abstract value is too small, the input value is rounded to
| a subnormal number, and the underflow and inexact exceptions are raised if
| the abstract input cannot be represented exactly as a subnormal extended
| double-precision floating-point number.
|     If `roundingPrecision' is 32 or 64, the result is rounded to the same
| number of bits as single or double precision, respectively.  Otherwise, the
| result is rounded to the full precision of the extended double-precision
| format.
|     The input significand must be normalized or smaller.  If the input
| significand is not normalized, `zExp' must be 0; in that case, the result
| returned is a subnormal number, and it must not require rounding.  The
| handling of underflow and overflow follows the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

// roundAndPackFloatx80 is now also used in fyl2x.c

/* static */ floatx80
roundAndPackFloatx80(
    int8 roundingPrecision, flag zSign, int32 zExp, bits64 zSig0, bits64 zSig1)
{
    int8 roundingMode;
    flag roundNearestEven, increment, isTiny;
    int64 roundIncrement, roundMask, roundBits;

    roundingMode = float_rounding_mode;
    roundNearestEven = (roundingMode == float_round_nearest_even);
    if (roundingPrecision == 80) {
        goto precision80;
    }
    if (roundingPrecision == 64) {
        roundIncrement = LIT64(0x0000000000000400);
        roundMask = LIT64(0x00000000000007FF);
    } else if (roundingPrecision == 32) {
        roundIncrement = LIT64(0x0000008000000000);
        roundMask = LIT64(0x000000FFFFFFFFFF);
    } else {
        goto precision80;
    }
    zSig0 |= (zSig1 != 0);
    if (!roundNearestEven) {
        if (roundingMode == float_round_to_zero) {
            roundIncrement = 0;
        } else {
            roundIncrement = roundMask;
            if (zSign) {
                if (roundingMode == float_round_up) {
                    roundIncrement = 0;
                }
            } else {
                if (roundingMode == float_round_down) {
                    roundIncrement = 0;
                }
            }
        }
    }
    roundBits = zSig0 & roundMask;
    if (0x7FFD <= (bits32)(zExp - 1)) {
        if ((0x7FFE < zExp) || ((zExp == 0x7FFE) && (zSig0 + roundIncrement < zSig0))) {
            goto overflow;
        }
        if (zExp <= 0) {
            isTiny =
                (float_detect_tininess == float_tininess_before_rounding) || (zExp < 0) || (zSig0 <= zSig0 + roundIncrement);
            shift64RightJamming(zSig0, 1 - zExp, &zSig0);
            zExp = 0;
            roundBits = zSig0 & roundMask;
            if (isTiny && roundBits) {
                float_raise(float_flag_underflow);
            }
            if (roundBits) {
                float_exception_flags |= float_flag_inexact;
            }
            zSig0 += roundIncrement;
            if ((sbits64)zSig0 < 0) {
                zExp = 1;
            }
            roundIncrement = roundMask + 1;
            if (roundNearestEven && (roundBits << 1 == roundIncrement)) {
                roundMask |= roundIncrement;
            }
            zSig0 &= ~roundMask;
            return packFloatx80(zSign, zExp, zSig0);
        }
    }
    if (roundBits) {
        float_exception_flags |= float_flag_inexact;
    }
    zSig0 += roundIncrement;
    if (zSig0 < (bits64)roundIncrement) {
        ++zExp;
        zSig0 = LIT64(0x8000000000000000);
    }
    roundIncrement = roundMask + 1;
    if (roundNearestEven && (roundBits << 1 == roundIncrement)) {
        roundMask |= roundIncrement;
    }
    zSig0 &= ~roundMask;
    if (zSig0 == 0) {
        zExp = 0;
    }
    return packFloatx80(zSign, zExp, zSig0);
precision80:
    increment = ((sbits64)zSig1 < 0);
    if (!roundNearestEven) {
        if (roundingMode == float_round_to_zero) {
            increment = 0;
        } else {
            if (zSign) {
                increment = (roundingMode == float_round_down) && zSig1;
            } else {
                increment = (roundingMode == float_round_up) && zSig1;
            }
        }
    }
    if (0x7FFD <= (bits32)(zExp - 1)) {
        if ((0x7FFE < zExp) || ((zExp == 0x7FFE) && (zSig0 == LIT64(0xFFFFFFFFFFFFFFFF)) && increment)) {
            roundMask = 0;
        overflow:
            float_raise(float_flag_overflow | float_flag_inexact);
            if ((roundingMode == float_round_to_zero) || (zSign && (roundingMode == float_round_up)) || (!zSign && (roundingMode == float_round_down))) {
                return packFloatx80(zSign, 0x7FFE, ~roundMask);
            }
            return packFloatx80(zSign, 0x7FFF, LIT64(0x8000000000000000));
        }
        if (zExp <= 0) {
            isTiny =
                (float_detect_tininess == float_tininess_before_rounding) || (zExp < 0) || !increment || (zSig0 < LIT64(0xFFFFFFFFFFFFFFFF));
            shift64ExtraRightJamming(zSig0, zSig1, 1 - zExp, &zSig0, &zSig1);
            zExp = 0;
            if (isTiny && zSig1) {
                float_raise(float_flag_underflow);
            }
            if (zSig1) {
                float_exception_flags |= float_flag_inexact;
            }
            if (roundNearestEven) {
                increment = ((sbits64)zSig1 < 0);
            } else {
                if (zSign) {
                    increment = (roundingMode == float_round_down) && zSig1;
                } else {
                    increment = (roundingMode == float_round_up) && zSig1;
                }
            }
            if (increment) {
                ++zSig0;
                zSig0 &=
                    ~(((bits64)(zSig1 << 1) == 0) & roundNearestEven);
                if ((sbits64)zSig0 < 0) {
                    zExp = 1;
                }
            }
            return packFloatx80(zSign, zExp, zSig0);
        }
    }
    if (zSig1) {
        float_exception_flags |= float_flag_inexact;
    }
    if (increment) {
        ++zSig0;
        if (zSig0 == 0) {
            ++zExp;
            zSig0 = LIT64(0x8000000000000000);
        } else {
            zSig0 &= ~(((bits64)(zSig1 << 1) == 0) & roundNearestEven);
        }
    } else {
        if (zSig0 == 0) {
            zExp = 0;
        }
    }
    return packFloatx80(zSign, zExp, zSig0);
}

/*----------------------------------------------------------------------------
| Takes an abstract floating-point value having sign `zSign', exponent
| `zExp', and significand formed by the concatenation of `zSig0' and `zSig1',
| and returns the proper extended double-precision floating-point value
| corresponding to the abstract input.  This routine is just like
| `roundAndPackFloatx80' except that the input significand does not have to be
| normalized.
*----------------------------------------------------------------------------*/

static floatx80
normalizeRoundAndPackFloatx80(
    int8 roundingPrecision, flag zSign, int32 zExp, bits64 zSig0, bits64 zSig1)
{
    int8 shiftCount;

    if (zSig0 == 0) {
        zSig0 = zSig1;
        zSig1 = 0;
        zExp -= 64;
    }
    shiftCount = countLeadingZeros64(zSig0);
    shortShift128Left(zSig0, zSig1, shiftCount, &zSig0, &zSig1);
    zExp -= shiftCount;
    return roundAndPackFloatx80(roundingPrecision, zSign, zExp, zSig0, zSig1);
}

#endif

#ifdef FLOAT128

/*----------------------------------------------------------------------------
| Returns the least-significant 64 fraction bits of the quadruple-precision
| floating-point value `a'.
*----------------------------------------------------------------------------*/

static inline bits64 extractFloat128Frac1(float128 a)
{
    return a.low;
}

/*----------------------------------------------------------------------------
| Returns the most-significant 48 fraction bits of the quadruple-precision
| floating-point value `a'.
*----------------------------------------------------------------------------*/

static inline bits64 extractFloat128Frac0(float128 a)
{
    return a.high & LIT64(0x0000FFFFFFFFFFFF);
}

/*----------------------------------------------------------------------------
| Returns the exponent bits of the quadruple-precision floating-point value
| `a'.
*----------------------------------------------------------------------------*/

static inline int32 extractFloat128Exp(float128 a)
{
    return (a.high >> 48) & 0x7FFF;
}

/*----------------------------------------------------------------------------
| Returns the sign bit of the quadruple-precision floating-point value `a'.
*----------------------------------------------------------------------------*/

static inline flag extractFloat128Sign(float128 a)
{
    return a.high >> 63;
}

/*----------------------------------------------------------------------------
| Normalizes the subnormal quadruple-precision floating-point value
| represented by the denormalized significand formed by the concatenation of
| `aSig0' and `aSig1'.  The normalized exponent is stored at the location
| pointed to by `zExpPtr'.  The most significant 49 bits of the normalized
| significand are stored at the location pointed to by `zSig0Ptr', and the
| least significant 64 bits of the normalized significand are stored at the
| location pointed to by `zSig1Ptr'.
*----------------------------------------------------------------------------*/

static void
normalizeFloat128Subnormal(
    bits64 aSig0,
    bits64 aSig1,
    int32* zExpPtr,
    bits64* zSig0Ptr,
    bits64* zSig1Ptr)
{
    int8 shiftCount;

    if (aSig0 == 0) {
        shiftCount = countLeadingZeros64(aSig1) - 15;
        if (shiftCount < 0) {
            *zSig0Ptr = aSig1 >> (-shiftCount);
            *zSig1Ptr = aSig1 << (shiftCount & 63);
        } else {
            *zSig0Ptr = aSig1 << shiftCount;
            *zSig1Ptr = 0;
        }
        *zExpPtr = -shiftCount - 63;
    } else {
        shiftCount = countLeadingZeros64(aSig0) - 15;
        shortShift128Left(aSig0, aSig1, shiftCount, zSig0Ptr, zSig1Ptr);
        *zExpPtr = 1 - shiftCount;
    }
}

#endif

/*----------------------------------------------------------------------------
| Returns the result of converting the 32-bit two's complement integer `a'
| to the single-precision floating-point format.  The conversion is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float32 int32_to_float32(int32 a)
{
    flag zSign;

    if (a == 0) {
        return 0;
    }
    if (a == (sbits32)0x80000000) {
        return packFloat32(1, 0x9E, 0);
    }
    zSign = (a < 0);
    return normalizeRoundAndPackFloat32(zSign, 0x9C, zSign ? -a : a);
}

/*----------------------------------------------------------------------------
| Returns the result of converting the 32-bit two's complement integer `a'
| to the double-precision floating-point format.  The conversion is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float64 int32_to_float64(int32 a)
{
    flag zSign;
    uint32 absA;
    int8 shiftCount;
    bits64 zSig;

    if (a == 0) {
        return 0;
    }
    zSign = (a < 0);
    absA = zSign ? -a : a;
    shiftCount = countLeadingZeros32(absA) + 21;
    zSig = absA;
    return packFloat64(zSign, 0x432 - shiftCount, zSig << shiftCount);
}

#ifdef FLOATX80

/*----------------------------------------------------------------------------
| Returns the result of converting the 32-bit two's complement integer `a'
| to the extended double-precision floating-point format.  The conversion
| is performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

floatx80 int32_to_floatx80(int32 a)
{
    flag zSign;
    uint32 absA;
    int8 shiftCount;
    bits64 zSig;

    if (a == 0) {
        return packFloatx80(0, 0, 0);
    }
    zSign = (a < 0);
    absA = zSign ? -a : a;
    shiftCount = countLeadingZeros32(absA) + 32;
    zSig = absA;
    return packFloatx80(zSign, 0x403E - shiftCount, zSig << shiftCount);
}

#endif

#ifdef FLOAT128

/*----------------------------------------------------------------------------
| Returns the result of converting the 32-bit two's complement integer `a' to
| the quadruple-precision floating-point format.  The conversion is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float128 int32_to_float128(int32 a)
{
    flag zSign;
    uint32 absA;
    int8 shiftCount;
    bits64 zSig0;

    if (a == 0) {
        return packFloat128(0, 0, 0, 0);
    }
    zSign = (a < 0);
    absA = zSign ? -a : a;
    shiftCount = countLeadingZeros32(absA) + 17;
    zSig0 = absA;
    return packFloat128(zSign, 0x402E - shiftCount, zSig0 << shiftCount, 0);
}

#endif

/*----------------------------------------------------------------------------
| Returns the result of converting the 64-bit two's complement integer `a'
| to the single-precision floating-point format.  The conversion is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float32 int64_to_float32(int64 a)
{
    flag zSign;
    uint64 absA;
    int8 shiftCount;
    //    bits32 zSig;

    if (a == 0) {
        return 0;
    }
    zSign = (a < 0);
    absA = zSign ? -a : a;
    shiftCount = countLeadingZeros64(absA) - 40;
    if (0 <= shiftCount) {
        return packFloat32(zSign, 0x95 - shiftCount, absA << shiftCount);
    } else {
        shiftCount += 7;
        if (shiftCount < 0) {
            shift64RightJamming(absA, -shiftCount, &absA);
        } else {
            absA <<= shiftCount;
        }
        return roundAndPackFloat32(zSign, 0x9C - shiftCount, absA);
    }
}

/*----------------------------------------------------------------------------
| Returns the result of converting the 64-bit two's complement integer `a'
| to the double-precision floating-point format.  The conversion is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float64 int64_to_float64(int64 a)
{
    flag zSign;

    if (a == 0) {
        return 0;
    }
    if (a == (sbits64)LIT64(0x8000000000000000)) {
        return packFloat64(1, 0x43E, 0);
    }
    zSign = (a < 0);
    return normalizeRoundAndPackFloat64(zSign, 0x43C, zSign ? -a : a);
}

#ifdef FLOATX80

/*----------------------------------------------------------------------------
| Returns the result of converting the 64-bit two's complement integer `a'
| to the extended double-precision floating-point format.  The conversion
| is performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

floatx80 int64_to_floatx80(int64 a)
{
    flag zSign;
    uint64 absA;
    int8 shiftCount;

    if (a == 0) {
        return packFloatx80(0, 0, 0);
    }
    zSign = (a < 0);
    absA = zSign ? -a : a;
    shiftCount = countLeadingZeros64(absA);
    return packFloatx80(zSign, 0x403E - shiftCount, absA << shiftCount);
}

#endif

#ifdef FLOAT128

/*----------------------------------------------------------------------------
| Returns the result of converting the 64-bit two's complement integer `a' to
| the quadruple-precision floating-point format.  The conversion is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float128 int64_to_float128(int64 a)
{
    flag zSign;
    uint64 absA;
    int8 shiftCount;
    int32 zExp;
    bits64 zSig0, zSig1;

    if (a == 0) {
        return packFloat128(0, 0, 0, 0);
    }
    zSign = (a < 0);
    absA = zSign ? -a : a;
    shiftCount = countLeadingZeros64(absA) + 49;
    zExp = 0x406E - shiftCount;
    if (64 <= shiftCount) {
        zSig1 = 0;
        zSig0 = absA;
        shiftCount -= 64;
    } else {
        zSig1 = absA;
        zSig0 = 0;
    }
    shortShift128Left(zSig0, zSig1, shiftCount, &zSig0, &zSig1);
    return packFloat128(zSign, zExp, zSig0, zSig1);
}

#endif

/*----------------------------------------------------------------------------
| Returns the result of converting the single-precision floating-point value
| `a' to the 32-bit two's complement integer format.  The conversion is
| performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic---which means in particular that the conversion is rounded
| according to the current rounding mode.  If `a' is a NaN, the largest
| positive integer is returned.  Otherwise, if the conversion overflows, the
| largest integer with the same sign as `a' is returned.
*----------------------------------------------------------------------------*/

int32 float32_to_int32(float32 a)
{
    flag aSign;
    int16 aExp, shiftCount;
    bits32 aSig;
    bits64 aSig64;

    aSig = extractFloat32Frac(a);
    aExp = extractFloat32Exp(a);
    aSign = extractFloat32Sign(a);
    if ((aExp == 0xFF) && aSig) {
        aSign = 0;
    }
    if (aExp) {
        aSig |= 0x00800000;
    }
    shiftCount = 0xAF - aExp;
    aSig64 = aSig;
    aSig64 <<= 32;
    if (0 < shiftCount) {
        shift64RightJamming(aSig64, shiftCount, &aSig64);
    }
    return roundAndPackInt32(aSign, aSig64);
}

/*----------------------------------------------------------------------------
| Returns the result of converting the single-precision floating-point value
| `a' to the 32-bit two's complement integer format.  The conversion is
| performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic, except that the conversion is always rounded toward zero.
| If `a' is a NaN, the largest positive integer is returned.  Otherwise, if
| the conversion overflows, the largest integer with the same sign as `a' is
| returned.
*----------------------------------------------------------------------------*/

int32 float32_to_int32_round_to_zero(float32 a)
{
    flag aSign;
    int16 aExp, shiftCount;
    bits32 aSig;
    int32 z;

    aSig = extractFloat32Frac(a);
    aExp = extractFloat32Exp(a);
    aSign = extractFloat32Sign(a);
    shiftCount = aExp - 0x9E;
    if (0 <= shiftCount) {
        if (a != 0xCF000000) {
            float_raise(float_flag_invalid);
            if (!aSign || ((aExp == 0xFF) && aSig)) {
                return 0x7FFFFFFF;
            }
        }
        return (sbits32)0x80000000;
    } else if (aExp <= 0x7E) {
        if (aExp | aSig) {
            float_exception_flags |= float_flag_inexact;
        }
        return 0;
    }
    aSig = (aSig | 0x00800000) << 8;
    z = aSig >> (-shiftCount);
    if ((bits32)(aSig << (shiftCount & 31))) {
        float_exception_flags |= float_flag_inexact;
    }
    if (aSign) {
        z = -z;
    }
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of converting the single-precision floating-point value
| `a' to the 64-bit two's complement integer format.  The conversion is
| performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic---which means in particular that the conversion is rounded
| according to the current rounding mode.  If `a' is a NaN, the largest
| positive integer is returned.  Otherwise, if the conversion overflows, the
| largest integer with the same sign as `a' is returned.
*----------------------------------------------------------------------------*/

int64 float32_to_int64(float32 a)
{
    flag aSign;
    int16 aExp, shiftCount;
    bits32 aSig;
    bits64 aSig64, aSigExtra;

    aSig = extractFloat32Frac(a);
    aExp = extractFloat32Exp(a);
    aSign = extractFloat32Sign(a);
    shiftCount = 0xBE - aExp;
    if (shiftCount < 0) {
        float_raise(float_flag_invalid);
        if (!aSign || ((aExp == 0xFF) && aSig)) {
            return LIT64(0x7FFFFFFFFFFFFFFF);
        }
        return (sbits64)LIT64(0x8000000000000000);
    }
    if (aExp) {
        aSig |= 0x00800000;
    }
    aSig64 = aSig;
    aSig64 <<= 40;
    shift64ExtraRightJamming(aSig64, 0, shiftCount, &aSig64, &aSigExtra);
    return roundAndPackInt64(aSign, aSig64, aSigExtra);
}

/*----------------------------------------------------------------------------
| Returns the result of converting the single-precision floating-point value
| `a' to the 64-bit two's complement integer format.  The conversion is
| performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic, except that the conversion is always rounded toward zero.  If
| `a' is a NaN, the largest positive integer is returned.  Otherwise, if the
| conversion overflows, the largest integer with the same sign as `a' is
| returned.
*----------------------------------------------------------------------------*/

int64 float32_to_int64_round_to_zero(float32 a)
{
    flag aSign;
    int16 aExp, shiftCount;
    bits32 aSig;
    bits64 aSig64;
    int64 z;

    aSig = extractFloat32Frac(a);
    aExp = extractFloat32Exp(a);
    aSign = extractFloat32Sign(a);
    shiftCount = aExp - 0xBE;
    if (0 <= shiftCount) {
        if (a != 0xDF000000) {
            float_raise(float_flag_invalid);
            if (!aSign || ((aExp == 0xFF) && aSig)) {
                return LIT64(0x7FFFFFFFFFFFFFFF);
            }
        }
        return (sbits64)LIT64(0x8000000000000000);
    } else if (aExp <= 0x7E) {
        if (aExp | aSig) {
            float_exception_flags |= float_flag_inexact;
        }
        return 0;
    }
    aSig64 = aSig | 0x00800000;
    aSig64 <<= 40;
    z = aSig64 >> (-shiftCount);
    if ((bits64)(aSig64 << (shiftCount & 63))) {
        float_exception_flags |= float_flag_inexact;
    }
    if (aSign) {
        z = -z;
    }
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of converting the single-precision floating-point value
| `a' to the double-precision floating-point format.  The conversion is
| performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

float64 float32_to_float64(float32 a)
{
    flag aSign;
    int16 aExp;
    bits32 aSig;

    aSig = extractFloat32Frac(a);
    aExp = extractFloat32Exp(a);
    aSign = extractFloat32Sign(a);
    if (aExp == 0xFF) {
        if (aSig) {
            return commonNaNToFloat64(float32ToCommonNaN(a));
        }
        return packFloat64(aSign, 0x7FF, 0);
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return packFloat64(aSign, 0, 0);
        }
        normalizeFloat32Subnormal(aSig, &aExp, &aSig);
        --aExp;
    }
    return packFloat64(aSign, aExp + 0x380, ((bits64)aSig) << 29);
}

#ifdef FLOATX80

/*----------------------------------------------------------------------------
| Returns the result of converting the single-precision floating-point value
| `a' to the extended double-precision floating-point format.  The conversion
| is performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

floatx80 float32_to_floatx80(float32 a)
{
    flag aSign;
    int16 aExp;
    bits32 aSig;

    aSig = extractFloat32Frac(a);
    aExp = extractFloat32Exp(a);
    aSign = extractFloat32Sign(a);
    if (aExp == 0xFF) {
        if (aSig) {
            return commonNaNToFloatx80(float32ToCommonNaN(a));
        }
        return packFloatx80(aSign, 0x7FFF, LIT64(0x8000000000000000));
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return packFloatx80(aSign, 0, 0);
        }
        normalizeFloat32Subnormal(aSig, &aExp, &aSig);
    }
    aSig |= 0x00800000;
    return packFloatx80(aSign, aExp + 0x3F80, ((bits64)aSig) << 40);
}

#endif

#ifdef FLOAT128

/*----------------------------------------------------------------------------
| Returns the result of converting the single-precision floating-point value
| `a' to the double-precision floating-point format.  The conversion is
| performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

float128 float32_to_float128(float32 a)
{
    flag aSign;
    int16 aExp;
    bits32 aSig;

    aSig = extractFloat32Frac(a);
    aExp = extractFloat32Exp(a);
    aSign = extractFloat32Sign(a);
    if (aExp == 0xFF) {
        if (aSig) {
            return commonNaNToFloat128(float32ToCommonNaN(a));
        }
        return packFloat128(aSign, 0x7FFF, 0, 0);
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return packFloat128(aSign, 0, 0, 0);
        }
        normalizeFloat32Subnormal(aSig, &aExp, &aSig);
        --aExp;
    }
    return packFloat128(aSign, aExp + 0x3F80, ((bits64)aSig) << 25, 0);
}

#endif

/*----------------------------------------------------------------------------
| Rounds the single-precision floating-point value `a' to an integer, and
| returns the result as a single-precision floating-point value.  The
| operation is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float32 float32_round_to_int(float32 a)
{
    flag aSign;
    int16 aExp;
    bits32 lastBitMask, roundBitsMask;
    int8 roundingMode;
    float32 z;

    aExp = extractFloat32Exp(a);
    if (0x96 <= aExp) {
        if ((aExp == 0xFF) && extractFloat32Frac(a)) {
            return propagateFloat32NaN(a, a);
        }
        return a;
    }
    if (aExp <= 0x7E) {
        if ((bits32)(a << 1) == 0) {
            return a;
        }
        float_exception_flags |= float_flag_inexact;
        aSign = extractFloat32Sign(a);
        switch (float_rounding_mode) {
            case float_round_nearest_even:
                if ((aExp == 0x7E) && extractFloat32Frac(a)) {
                    return packFloat32(aSign, 0x7F, 0);
                }
                break;
            case float_round_down:
                return aSign ? 0xBF800000 : 0;
            case float_round_up:
                return aSign ? 0x80000000 : 0x3F800000;
        }
        return packFloat32(aSign, 0, 0);
    }
    lastBitMask = 1;
    lastBitMask <<= 0x96 - aExp;
    roundBitsMask = lastBitMask - 1;
    z = a;
    roundingMode = float_rounding_mode;
    if (roundingMode == float_round_nearest_even) {
        z += lastBitMask >> 1;
        if ((z & roundBitsMask) == 0) {
            z &= ~lastBitMask;
        }
    } else if (roundingMode != float_round_to_zero) {
        if (extractFloat32Sign(z) ^ (roundingMode == float_round_up)) {
            z += roundBitsMask;
        }
    }
    z &= ~roundBitsMask;
    if (z != a) {
        float_exception_flags |= float_flag_inexact;
    }
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of adding the absolute values of the single-precision
| floating-point values `a' and `b'.  If `zSign' is 1, the sum is negated
| before being returned.  `zSign' is ignored if the result is a NaN.
| The addition is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

static float32 addFloat32Sigs(float32 a, float32 b, flag zSign)
{
    int16 aExp, bExp, zExp;
    bits32 aSig, bSig, zSig;
    int16 expDiff;

    aSig = extractFloat32Frac(a);
    aExp = extractFloat32Exp(a);
    bSig = extractFloat32Frac(b);
    bExp = extractFloat32Exp(b);
    expDiff = aExp - bExp;
    aSig <<= 6;
    bSig <<= 6;
    if (0 < expDiff) {
        if (aExp == 0xFF) {
            if (aSig) {
                return propagateFloat32NaN(a, b);
            }
            return a;
        }
        if (bExp == 0) {
            --expDiff;
        } else {
            bSig |= 0x20000000;
        }
        shift32RightJamming(bSig, expDiff, &bSig);
        zExp = aExp;
    } else if (expDiff < 0) {
        if (bExp == 0xFF) {
            if (bSig) {
                return propagateFloat32NaN(a, b);
            }
            return packFloat32(zSign, 0xFF, 0);
        }
        if (aExp == 0) {
            ++expDiff;
        } else {
            aSig |= 0x20000000;
        }
        shift32RightJamming(aSig, -expDiff, &aSig);
        zExp = bExp;
    } else {
        if (aExp == 0xFF) {
            if (aSig | bSig) {
                return propagateFloat32NaN(a, b);
            }
            return a;
        }
        if (aExp == 0) {
            return packFloat32(zSign, 0, (aSig + bSig) >> 6);
        }
        zSig = 0x40000000 + aSig + bSig;
        zExp = aExp;
        goto roundAndPack;
    }
    aSig |= 0x20000000;
    zSig = (aSig + bSig) << 1;
    --zExp;
    if ((sbits32)zSig < 0) {
        zSig = aSig + bSig;
        ++zExp;
    }
roundAndPack:
    return roundAndPackFloat32(zSign, zExp, zSig);
}

/*----------------------------------------------------------------------------
| Returns the result of subtracting the absolute values of the single-
| precision floating-point values `a' and `b'.  If `zSign' is 1, the
| difference is negated before being returned.  `zSign' is ignored if the
| result is a NaN.  The subtraction is performed according to the IEC/IEEE
| Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

static float32 subFloat32Sigs(float32 a, float32 b, flag zSign)
{
    int16 aExp, bExp, zExp;
    bits32 aSig, bSig, zSig;
    int16 expDiff;

    aSig = extractFloat32Frac(a);
    aExp = extractFloat32Exp(a);
    bSig = extractFloat32Frac(b);
    bExp = extractFloat32Exp(b);
    expDiff = aExp - bExp;
    aSig <<= 7;
    bSig <<= 7;
    if (0 < expDiff) {
        goto aExpBigger;
    }
    if (expDiff < 0) {
        goto bExpBigger;
    }
    if (aExp == 0xFF) {
        if (aSig | bSig) {
            return propagateFloat32NaN(a, b);
        }
        float_raise(float_flag_invalid);
        return float32_default_nan;
    }
    if (aExp == 0) {
        aExp = 1;
        bExp = 1;
    }
    if (bSig < aSig) {
        goto aBigger;
    }
    if (aSig < bSig) {
        goto bBigger;
    }
    return packFloat32(float_rounding_mode == float_round_down, 0, 0);
bExpBigger:
    if (bExp == 0xFF) {
        if (bSig) {
            return propagateFloat32NaN(a, b);
        }
        return packFloat32(zSign ^ 1, 0xFF, 0);
    }
    if (aExp == 0) {
        ++expDiff;
    } else {
        aSig |= 0x40000000;
    }
    shift32RightJamming(aSig, -expDiff, &aSig);
    bSig |= 0x40000000;
bBigger:
    zSig = bSig - aSig;
    zExp = bExp;
    zSign ^= 1;
    goto normalizeRoundAndPack;
aExpBigger:
    if (aExp == 0xFF) {
        if (aSig) {
            return propagateFloat32NaN(a, b);
        }
        return a;
    }
    if (bExp == 0) {
        --expDiff;
    } else {
        bSig |= 0x40000000;
    }
    shift32RightJamming(bSig, expDiff, &bSig);
    aSig |= 0x40000000;
aBigger:
    zSig = aSig - bSig;
    zExp = aExp;
normalizeRoundAndPack:
    --zExp;
    return normalizeRoundAndPackFloat32(zSign, zExp, zSig);
}

/*----------------------------------------------------------------------------
| Returns the result of adding the single-precision floating-point values `a'
| and `b'.  The operation is performed according to the IEC/IEEE Standard for
| Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float32 float32_add(float32 a, float32 b)
{
    flag aSign, bSign;

    aSign = extractFloat32Sign(a);
    bSign = extractFloat32Sign(b);
    if (aSign == bSign) {
        return addFloat32Sigs(a, b, aSign);
    } else {
        return subFloat32Sigs(a, b, aSign);
    }
}

/*----------------------------------------------------------------------------
| Returns the result of subtracting the single-precision floating-point values
| `a' and `b'.  The operation is performed according to the IEC/IEEE Standard
| for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float32 float32_sub(float32 a, float32 b)
{
    flag aSign, bSign;

    aSign = extractFloat32Sign(a);
    bSign = extractFloat32Sign(b);
    if (aSign == bSign) {
        return subFloat32Sigs(a, b, aSign);
    } else {
        return addFloat32Sigs(a, b, aSign);
    }
}

/*----------------------------------------------------------------------------
| Returns the result of multiplying the single-precision floating-point values
| `a' and `b'.  The operation is performed according to the IEC/IEEE Standard
| for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float32 float32_mul(float32 a, float32 b)
{
    flag aSign, bSign, zSign;
    int16 aExp, bExp, zExp;
    bits32 aSig, bSig;
    bits64 zSig64;
    bits32 zSig;

    aSig = extractFloat32Frac(a);
    aExp = extractFloat32Exp(a);
    aSign = extractFloat32Sign(a);
    bSig = extractFloat32Frac(b);
    bExp = extractFloat32Exp(b);
    bSign = extractFloat32Sign(b);
    zSign = aSign ^ bSign;
    if (aExp == 0xFF) {
        if (aSig || ((bExp == 0xFF) && bSig)) {
            return propagateFloat32NaN(a, b);
        }
        if ((bExp | bSig) == 0) {
            float_raise(float_flag_invalid);
            return float32_default_nan;
        }
        return packFloat32(zSign, 0xFF, 0);
    }
    if (bExp == 0xFF) {
        if (bSig) {
            return propagateFloat32NaN(a, b);
        }
        if ((aExp | aSig) == 0) {
            float_raise(float_flag_invalid);
            return float32_default_nan;
        }
        return packFloat32(zSign, 0xFF, 0);
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return packFloat32(zSign, 0, 0);
        }
        normalizeFloat32Subnormal(aSig, &aExp, &aSig);
    }
    if (bExp == 0) {
        if (bSig == 0) {
            return packFloat32(zSign, 0, 0);
        }
        normalizeFloat32Subnormal(bSig, &bExp, &bSig);
    }
    zExp = aExp + bExp - 0x7F;
    aSig = (aSig | 0x00800000) << 7;
    bSig = (bSig | 0x00800000) << 8;
    shift64RightJamming(((bits64)aSig) * bSig, 32, &zSig64);
    zSig = zSig64;
    if (0 <= (sbits32)(zSig << 1)) {
        zSig <<= 1;
        --zExp;
    }
    return roundAndPackFloat32(zSign, zExp, zSig);
}

/*----------------------------------------------------------------------------
| Returns the result of dividing the single-precision floating-point value `a'
| by the corresponding value `b'.  The operation is performed according to the
| IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float32 float32_div(float32 a, float32 b)
{
    flag aSign, bSign, zSign;
    int16 aExp, bExp, zExp;
    bits32 aSig, bSig, zSig;

    aSig = extractFloat32Frac(a);
    aExp = extractFloat32Exp(a);
    aSign = extractFloat32Sign(a);
    bSig = extractFloat32Frac(b);
    bExp = extractFloat32Exp(b);
    bSign = extractFloat32Sign(b);
    zSign = aSign ^ bSign;
    if (aExp == 0xFF) {
        if (aSig) {
            return propagateFloat32NaN(a, b);
        }
        if (bExp == 0xFF) {
            if (bSig) {
                return propagateFloat32NaN(a, b);
            }
            float_raise(float_flag_invalid);
            return float32_default_nan;
        }
        return packFloat32(zSign, 0xFF, 0);
    }
    if (bExp == 0xFF) {
        if (bSig) {
            return propagateFloat32NaN(a, b);
        }
        return packFloat32(zSign, 0, 0);
    }
    if (bExp == 0) {
        if (bSig == 0) {
            if ((aExp | aSig) == 0) {
                float_raise(float_flag_invalid);
                return float32_default_nan;
            }
            float_raise(float_flag_divbyzero);
            return packFloat32(zSign, 0xFF, 0);
        }
        normalizeFloat32Subnormal(bSig, &bExp, &bSig);
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return packFloat32(zSign, 0, 0);
        }
        normalizeFloat32Subnormal(aSig, &aExp, &aSig);
    }
    zExp = aExp - bExp + 0x7D;
    aSig = (aSig | 0x00800000) << 7;
    bSig = (bSig | 0x00800000) << 8;
    if (bSig <= (aSig + aSig)) {
        aSig >>= 1;
        ++zExp;
    }
    zSig = (((bits64)aSig) << 32) / bSig;
    if ((zSig & 0x3F) == 0) {
        zSig |= ((bits64)bSig * zSig != ((bits64)aSig) << 32);
    }
    return roundAndPackFloat32(zSign, zExp, zSig);
}

/*----------------------------------------------------------------------------
| Returns the remainder of the single-precision floating-point value `a'
| with respect to the corresponding value `b'.  The operation is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float32 float32_rem(float32 a, float32 b)
{
    flag aSign, zSign;
    int16 aExp, bExp, expDiff;
    bits32 aSig, bSig;
    bits32 q;
    bits64 aSig64, bSig64, q64;
    bits32 alternateASig;
    sbits32 sigMean;

    aSig = extractFloat32Frac(a);
    aExp = extractFloat32Exp(a);
    aSign = extractFloat32Sign(a);
    bSig = extractFloat32Frac(b);
    bExp = extractFloat32Exp(b);
    //    bSign = extractFloat32Sign( b );
    if (aExp == 0xFF) {
        if (aSig || ((bExp == 0xFF) && bSig)) {
            return propagateFloat32NaN(a, b);
        }
        float_raise(float_flag_invalid);
        return float32_default_nan;
    }
    if (bExp == 0xFF) {
        if (bSig) {
            return propagateFloat32NaN(a, b);
        }
        return a;
    }
    if (bExp == 0) {
        if (bSig == 0) {
            float_raise(float_flag_invalid);
            return float32_default_nan;
        }
        normalizeFloat32Subnormal(bSig, &bExp, &bSig);
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return a;
        }
        normalizeFloat32Subnormal(aSig, &aExp, &aSig);
    }
    expDiff = aExp - bExp;
    aSig |= 0x00800000;
    bSig |= 0x00800000;
    if (expDiff < 32) {
        aSig <<= 8;
        bSig <<= 8;
        if (expDiff < 0) {
            if (expDiff < -1) {
                return a;
            }
            aSig >>= 1;
        }
        q = (bSig <= aSig);
        if (q) {
            aSig -= bSig;
        }
        if (0 < expDiff) {
            q = (((bits64)aSig) << 32) / bSig;
            q >>= 32 - expDiff;
            bSig >>= 2;
            aSig = ((aSig >> 1) << (expDiff - 1)) - bSig * q;
        } else {
            aSig >>= 2;
            bSig >>= 2;
        }
    } else {
        if (bSig <= aSig) {
            aSig -= bSig;
        }
        aSig64 = ((bits64)aSig) << 40;
        bSig64 = ((bits64)bSig) << 40;
        expDiff -= 64;
        while (0 < expDiff) {
            q64 = estimateDiv128To64(aSig64, 0, bSig64);
            q64 = (2 < q64) ? q64 - 2 : 0;
            aSig64 = (bits64)0 - ((bSig * q64) << 38);
            expDiff -= 62;
        }
        expDiff += 64;
        q64 = estimateDiv128To64(aSig64, 0, bSig64);
        q64 = (2 < q64) ? q64 - 2 : 0;
        q = q64 >> (64 - expDiff);
        bSig <<= 6;
        aSig = ((aSig64 >> 33) << (expDiff - 1)) - bSig * q;
    }
    do {
        alternateASig = aSig;
        ++q;
        aSig -= bSig;
    } while (0 <= (sbits32)aSig);
    sigMean = aSig + alternateASig;
    if ((sigMean < 0) || ((sigMean == 0) && (q & 1))) {
        aSig = alternateASig;
    }
    zSign = ((sbits32)aSig < 0);
    if (zSign) {
        aSig = (bits32)0 - aSig;
    }
    return normalizeRoundAndPackFloat32(aSign ^ zSign, bExp, aSig);
}

/*----------------------------------------------------------------------------
| Returns the square root of the single-precision floating-point value `a'.
| The operation is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float32 float32_sqrt(float32 a)
{
    flag aSign;
    int16 aExp, zExp;
    bits32 aSig, zSig;
    bits64 rem, term;

    aSig = extractFloat32Frac(a);
    aExp = extractFloat32Exp(a);
    aSign = extractFloat32Sign(a);
    if (aExp == 0xFF) {
        if (aSig) {
            return propagateFloat32NaN(a, 0);
        }
        if (!aSign) {
            return a;
        }
        float_raise(float_flag_invalid);
        return float32_default_nan;
    }
    if (aSign) {
        if ((aExp | aSig) == 0) {
            return a;
        }
        float_raise(float_flag_invalid);
        return float32_default_nan;
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return 0;
        }
        normalizeFloat32Subnormal(aSig, &aExp, &aSig);
    }
    zExp = ((aExp - 0x7F) >> 1) + 0x7E;
    aSig = (aSig | 0x00800000) << 8;
    zSig = estimateSqrt32(aExp, aSig) + 2;
    if ((zSig & 0x7F) <= 5) {
        if (zSig < 2) {
            zSig = 0x7FFFFFFF;
            goto roundAndPack;
        }
        aSig >>= aExp & 1;
        term = ((bits64)zSig) * zSig;
        rem = (((bits64)aSig) << 32) - term;
        while ((sbits64)rem < 0) {
            --zSig;
            rem += (((bits64)zSig) << 1) | 1;
        }
        zSig |= (rem != 0);
    }
    shift32RightJamming(zSig, 1, &zSig);
roundAndPack:
    return roundAndPackFloat32(0, zExp, zSig);
}

/*----------------------------------------------------------------------------
| Returns 1 if the single-precision floating-point value `a' is equal to
| the corresponding value `b', and 0 otherwise.  The comparison is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float32_eq(float32 a, float32 b)
{
    if (((extractFloat32Exp(a) == 0xFF) && extractFloat32Frac(a)) || ((extractFloat32Exp(b) == 0xFF) && extractFloat32Frac(b))) {
        if (float32_is_signaling_nan(a) || float32_is_signaling_nan(b)) {
            float_raise(float_flag_invalid);
        }
        return 0;
    }
    return (a == b) || ((bits32)((a | b) << 1) == 0);
}

/*----------------------------------------------------------------------------
| Returns 1 if the single-precision floating-point value `a' is less than
| or equal to the corresponding value `b', and 0 otherwise.  The comparison
| is performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

flag float32_le(float32 a, float32 b)
{
    flag aSign, bSign;

    if (((extractFloat32Exp(a) == 0xFF) && extractFloat32Frac(a)) || ((extractFloat32Exp(b) == 0xFF) && extractFloat32Frac(b))) {
        float_raise(float_flag_invalid);
        return 0;
    }
    aSign = extractFloat32Sign(a);
    bSign = extractFloat32Sign(b);
    if (aSign != bSign) {
        return aSign || ((bits32)((a | b) << 1) == 0);
    }
    return (a == b) || (aSign ^ (a < b));
}

/*----------------------------------------------------------------------------
| Returns 1 if the single-precision floating-point value `a' is less than
| the corresponding value `b', and 0 otherwise.  The comparison is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float32_lt(float32 a, float32 b)
{
    flag aSign, bSign;

    if (((extractFloat32Exp(a) == 0xFF) && extractFloat32Frac(a)) || ((extractFloat32Exp(b) == 0xFF) && extractFloat32Frac(b))) {
        float_raise(float_flag_invalid);
        return 0;
    }
    aSign = extractFloat32Sign(a);
    bSign = extractFloat32Sign(b);
    if (aSign != bSign) {
        return aSign && ((bits32)((a | b) << 1) != 0);
    }
    return (a != b) && (aSign ^ (a < b));
}

/*----------------------------------------------------------------------------
| Returns 1 if the single-precision floating-point value `a' is equal to
| the corresponding value `b', and 0 otherwise.  The invalid exception is
| raised if either operand is a NaN.  Otherwise, the comparison is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float32_eq_signaling(float32 a, float32 b)
{
    if (((extractFloat32Exp(a) == 0xFF) && extractFloat32Frac(a)) || ((extractFloat32Exp(b) == 0xFF) && extractFloat32Frac(b))) {
        float_raise(float_flag_invalid);
        return 0;
    }
    return (a == b) || ((bits32)((a | b) << 1) == 0);
}

/*----------------------------------------------------------------------------
| Returns 1 if the single-precision floating-point value `a' is less than or
| equal to the corresponding value `b', and 0 otherwise.  Quiet NaNs do not
| cause an exception.  Otherwise, the comparison is performed according to the
| IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float32_le_quiet(float32 a, float32 b)
{
    flag aSign, bSign;
    //    int16 aExp, bExp;

    if (((extractFloat32Exp(a) == 0xFF) && extractFloat32Frac(a)) || ((extractFloat32Exp(b) == 0xFF) && extractFloat32Frac(b))) {
        if (float32_is_signaling_nan(a) || float32_is_signaling_nan(b)) {
            float_raise(float_flag_invalid);
        }
        return 0;
    }
    aSign = extractFloat32Sign(a);
    bSign = extractFloat32Sign(b);
    if (aSign != bSign) {
        return aSign || ((bits32)((a | b) << 1) == 0);
    }
    return (a == b) || (aSign ^ (a < b));
}

/*----------------------------------------------------------------------------
| Returns 1 if the single-precision floating-point value `a' is less than
| the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an
| exception.  Otherwise, the comparison is performed according to the IEC/IEEE
| Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float32_lt_quiet(float32 a, float32 b)
{
    flag aSign, bSign;

    if (((extractFloat32Exp(a) == 0xFF) && extractFloat32Frac(a)) || ((extractFloat32Exp(b) == 0xFF) && extractFloat32Frac(b))) {
        if (float32_is_signaling_nan(a) || float32_is_signaling_nan(b)) {
            float_raise(float_flag_invalid);
        }
        return 0;
    }
    aSign = extractFloat32Sign(a);
    bSign = extractFloat32Sign(b);
    if (aSign != bSign) {
        return aSign && ((bits32)((a | b) << 1) != 0);
    }
    return (a != b) && (aSign ^ (a < b));
}

/*----------------------------------------------------------------------------
| Returns the result of converting the double-precision floating-point value
| `a' to the 32-bit two's complement integer format.  The conversion is
| performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic---which means in particular that the conversion is rounded
| according to the current rounding mode.  If `a' is a NaN, the largest
| positive integer is returned.  Otherwise, if the conversion overflows, the
| largest integer with the same sign as `a' is returned.
*----------------------------------------------------------------------------*/

int32 float64_to_int32(float64 a)
{
    flag aSign;
    int16 aExp, shiftCount;
    bits64 aSig;

    aSig = extractFloat64Frac(a);
    aExp = extractFloat64Exp(a);
    aSign = extractFloat64Sign(a);
    if ((aExp == 0x7FF) && aSig) {
        aSign = 0;
    }
    if (aExp) {
        aSig |= LIT64(0x0010000000000000);
    }
    shiftCount = 0x42C - aExp;
    if (0 < shiftCount) {
        shift64RightJamming(aSig, shiftCount, &aSig);
    }
    return roundAndPackInt32(aSign, aSig);
}

/*----------------------------------------------------------------------------
| Returns the result of converting the double-precision floating-point value
| `a' to the 32-bit two's complement integer format.  The conversion is
| performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic, except that the conversion is always rounded toward zero.
| If `a' is a NaN, the largest positive integer is returned.  Otherwise, if
| the conversion overflows, the largest integer with the same sign as `a' is
| returned.
*----------------------------------------------------------------------------*/

int32 float64_to_int32_round_to_zero(float64 a)
{
    flag aSign;
    int16 aExp, shiftCount;
    bits64 aSig, savedASig;
    int32 z;

    aSig = extractFloat64Frac(a);
    aExp = extractFloat64Exp(a);
    aSign = extractFloat64Sign(a);
    if (0x41E < aExp) {
        if ((aExp == 0x7FF) && aSig) {
            aSign = 0;
        }
        goto invalid;
    } else if (aExp < 0x3FF) {
        if (aExp || aSig) {
            float_exception_flags |= float_flag_inexact;
        }
        return 0;
    }
    aSig |= LIT64(0x0010000000000000);
    shiftCount = 0x433 - aExp;
    savedASig = aSig;
    aSig >>= shiftCount;
    z = aSig;
    if (aSign) {
        z = -z;
    }
    if ((z < 0) ^ aSign) {
    invalid:
        float_raise(float_flag_invalid);
        return aSign ? (sbits32)0x80000000 : 0x7FFFFFFF;
    }
    if ((aSig << shiftCount) != savedASig) {
        float_exception_flags |= float_flag_inexact;
    }
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of converting the double-precision floating-point value
| `a' to the 64-bit two's complement integer format.  The conversion is
| performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic---which means in particular that the conversion is rounded
| according to the current rounding mode.  If `a' is a NaN, the largest
| positive integer is returned.  Otherwise, if the conversion overflows, the
| largest integer with the same sign as `a' is returned.
*----------------------------------------------------------------------------*/

int64 float64_to_int64(float64 a)
{
    flag aSign;
    int16 aExp, shiftCount;
    bits64 aSig, aSigExtra;

    aSig = extractFloat64Frac(a);
    aExp = extractFloat64Exp(a);
    aSign = extractFloat64Sign(a);
    if (aExp) {
        aSig |= LIT64(0x0010000000000000);
    }
    shiftCount = 0x433 - aExp;
    if (shiftCount <= 0) {
        if (0x43E < aExp) {
            float_raise(float_flag_invalid);
            if (!aSign || ((aExp == 0x7FF) && (aSig != LIT64(0x0010000000000000)))) {
                return LIT64(0x7FFFFFFFFFFFFFFF);
            }
            return (sbits64)LIT64(0x8000000000000000);
        }
        aSigExtra = 0;
        aSig <<= -shiftCount;
    } else {
        shift64ExtraRightJamming(aSig, 0, shiftCount, &aSig, &aSigExtra);
    }
    return roundAndPackInt64(aSign, aSig, aSigExtra);
}

/*----------------------------------------------------------------------------
| Returns the result of converting the double-precision floating-point value
| `a' to the 64-bit two's complement integer format.  The conversion is
| performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic, except that the conversion is always rounded toward zero.
| If `a' is a NaN, the largest positive integer is returned.  Otherwise, if
| the conversion overflows, the largest integer with the same sign as `a' is
| returned.
*----------------------------------------------------------------------------*/

int64 float64_to_int64_round_to_zero(float64 a)
{
    flag aSign;
    int16 aExp, shiftCount;
    bits64 aSig;
    int64 z;

    aSig = extractFloat64Frac(a);
    aExp = extractFloat64Exp(a);
    aSign = extractFloat64Sign(a);
    if (aExp) {
        aSig |= LIT64(0x0010000000000000);
    }
    shiftCount = aExp - 0x433;
    if (0 <= shiftCount) {
        if (0x43E <= aExp) {
            if (a != LIT64(0xC3E0000000000000)) {
                float_raise(float_flag_invalid);
                if (!aSign || ((aExp == 0x7FF) && (aSig != LIT64(0x0010000000000000)))) {
                    return LIT64(0x7FFFFFFFFFFFFFFF);
                }
            }
            return (sbits64)LIT64(0x8000000000000000);
        }
        z = aSig << shiftCount;
    } else {
        if (aExp < 0x3FE) {
            if (aExp | aSig) {
                float_exception_flags |= float_flag_inexact;
            }
            return 0;
        }
        z = aSig >> (-shiftCount);
        if ((bits64)(aSig << (shiftCount & 63))) {
            float_exception_flags |= float_flag_inexact;
        }
    }
    if (aSign) {
        z = -z;
    }
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of converting the double-precision floating-point value
| `a' to the single-precision floating-point format.  The conversion is
| performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

float32 float64_to_float32(float64 a)
{
    flag aSign;
    int16 aExp;
    bits64 aSig;
    bits32 zSig;

    aSig = extractFloat64Frac(a);
    aExp = extractFloat64Exp(a);
    aSign = extractFloat64Sign(a);
    if (aExp == 0x7FF) {
        if (aSig) {
            return commonNaNToFloat32(float64ToCommonNaN(a));
        }
        return packFloat32(aSign, 0xFF, 0);
    }
    shift64RightJamming(aSig, 22, &aSig);
    zSig = aSig;
    if (aExp || zSig) {
        zSig |= 0x40000000;
        aExp -= 0x381;
    }
    return roundAndPackFloat32(aSign, aExp, zSig);
}

#ifdef FLOATX80

/*----------------------------------------------------------------------------
| Returns the result of converting the double-precision floating-point value
| `a' to the extended double-precision floating-point format.  The conversion
| is performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

floatx80 float64_to_floatx80(float64 a)
{
    flag aSign;
    int16 aExp;
    bits64 aSig;

    aSig = extractFloat64Frac(a);
    aExp = extractFloat64Exp(a);
    aSign = extractFloat64Sign(a);
    if (aExp == 0x7FF) {
        if (aSig) {
            return commonNaNToFloatx80(float64ToCommonNaN(a));
        }
        return packFloatx80(aSign, 0x7FFF, LIT64(0x8000000000000000));
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return packFloatx80(aSign, 0, 0);
        }
        normalizeFloat64Subnormal(aSig, &aExp, &aSig);
    }
    return packFloatx80(
        aSign, aExp + 0x3C00, (aSig | LIT64(0x0010000000000000)) << 11);
}

#endif

#ifdef FLOAT128

/*----------------------------------------------------------------------------
| Returns the result of converting the double-precision floating-point value
| `a' to the quadruple-precision floating-point format.  The conversion is
| performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

float128 float64_to_float128(float64 a)
{
    flag aSign;
    int16 aExp;
    bits64 aSig, zSig0, zSig1;

    aSig = extractFloat64Frac(a);
    aExp = extractFloat64Exp(a);
    aSign = extractFloat64Sign(a);
    if (aExp == 0x7FF) {
        if (aSig) {
            return commonNaNToFloat128(float64ToCommonNaN(a));
        }
        return packFloat128(aSign, 0x7FFF, 0, 0);
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return packFloat128(aSign, 0, 0, 0);
        }
        normalizeFloat64Subnormal(aSig, &aExp, &aSig);
        --aExp;
    }
    shift128Right(aSig, 0, 4, &zSig0, &zSig1);
    return packFloat128(aSign, aExp + 0x3C00, zSig0, zSig1);
}

#endif

/*----------------------------------------------------------------------------
| Rounds the double-precision floating-point value `a' to an integer, and
| returns the result as a double-precision floating-point value.  The
| operation is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float64 float64_round_to_int(float64 a)
{
    flag aSign;
    int16 aExp;
    bits64 lastBitMask, roundBitsMask;
    int8 roundingMode;
    float64 z;

    aExp = extractFloat64Exp(a);
    if (0x433 <= aExp) {
        if ((aExp == 0x7FF) && extractFloat64Frac(a)) {
            return propagateFloat64NaN(a, a);
        }
        return a;
    }
    if (aExp < 0x3FF) {
        if ((bits64)(a << 1) == 0) {
            return a;
        }
        float_exception_flags |= float_flag_inexact;
        aSign = extractFloat64Sign(a);
        switch (float_rounding_mode) {
            case float_round_nearest_even:
                if ((aExp == 0x3FE) && extractFloat64Frac(a)) {
                    return packFloat64(aSign, 0x3FF, 0);
                }
                break;
            case float_round_down:
                return aSign ? LIT64(0xBFF0000000000000) : 0;
            case float_round_up:
                return aSign ? LIT64(0x8000000000000000) : LIT64(0x3FF0000000000000);
        }
        return packFloat64(aSign, 0, 0);
    }
    lastBitMask = 1;
    lastBitMask <<= 0x433 - aExp;
    roundBitsMask = lastBitMask - 1;
    z = a;
    roundingMode = float_rounding_mode;
    if (roundingMode == float_round_nearest_even) {
        z += lastBitMask >> 1;
        if ((z & roundBitsMask) == 0) {
            z &= ~lastBitMask;
        }
    } else if (roundingMode != float_round_to_zero) {
        if (extractFloat64Sign(z) ^ (roundingMode == float_round_up)) {
            z += roundBitsMask;
        }
    }
    z &= ~roundBitsMask;
    if (z != a) {
        float_exception_flags |= float_flag_inexact;
    }
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of adding the absolute values of the double-precision
| floating-point values `a' and `b'.  If `zSign' is 1, the sum is negated
| before being returned.  `zSign' is ignored if the result is a NaN.
| The addition is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

static float64 addFloat64Sigs(float64 a, float64 b, flag zSign)
{
    int16 aExp, bExp, zExp;
    bits64 aSig, bSig, zSig;
    int16 expDiff;

    aSig = extractFloat64Frac(a);
    aExp = extractFloat64Exp(a);
    bSig = extractFloat64Frac(b);
    bExp = extractFloat64Exp(b);
    expDiff = aExp - bExp;
    aSig <<= 9;
    bSig <<= 9;
    if (0 < expDiff) {
        if (aExp == 0x7FF) {
            if (aSig) {
                return propagateFloat64NaN(a, b);
            }
            return a;
        }
        if (bExp == 0) {
            --expDiff;
        } else {
            bSig |= LIT64(0x2000000000000000);
        }
        shift64RightJamming(bSig, expDiff, &bSig);
        zExp = aExp;
    } else if (expDiff < 0) {
        if (bExp == 0x7FF) {
            if (bSig) {
                return propagateFloat64NaN(a, b);
            }
            return packFloat64(zSign, 0x7FF, 0);
        }
        if (aExp == 0) {
            ++expDiff;
        } else {
            aSig |= LIT64(0x2000000000000000);
        }
        shift64RightJamming(aSig, -expDiff, &aSig);
        zExp = bExp;
    } else {
        if (aExp == 0x7FF) {
            if (aSig | bSig) {
                return propagateFloat64NaN(a, b);
            }
            return a;
        }
        if (aExp == 0) {
            return packFloat64(zSign, 0, (aSig + bSig) >> 9);
        }
        zSig = LIT64(0x4000000000000000) + aSig + bSig;
        zExp = aExp;
        goto roundAndPack;
    }
    aSig |= LIT64(0x2000000000000000);
    zSig = (aSig + bSig) << 1;
    --zExp;
    if ((sbits64)zSig < 0) {
        zSig = aSig + bSig;
        ++zExp;
    }
roundAndPack:
    return roundAndPackFloat64(zSign, zExp, zSig);
}

/*----------------------------------------------------------------------------
| Returns the result of subtracting the absolute values of the double-
| precision floating-point values `a' and `b'.  If `zSign' is 1, the
| difference is negated before being returned.  `zSign' is ignored if the
| result is a NaN.  The subtraction is performed according to the IEC/IEEE
| Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

static float64 subFloat64Sigs(float64 a, float64 b, flag zSign)
{
    int16 aExp, bExp, zExp;
    bits64 aSig, bSig, zSig;
    int16 expDiff;

    aSig = extractFloat64Frac(a);
    aExp = extractFloat64Exp(a);
    bSig = extractFloat64Frac(b);
    bExp = extractFloat64Exp(b);
    expDiff = aExp - bExp;
    aSig <<= 10;
    bSig <<= 10;
    if (0 < expDiff) {
        goto aExpBigger;
    }
    if (expDiff < 0) {
        goto bExpBigger;
    }
    if (aExp == 0x7FF) {
        if (aSig | bSig) {
            return propagateFloat64NaN(a, b);
        }
        float_raise(float_flag_invalid);
        return float64_default_nan;
    }
    if (aExp == 0) {
        aExp = 1;
        bExp = 1;
    }
    if (bSig < aSig) {
        goto aBigger;
    }
    if (aSig < bSig) {
        goto bBigger;
    }
    return packFloat64(float_rounding_mode == float_round_down, 0, 0);
bExpBigger:
    if (bExp == 0x7FF) {
        if (bSig) {
            return propagateFloat64NaN(a, b);
        }
        return packFloat64(zSign ^ 1, 0x7FF, 0);
    }
    if (aExp == 0) {
        ++expDiff;
    } else {
        aSig |= LIT64(0x4000000000000000);
    }
    shift64RightJamming(aSig, -expDiff, &aSig);
    bSig |= LIT64(0x4000000000000000);
bBigger:
    zSig = bSig - aSig;
    zExp = bExp;
    zSign ^= 1;
    goto normalizeRoundAndPack;
aExpBigger:
    if (aExp == 0x7FF) {
        if (aSig) {
            return propagateFloat64NaN(a, b);
        }
        return a;
    }
    if (bExp == 0) {
        --expDiff;
    } else {
        bSig |= LIT64(0x4000000000000000);
    }
    shift64RightJamming(bSig, expDiff, &bSig);
    aSig |= LIT64(0x4000000000000000);
aBigger:
    zSig = aSig - bSig;
    zExp = aExp;
normalizeRoundAndPack:
    --zExp;
    return normalizeRoundAndPackFloat64(zSign, zExp, zSig);
}

/*----------------------------------------------------------------------------
| Returns the result of adding the double-precision floating-point values `a'
| and `b'.  The operation is performed according to the IEC/IEEE Standard for
| Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float64 float64_add(float64 a, float64 b)
{
    flag aSign, bSign;

    aSign = extractFloat64Sign(a);
    bSign = extractFloat64Sign(b);
    if (aSign == bSign) {
        return addFloat64Sigs(a, b, aSign);
    } else {
        return subFloat64Sigs(a, b, aSign);
    }
}

/*----------------------------------------------------------------------------
| Returns the result of subtracting the double-precision floating-point values
| `a' and `b'.  The operation is performed according to the IEC/IEEE Standard
| for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float64 float64_sub(float64 a, float64 b)
{
    flag aSign, bSign;

    aSign = extractFloat64Sign(a);
    bSign = extractFloat64Sign(b);
    if (aSign == bSign) {
        return subFloat64Sigs(a, b, aSign);
    } else {
        return addFloat64Sigs(a, b, aSign);
    }
}

/*----------------------------------------------------------------------------
| Returns the result of multiplying the double-precision floating-point values
| `a' and `b'.  The operation is performed according to the IEC/IEEE Standard
| for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float64 float64_mul(float64 a, float64 b)
{
    flag aSign, bSign, zSign;
    int16 aExp, bExp, zExp;
    bits64 aSig, bSig, zSig0, zSig1;

    aSig = extractFloat64Frac(a);
    aExp = extractFloat64Exp(a);
    aSign = extractFloat64Sign(a);
    bSig = extractFloat64Frac(b);
    bExp = extractFloat64Exp(b);
    bSign = extractFloat64Sign(b);
    zSign = aSign ^ bSign;
    if (aExp == 0x7FF) {
        if (aSig || ((bExp == 0x7FF) && bSig)) {
            return propagateFloat64NaN(a, b);
        }
        if ((bExp | bSig) == 0) {
            float_raise(float_flag_invalid);
            return float64_default_nan;
        }
        return packFloat64(zSign, 0x7FF, 0);
    }
    if (bExp == 0x7FF) {
        if (bSig) {
            return propagateFloat64NaN(a, b);
        }
        if ((aExp | aSig) == 0) {
            float_raise(float_flag_invalid);
            return float64_default_nan;
        }
        return packFloat64(zSign, 0x7FF, 0);
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return packFloat64(zSign, 0, 0);
        }
        normalizeFloat64Subnormal(aSig, &aExp, &aSig);
    }
    if (bExp == 0) {
        if (bSig == 0) {
            return packFloat64(zSign, 0, 0);
        }
        normalizeFloat64Subnormal(bSig, &bExp, &bSig);
    }
    zExp = aExp + bExp - 0x3FF;
    aSig = (aSig | LIT64(0x0010000000000000)) << 10;
    bSig = (bSig | LIT64(0x0010000000000000)) << 11;
    mul64To128(aSig, bSig, &zSig0, &zSig1);
    zSig0 |= (zSig1 != 0);
    if (0 <= (sbits64)(zSig0 << 1)) {
        zSig0 <<= 1;
        --zExp;
    }
    return roundAndPackFloat64(zSign, zExp, zSig0);
}

/*----------------------------------------------------------------------------
| Returns the result of dividing the double-precision floating-point value `a'
| by the corresponding value `b'.  The operation is performed according to
| the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float64 float64_div(float64 a, float64 b)
{
    flag aSign, bSign, zSign;
    int16 aExp, bExp, zExp;
    bits64 aSig, bSig, zSig;
    bits64 rem0, rem1;
    bits64 term0, term1;

    aSig = extractFloat64Frac(a);
    aExp = extractFloat64Exp(a);
    aSign = extractFloat64Sign(a);
    bSig = extractFloat64Frac(b);
    bExp = extractFloat64Exp(b);
    bSign = extractFloat64Sign(b);
    zSign = aSign ^ bSign;
    if (aExp == 0x7FF) {
        if (aSig) {
            return propagateFloat64NaN(a, b);
        }
        if (bExp == 0x7FF) {
            if (bSig) {
                return propagateFloat64NaN(a, b);
            }
            float_raise(float_flag_invalid);
            return float64_default_nan;
        }
        return packFloat64(zSign, 0x7FF, 0);
    }
    if (bExp == 0x7FF) {
        if (bSig) {
            return propagateFloat64NaN(a, b);
        }
        return packFloat64(zSign, 0, 0);
    }
    if (bExp == 0) {
        if (bSig == 0) {
            if ((aExp | aSig) == 0) {
                float_raise(float_flag_invalid);
                return float64_default_nan;
            }
            float_raise(float_flag_divbyzero);
            return packFloat64(zSign, 0x7FF, 0);
        }
        normalizeFloat64Subnormal(bSig, &bExp, &bSig);
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return packFloat64(zSign, 0, 0);
        }
        normalizeFloat64Subnormal(aSig, &aExp, &aSig);
    }
    zExp = aExp - bExp + 0x3FD;
    aSig = (aSig | LIT64(0x0010000000000000)) << 10;
    bSig = (bSig | LIT64(0x0010000000000000)) << 11;
    if (bSig <= (aSig + aSig)) {
        aSig >>= 1;
        ++zExp;
    }
    zSig = estimateDiv128To64(aSig, 0, bSig);
    if ((zSig & 0x1FF) <= 2) {
        mul64To128(bSig, zSig, &term0, &term1);
        sub128(aSig, 0, term0, term1, &rem0, &rem1);
        while ((sbits64)rem0 < 0) {
            --zSig;
            add128(rem0, rem1, 0, bSig, &rem0, &rem1);
        }
        zSig |= (rem1 != 0);
    }
    return roundAndPackFloat64(zSign, zExp, zSig);
}

/*----------------------------------------------------------------------------
| Returns the remainder of the double-precision floating-point value `a'
| with respect to the corresponding value `b'.  The operation is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float64 float64_rem(float64 a, float64 b)
{
    flag aSign, zSign;
    int16 aExp, bExp, expDiff;
    bits64 aSig, bSig;
    bits64 q, alternateASig;
    sbits64 sigMean;

    aSig = extractFloat64Frac(a);
    aExp = extractFloat64Exp(a);
    aSign = extractFloat64Sign(a);
    bSig = extractFloat64Frac(b);
    bExp = extractFloat64Exp(b);
    //    bSign = extractFloat64Sign( b );
    if (aExp == 0x7FF) {
        if (aSig || ((bExp == 0x7FF) && bSig)) {
            return propagateFloat64NaN(a, b);
        }
        float_raise(float_flag_invalid);
        return float64_default_nan;
    }
    if (bExp == 0x7FF) {
        if (bSig) {
            return propagateFloat64NaN(a, b);
        }
        return a;
    }
    if (bExp == 0) {
        if (bSig == 0) {
            float_raise(float_flag_invalid);
            return float64_default_nan;
        }
        normalizeFloat64Subnormal(bSig, &bExp, &bSig);
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return a;
        }
        normalizeFloat64Subnormal(aSig, &aExp, &aSig);
    }
    expDiff = aExp - bExp;
    aSig = (aSig | LIT64(0x0010000000000000)) << 11;
    bSig = (bSig | LIT64(0x0010000000000000)) << 11;
    if (expDiff < 0) {
        if (expDiff < -1) {
            return a;
        }
        aSig >>= 1;
    }
    q = (bSig <= aSig);
    if (q) {
        aSig -= bSig;
    }
    expDiff -= 64;
    while (0 < expDiff) {
        q = estimateDiv128To64(aSig, 0, bSig);
        q = (2 < q) ? q - 2 : 0;
        aSig = (bits64)0 - ((bSig >> 2) * q);
        expDiff -= 62;
    }
    expDiff += 64;
    if (0 < expDiff) {
        q = estimateDiv128To64(aSig, 0, bSig);
        q = (2 < q) ? q - 2 : 0;
        q >>= 64 - expDiff;
        bSig >>= 2;
        aSig = ((aSig >> 1) << (expDiff - 1)) - bSig * q;
    } else {
        aSig >>= 2;
        bSig >>= 2;
    }
    do {
        alternateASig = aSig;
        ++q;
        aSig -= bSig;
    } while (0 <= (sbits64)aSig);
    sigMean = aSig + alternateASig;
    if ((sigMean < 0) || ((sigMean == 0) && (q & 1))) {
        aSig = alternateASig;
    }
    zSign = ((sbits64)aSig < 0);
    if (zSign) {
        aSig = (bits64)0 - aSig;
    }
    return normalizeRoundAndPackFloat64(aSign ^ zSign, bExp, aSig);
}

/*----------------------------------------------------------------------------
| Returns the square root of the double-precision floating-point value `a'.
| The operation is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float64 float64_sqrt(float64 a)
{
    flag aSign;
    int16 aExp, zExp;
    bits64 aSig, zSig, doubleZSig;
    bits64 rem0, rem1, term0, term1;
    //    float64 z;

    aSig = extractFloat64Frac(a);
    aExp = extractFloat64Exp(a);
    aSign = extractFloat64Sign(a);
    if (aExp == 0x7FF) {
        if (aSig) {
            return propagateFloat64NaN(a, a);
        }
        if (!aSign) {
            return a;
        }
        float_raise(float_flag_invalid);
        return float64_default_nan;
    }
    if (aSign) {
        if ((aExp | aSig) == 0) {
            return a;
        }
        float_raise(float_flag_invalid);
        return float64_default_nan;
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return 0;
        }
        normalizeFloat64Subnormal(aSig, &aExp, &aSig);
    }
    zExp = ((aExp - 0x3FF) >> 1) + 0x3FE;
    aSig |= LIT64(0x0010000000000000);
    zSig = estimateSqrt32(aExp, aSig >> 21);
    aSig <<= 9 - (aExp & 1);
    zSig = estimateDiv128To64(aSig, 0, zSig << 32) + (zSig << 30);
    if ((zSig & 0x1FF) <= 5) {
        doubleZSig = zSig << 1;
        mul64To128(zSig, zSig, &term0, &term1);
        sub128(aSig, 0, term0, term1, &rem0, &rem1);
        while ((sbits64)rem0 < 0) {
            --zSig;
            doubleZSig -= 2;
            add128(rem0, rem1, zSig >> 63, doubleZSig | 1, &rem0, &rem1);
        }
        zSig |= ((rem0 | rem1) != 0);
    }
    return roundAndPackFloat64(0, zExp, zSig);
}

/*----------------------------------------------------------------------------
| Returns 1 if the double-precision floating-point value `a' is equal to the
| corresponding value `b', and 0 otherwise.  The comparison is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float64_eq(float64 a, float64 b)
{
    if (((extractFloat64Exp(a) == 0x7FF) && extractFloat64Frac(a)) || ((extractFloat64Exp(b) == 0x7FF) && extractFloat64Frac(b))) {
        if (float64_is_signaling_nan(a) || float64_is_signaling_nan(b)) {
            float_raise(float_flag_invalid);
        }
        return 0;
    }
    return (a == b) || ((bits64)((a | b) << 1) == 0);
}

/*----------------------------------------------------------------------------
| Returns 1 if the double-precision floating-point value `a' is less than or
| equal to the corresponding value `b', and 0 otherwise.  The comparison is
| performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

flag float64_le(float64 a, float64 b)
{
    flag aSign, bSign;

    if (((extractFloat64Exp(a) == 0x7FF) && extractFloat64Frac(a)) || ((extractFloat64Exp(b) == 0x7FF) && extractFloat64Frac(b))) {
        float_raise(float_flag_invalid);
        return 0;
    }
    aSign = extractFloat64Sign(a);
    bSign = extractFloat64Sign(b);
    if (aSign != bSign) {
        return aSign || ((bits64)((a | b) << 1) == 0);
    }
    return (a == b) || (aSign ^ (a < b));
}

/*----------------------------------------------------------------------------
| Returns 1 if the double-precision floating-point value `a' is less than
| the corresponding value `b', and 0 otherwise.  The comparison is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float64_lt(float64 a, float64 b)
{
    flag aSign, bSign;

    if (((extractFloat64Exp(a) == 0x7FF) && extractFloat64Frac(a)) || ((extractFloat64Exp(b) == 0x7FF) && extractFloat64Frac(b))) {
        float_raise(float_flag_invalid);
        return 0;
    }
    aSign = extractFloat64Sign(a);
    bSign = extractFloat64Sign(b);
    if (aSign != bSign) {
        return aSign && ((bits64)((a | b) << 1) != 0);
    }
    return (a != b) && (aSign ^ (a < b));
}

/*----------------------------------------------------------------------------
| Returns 1 if the double-precision floating-point value `a' is equal to the
| corresponding value `b', and 0 otherwise.  The invalid exception is raised
| if either operand is a NaN.  Otherwise, the comparison is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float64_eq_signaling(float64 a, float64 b)
{
    if (((extractFloat64Exp(a) == 0x7FF) && extractFloat64Frac(a)) || ((extractFloat64Exp(b) == 0x7FF) && extractFloat64Frac(b))) {
        float_raise(float_flag_invalid);
        return 0;
    }
    return (a == b) || ((bits64)((a | b) << 1) == 0);
}

/*----------------------------------------------------------------------------
| Returns 1 if the double-precision floating-point value `a' is less than or
| equal to the corresponding value `b', and 0 otherwise.  Quiet NaNs do not
| cause an exception.  Otherwise, the comparison is performed according to the
| IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float64_le_quiet(float64 a, float64 b)
{
    flag aSign, bSign;
    //    int16 aExp, bExp;

    if (((extractFloat64Exp(a) == 0x7FF) && extractFloat64Frac(a)) || ((extractFloat64Exp(b) == 0x7FF) && extractFloat64Frac(b))) {
        if (float64_is_signaling_nan(a) || float64_is_signaling_nan(b)) {
            float_raise(float_flag_invalid);
        }
        return 0;
    }
    aSign = extractFloat64Sign(a);
    bSign = extractFloat64Sign(b);
    if (aSign != bSign) {
        return aSign || ((bits64)((a | b) << 1) == 0);
    }
    return (a == b) || (aSign ^ (a < b));
}

/*----------------------------------------------------------------------------
| Returns 1 if the double-precision floating-point value `a' is less than
| the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an
| exception.  Otherwise, the comparison is performed according to the IEC/IEEE
| Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float64_lt_quiet(float64 a, float64 b)
{
    flag aSign, bSign;

    if (((extractFloat64Exp(a) == 0x7FF) && extractFloat64Frac(a)) || ((extractFloat64Exp(b) == 0x7FF) && extractFloat64Frac(b))) {
        if (float64_is_signaling_nan(a) || float64_is_signaling_nan(b)) {
            float_raise(float_flag_invalid);
        }
        return 0;
    }
    aSign = extractFloat64Sign(a);
    bSign = extractFloat64Sign(b);
    if (aSign != bSign) {
        return aSign && ((bits64)((a | b) << 1) != 0);
    }
    return (a != b) && (aSign ^ (a < b));
}

#ifdef FLOATX80

/*----------------------------------------------------------------------------
| Returns the result of converting the extended double-precision floating-
| point value `a' to the 32-bit two's complement integer format.  The
| conversion is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic---which means in particular that the conversion
| is rounded according to the current rounding mode.  If `a' is a NaN, the
| largest positive integer is returned.  Otherwise, if the conversion
| overflows, the largest integer with the same sign as `a' is returned.
*----------------------------------------------------------------------------*/

int32 floatx80_to_int32(floatx80 a)
{
    flag aSign;
    int32 aExp, shiftCount;
    bits64 aSig;

    aSig = extractFloatx80Frac(a);
    aExp = extractFloatx80Exp(a);
    aSign = extractFloatx80Sign(a);
    if ((aExp == 0x7FFF) && (bits64)(aSig << 1)) {
        aSign = 0;
    }
    shiftCount = 0x4037 - aExp;
    if (shiftCount <= 0) {
        shiftCount = 1;
    }
    shift64RightJamming(aSig, shiftCount, &aSig);
    return roundAndPackInt32(aSign, aSig);
}

/*----------------------------------------------------------------------------
| Returns the result of converting the extended double-precision floating-
| point value `a' to the 32-bit two's complement integer format.  The
| conversion is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic, except that the conversion is always rounded
| toward zero.  If `a' is a NaN, the largest positive integer is returned.
| Otherwise, if the conversion overflows, the largest integer with the same
| sign as `a' is returned.
*----------------------------------------------------------------------------*/

int32 floatx80_to_int32_round_to_zero(floatx80 a)
{
    flag aSign;
    int32 aExp, shiftCount;
    bits64 aSig, savedASig;
    int32 z;

    aSig = extractFloatx80Frac(a);
    aExp = extractFloatx80Exp(a);
    aSign = extractFloatx80Sign(a);
    if (0x401E < aExp) {
        if ((aExp == 0x7FFF) && (bits64)(aSig << 1)) {
            aSign = 0;
        }
        goto invalid;
    } else if (aExp < 0x3FFF) {
        if (aExp || aSig) {
            float_exception_flags |= float_flag_inexact;
        }
        return 0;
    }
    shiftCount = 0x403E - aExp;
    savedASig = aSig;
    aSig >>= shiftCount;
    z = aSig;
    if (aSign) {
        z = -z;
    }
    if ((z < 0) ^ aSign) {
    invalid:
        float_raise(float_flag_invalid);
        return aSign ? (sbits32)0x80000000 : 0x7FFFFFFF;
    }
    if ((aSig << shiftCount) != savedASig) {
        float_exception_flags |= float_flag_inexact;
    }
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of converting the extended double-precision floating-
| point value `a' to the 64-bit two's complement integer format.  The
| conversion is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic---which means in particular that the conversion
| is rounded according to the current rounding mode.  If `a' is a NaN,
| the largest positive integer is returned.  Otherwise, if the conversion
| overflows, the largest integer with the same sign as `a' is returned.
*----------------------------------------------------------------------------*/

int64 floatx80_to_int64(floatx80 a)
{
    flag aSign;
    int32 aExp, shiftCount;
    bits64 aSig, aSigExtra;

    aSig = extractFloatx80Frac(a);
    aExp = extractFloatx80Exp(a);
    aSign = extractFloatx80Sign(a);
    shiftCount = 0x403E - aExp;
    if (shiftCount <= 0) {
        if (shiftCount) {
            float_raise(float_flag_invalid);
            if (!aSign || ((aExp == 0x7FFF) && (aSig != LIT64(0x8000000000000000)))) {
                return LIT64(0x7FFFFFFFFFFFFFFF);
            }
            return (sbits64)LIT64(0x8000000000000000);
        }
        aSigExtra = 0;
    } else {
        shift64ExtraRightJamming(aSig, 0, shiftCount, &aSig, &aSigExtra);
    }
    return roundAndPackInt64(aSign, aSig, aSigExtra);
}

/*----------------------------------------------------------------------------
| Returns the result of converting the extended double-precision floating-
| point value `a' to the 64-bit two's complement integer format.  The
| conversion is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic, except that the conversion is always rounded
| toward zero.  If `a' is a NaN, the largest positive integer is returned.
| Otherwise, if the conversion overflows, the largest integer with the same
| sign as `a' is returned.
*----------------------------------------------------------------------------*/

int64 floatx80_to_int64_round_to_zero(floatx80 a)
{
    flag aSign;
    int32 aExp, shiftCount;
    bits64 aSig;
    int64 z;

    aSig = extractFloatx80Frac(a);
    aExp = extractFloatx80Exp(a);
    aSign = extractFloatx80Sign(a);
    shiftCount = aExp - 0x403E;
    if (0 <= shiftCount) {
        aSig &= LIT64(0x7FFFFFFFFFFFFFFF);
        if ((a.high != 0xC03E) || aSig) {
            float_raise(float_flag_invalid);
            if (!aSign || ((aExp == 0x7FFF) && aSig)) {
                return LIT64(0x7FFFFFFFFFFFFFFF);
            }
        }
        return (sbits64)LIT64(0x8000000000000000);
    } else if (aExp < 0x3FFF) {
        if (aExp | aSig) {
            float_exception_flags |= float_flag_inexact;
        }
        return 0;
    }
    z = aSig >> (-shiftCount);
    if ((bits64)(aSig << (shiftCount & 63))) {
        float_exception_flags |= float_flag_inexact;
    }
    if (aSign) {
        z = -z;
    }
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of converting the extended double-precision floating-
| point value `a' to the single-precision floating-point format.  The
| conversion is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float32 floatx80_to_float32(floatx80 a)
{
    flag aSign;
    int32 aExp;
    bits64 aSig;

    aSig = extractFloatx80Frac(a);
    aExp = extractFloatx80Exp(a);
    aSign = extractFloatx80Sign(a);
    if (aExp == 0x7FFF) {
        if ((bits64)(aSig << 1)) {
            return commonNaNToFloat32(floatx80ToCommonNaN(a));
        }
        return packFloat32(aSign, 0xFF, 0);
    }
    shift64RightJamming(aSig, 33, &aSig);
    if (aExp || aSig) {
        aExp -= 0x3F81;
    }
    return roundAndPackFloat32(aSign, aExp, aSig);
}

/*----------------------------------------------------------------------------
| Returns the result of converting the extended double-precision floating-
| point value `a' to the double-precision floating-point format.  The
| conversion is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float64 floatx80_to_float64(floatx80 a)
{
    flag aSign;
    int32 aExp;
    bits64 aSig, zSig;

    aSig = extractFloatx80Frac(a);
    aExp = extractFloatx80Exp(a);
    aSign = extractFloatx80Sign(a);
    if (aExp == 0x7FFF) {
        if ((bits64)(aSig << 1)) {
            return commonNaNToFloat64(floatx80ToCommonNaN(a));
        }
        return packFloat64(aSign, 0x7FF, 0);
    }
    shift64RightJamming(aSig, 1, &zSig);
    if (aExp || aSig) {
        aExp -= 0x3C01;
    }
    return roundAndPackFloat64(aSign, aExp, zSig);
}

#ifdef FLOAT128

/*----------------------------------------------------------------------------
| Returns the result of converting the extended double-precision floating-
| point value `a' to the quadruple-precision floating-point format.  The
| conversion is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float128 floatx80_to_float128(floatx80 a)
{
    flag aSign;
    int16 aExp;
    bits64 aSig, zSig0, zSig1;

    aSig = extractFloatx80Frac(a);
    aExp = extractFloatx80Exp(a);
    aSign = extractFloatx80Sign(a);
    if ((aExp == 0x7FFF) && (bits64)(aSig << 1)) {
        return commonNaNToFloat128(floatx80ToCommonNaN(a));
    }
    shift128Right(aSig << 1, 0, 16, &zSig0, &zSig1);
    return packFloat128(aSign, aExp, zSig0, zSig1);
}

#endif

/*----------------------------------------------------------------------------
| Rounds the extended double-precision floating-point value `a' to an integer,
| and returns the result as an extended quadruple-precision floating-point
| value.  The operation is performed according to the IEC/IEEE Standard for
| Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

floatx80 floatx80_round_to_int(floatx80 a)
{
    flag aSign;
    int32 aExp;
    bits64 lastBitMask, roundBitsMask;
    int8 roundingMode;
    floatx80 z;

    aExp = extractFloatx80Exp(a);
    if (0x403E <= aExp) {
        if ((aExp == 0x7FFF) && (bits64)(extractFloatx80Frac(a) << 1)) {
            return propagateFloatx80NaN(a, a);
        }
        return a;
    }
    if (aExp < 0x3FFF) {
        if ((aExp == 0) && ((bits64)(extractFloatx80Frac(a) << 1) == 0)) {
            return a;
        }
        float_exception_flags |= float_flag_inexact;
        aSign = extractFloatx80Sign(a);
        switch (float_rounding_mode) {
            case float_round_nearest_even:
                if ((aExp == 0x3FFE) && (bits64)(extractFloatx80Frac(a) << 1)) {
                    return packFloatx80(aSign, 0x3FFF, LIT64(0x8000000000000000));
                }
                break;
            case float_round_down:
                return aSign ? packFloatx80(1, 0x3FFF, LIT64(0x8000000000000000))
                             : packFloatx80(0, 0, 0);
            case float_round_up:
                return aSign ? packFloatx80(1, 0, 0)
                             : packFloatx80(0, 0x3FFF, LIT64(0x8000000000000000));
        }
        return packFloatx80(aSign, 0, 0);
    }
    lastBitMask = 1;
    lastBitMask <<= 0x403E - aExp;
    roundBitsMask = lastBitMask - 1;
    z = a;
    roundingMode = float_rounding_mode;
    if (roundingMode == float_round_nearest_even) {
        z.low += lastBitMask >> 1;
        if ((z.low & roundBitsMask) == 0) {
            z.low &= ~lastBitMask;
        }
    } else if (roundingMode != float_round_to_zero) {
        if (extractFloatx80Sign(z) ^ (roundingMode == float_round_up)) {
            z.low += roundBitsMask;
        }
    }
    z.low &= ~roundBitsMask;
    if (z.low == 0) {
        ++z.high;
        z.low = LIT64(0x8000000000000000);
    }
    if (z.low != a.low) {
        float_exception_flags |= float_flag_inexact;
    }
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of adding the absolute values of the extended double-
| precision floating-point values `a' and `b'.  If `zSign' is 1, the sum is
| negated before being returned.  `zSign' is ignored if the result is a NaN.
| The addition is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

static floatx80 addFloatx80Sigs(floatx80 a, floatx80 b, flag zSign)
{
    int32 aExp, bExp, zExp;
    bits64 aSig, bSig, zSig0, zSig1;
    int32 expDiff;

    aSig = extractFloatx80Frac(a);
    aExp = extractFloatx80Exp(a);
    bSig = extractFloatx80Frac(b);
    bExp = extractFloatx80Exp(b);
    expDiff = aExp - bExp;
    if (0 < expDiff) {
        if (aExp == 0x7FFF) {
            if ((bits64)(aSig << 1)) {
                return propagateFloatx80NaN(a, b);
            }
            return a;
        }
        if (bExp == 0) {
            --expDiff;
        }
        shift64ExtraRightJamming(bSig, 0, expDiff, &bSig, &zSig1);
        zExp = aExp;
    } else if (expDiff < 0) {
        if (bExp == 0x7FFF) {
            if ((bits64)(bSig << 1)) {
                return propagateFloatx80NaN(a, b);
            }
            return packFloatx80(zSign, 0x7FFF, LIT64(0x8000000000000000));
        }
        if (aExp == 0) {
            ++expDiff;
        }
        shift64ExtraRightJamming(aSig, 0, -expDiff, &aSig, &zSig1);
        zExp = bExp;
    } else {
        if (aExp == 0x7FFF) {
            if ((bits64)((aSig | bSig) << 1)) {
                return propagateFloatx80NaN(a, b);
            }
            return a;
        }
        zSig1 = 0;
        zSig0 = aSig + bSig;
        if (aExp == 0) {
            normalizeFloatx80Subnormal(zSig0, &zExp, &zSig0);
            goto roundAndPack;
        }
        zExp = aExp;
        goto shiftRight1;
    }
    zSig0 = aSig + bSig;
    if ((sbits64)zSig0 < 0) {
        goto roundAndPack;
    }
shiftRight1:
    shift64ExtraRightJamming(zSig0, zSig1, 1, &zSig0, &zSig1);
    zSig0 |= LIT64(0x8000000000000000);
    ++zExp;
roundAndPack:
    return roundAndPackFloatx80(
        floatx80_rounding_precision, zSign, zExp, zSig0, zSig1);
}

/*----------------------------------------------------------------------------
| Returns the result of subtracting the absolute values of the extended
| double-precision floating-point values `a' and `b'.  If `zSign' is 1, the
| difference is negated before being returned.  `zSign' is ignored if the
| result is a NaN.  The subtraction is performed according to the IEC/IEEE
| Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

static floatx80 subFloatx80Sigs(floatx80 a, floatx80 b, flag zSign)
{
    int32 aExp, bExp, zExp;
    bits64 aSig, bSig, zSig0, zSig1;
    int32 expDiff;
    floatx80 z;

    aSig = extractFloatx80Frac(a);
    aExp = extractFloatx80Exp(a);
    bSig = extractFloatx80Frac(b);
    bExp = extractFloatx80Exp(b);
    expDiff = aExp - bExp;
    if (0 < expDiff) {
        goto aExpBigger;
    }
    if (expDiff < 0) {
        goto bExpBigger;
    }
    if (aExp == 0x7FFF) {
        if ((bits64)((aSig | bSig) << 1)) {
            return propagateFloatx80NaN(a, b);
        }
        float_raise(float_flag_invalid);
        z.low = floatx80_default_nan_low;
        z.high = floatx80_default_nan_high;
        return z;
    }
    if (aExp == 0) {
        aExp = 1;
        bExp = 1;
    }
    zSig1 = 0;
    if (bSig < aSig) {
        goto aBigger;
    }
    if (aSig < bSig) {
        goto bBigger;
    }
    return packFloatx80(float_rounding_mode == float_round_down, 0, 0);
bExpBigger:
    if (bExp == 0x7FFF) {
        if ((bits64)(bSig << 1)) {
            return propagateFloatx80NaN(a, b);
        }
        return packFloatx80(zSign ^ 1, 0x7FFF, LIT64(0x8000000000000000));
    }
    if (aExp == 0) {
        ++expDiff;
    }
    shift128RightJamming(aSig, 0, -expDiff, &aSig, &zSig1);
bBigger:
    sub128(bSig, 0, aSig, zSig1, &zSig0, &zSig1);
    zExp = bExp;
    zSign ^= 1;
    goto normalizeRoundAndPack;
aExpBigger:
    if (aExp == 0x7FFF) {
        if ((bits64)(aSig << 1)) {
            return propagateFloatx80NaN(a, b);
        }
        return a;
    }
    if (bExp == 0) {
        --expDiff;
    }
    shift128RightJamming(bSig, 0, expDiff, &bSig, &zSig1);
aBigger:
    sub128(aSig, 0, bSig, zSig1, &zSig0, &zSig1);
    zExp = aExp;
normalizeRoundAndPack:
    return normalizeRoundAndPackFloatx80(
        floatx80_rounding_precision, zSign, zExp, zSig0, zSig1);
}

/*----------------------------------------------------------------------------
| Returns the result of adding the extended double-precision floating-point
| values `a' and `b'.  The operation is performed according to the IEC/IEEE
| Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

floatx80 floatx80_add(floatx80 a, floatx80 b)
{
    flag aSign, bSign;

    aSign = extractFloatx80Sign(a);
    bSign = extractFloatx80Sign(b);
    if (aSign == bSign) {
        return addFloatx80Sigs(a, b, aSign);
    } else {
        return subFloatx80Sigs(a, b, aSign);
    }
}

/*----------------------------------------------------------------------------
| Returns the result of subtracting the extended double-precision floating-
| point values `a' and `b'.  The operation is performed according to the
| IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

floatx80 floatx80_sub(floatx80 a, floatx80 b)
{
    flag aSign, bSign;

    aSign = extractFloatx80Sign(a);
    bSign = extractFloatx80Sign(b);
    if (aSign == bSign) {
        return subFloatx80Sigs(a, b, aSign);
    } else {
        return addFloatx80Sigs(a, b, aSign);
    }
}

/*----------------------------------------------------------------------------
| Returns the result of multiplying the extended double-precision floating-
| point values `a' and `b'.  The operation is performed according to the
| IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

floatx80 floatx80_mul(floatx80 a, floatx80 b)
{
    flag aSign, bSign, zSign;
    int32 aExp, bExp, zExp;
    bits64 aSig, bSig, zSig0, zSig1;
    floatx80 z;

    aSig = extractFloatx80Frac(a);
    aExp = extractFloatx80Exp(a);
    aSign = extractFloatx80Sign(a);
    bSig = extractFloatx80Frac(b);
    bExp = extractFloatx80Exp(b);
    bSign = extractFloatx80Sign(b);
    zSign = aSign ^ bSign;
    if (aExp == 0x7FFF) {
        if ((bits64)(aSig << 1) || ((bExp == 0x7FFF) && (bits64)(bSig << 1))) {
            return propagateFloatx80NaN(a, b);
        }
        if ((bExp | bSig) == 0) {
            goto invalid;
        }
        return packFloatx80(zSign, 0x7FFF, LIT64(0x8000000000000000));
    }
    if (bExp == 0x7FFF) {
        if ((bits64)(bSig << 1)) {
            return propagateFloatx80NaN(a, b);
        }
        if ((aExp | aSig) == 0) {
        invalid:
            float_raise(float_flag_invalid);
            z.low = floatx80_default_nan_low;
            z.high = floatx80_default_nan_high;
            return z;
        }
        return packFloatx80(zSign, 0x7FFF, LIT64(0x8000000000000000));
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return packFloatx80(zSign, 0, 0);
        }
        normalizeFloatx80Subnormal(aSig, &aExp, &aSig);
    }
    if (bExp == 0) {
        if (bSig == 0) {
            return packFloatx80(zSign, 0, 0);
        }
        normalizeFloatx80Subnormal(bSig, &bExp, &bSig);
    }
    zExp = aExp + bExp - 0x3FFE;
    mul64To128(aSig, bSig, &zSig0, &zSig1);
    if (0 < (sbits64)zSig0) {
        shortShift128Left(zSig0, zSig1, 1, &zSig0, &zSig1);
        --zExp;
    }
    return roundAndPackFloatx80(
        floatx80_rounding_precision, zSign, zExp, zSig0, zSig1);
}

/*----------------------------------------------------------------------------
| Returns the result of dividing the extended double-precision floating-point
| value `a' by the corresponding value `b'.  The operation is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

floatx80 floatx80_div(floatx80 a, floatx80 b)
{
    flag aSign, bSign, zSign;
    int32 aExp, bExp, zExp;
    bits64 aSig, bSig, zSig0, zSig1;
    bits64 rem0, rem1, rem2, term0, term1, term2;
    floatx80 z;

    aSig = extractFloatx80Frac(a);
    aExp = extractFloatx80Exp(a);
    aSign = extractFloatx80Sign(a);
    bSig = extractFloatx80Frac(b);
    bExp = extractFloatx80Exp(b);
    bSign = extractFloatx80Sign(b);
    zSign = aSign ^ bSign;
    if (aExp == 0x7FFF) {
        if ((bits64)(aSig << 1)) {
            return propagateFloatx80NaN(a, b);
        }
        if (bExp == 0x7FFF) {
            if ((bits64)(bSig << 1)) {
                return propagateFloatx80NaN(a, b);
            }
            goto invalid;
        }
        return packFloatx80(zSign, 0x7FFF, LIT64(0x8000000000000000));
    }
    if (bExp == 0x7FFF) {
        if ((bits64)(bSig << 1)) {
            return propagateFloatx80NaN(a, b);
        }
        return packFloatx80(zSign, 0, 0);
    }
    if (bExp == 0) {
        if (bSig == 0) {
            if ((aExp | aSig) == 0) {
            invalid:
                float_raise(float_flag_invalid);
                z.low = floatx80_default_nan_low;
                z.high = floatx80_default_nan_high;
                return z;
            }
            float_raise(float_flag_divbyzero);
            return packFloatx80(zSign, 0x7FFF, LIT64(0x8000000000000000));
        }
        normalizeFloatx80Subnormal(bSig, &bExp, &bSig);
    }
    if (aExp == 0) {
        if (aSig == 0) {
            return packFloatx80(zSign, 0, 0);
        }
        normalizeFloatx80Subnormal(aSig, &aExp, &aSig);
    }
    zExp = aExp - bExp + 0x3FFE;
    rem1 = 0;
    if (bSig <= aSig) {
        shift128Right(aSig, 0, 1, &aSig, &rem1);
        ++zExp;
    }
    zSig0 = estimateDiv128To64(aSig, rem1, bSig);
    mul64To128(bSig, zSig0, &term0, &term1);
    sub128(aSig, rem1, term0, term1, &rem0, &rem1);
    while ((sbits64)rem0 < 0) {
        --zSig0;
        add128(rem0, rem1, 0, bSig, &rem0, &rem1);
    }
    zSig1 = estimateDiv128To64(rem1, 0, bSig);
    if ((bits64)(zSig1 << 1) <= 8) {
        mul64To128(bSig, zSig1, &term1, &term2);
        sub128(rem1, 0, term1, term2, &rem1, &rem2);
        while ((sbits64)rem1 < 0) {
            --zSig1;
            add128(rem1, rem2, 0, bSig, &rem1, &rem2);
        }
        zSig1 |= ((rem1 | rem2) != 0);
    }
    return roundAndPackFloatx80(
        floatx80_rounding_precision, zSign, zExp, zSig0, zSig1);
}

/*----------------------------------------------------------------------------
| Returns the remainder of the extended double-precision floating-point value
| `a' with respect to the corresponding value `b'.  The operation is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

floatx80 floatx80_rem(floatx80 a, floatx80 b)
{
    flag aSign, zSign;
    int32 aExp, bExp, expDiff;
    bits64 aSig0, aSig1, bSig;
    bits64 q, term0, term1, alternateASig0, alternateASig1;
    floatx80 z;

    aSig0 = extractFloatx80Frac(a);
    aExp = extractFloatx80Exp(a);
    aSign = extractFloatx80Sign(a);
    bSig = extractFloatx80Frac(b);
    bExp = extractFloatx80Exp(b);
    //    bSign = extractFloatx80Sign( b );
    if (aExp == 0x7FFF) {
        if ((bits64)(aSig0 << 1) || ((bExp == 0x7FFF) && (bits64)(bSig << 1))) {
            return propagateFloatx80NaN(a, b);
        }
        goto invalid;
    }
    if (bExp == 0x7FFF) {
        if ((bits64)(bSig << 1)) {
            return propagateFloatx80NaN(a, b);
        }
        return a;
    }
    if (bExp == 0) {
        if (bSig == 0) {
        invalid:
            float_raise(float_flag_invalid);
            z.low = floatx80_default_nan_low;
            z.high = floatx80_default_nan_high;
            return z;
        }
        normalizeFloatx80Subnormal(bSig, &bExp, &bSig);
    }
    if (aExp == 0) {
        if ((bits64)(aSig0 << 1) == 0) {
            return a;
        }
        normalizeFloatx80Subnormal(aSig0, &aExp, &aSig0);
    }
    bSig |= LIT64(0x8000000000000000);
    zSign = aSign;
    expDiff = aExp - bExp;
    aSig1 = 0;
    if (expDiff < 0) {
        if (expDiff < -1) {
            return a;
        }
        shift128Right(aSig0, 0, 1, &aSig0, &aSig1);
        expDiff = 0;
    }
    q = (bSig <= aSig0);
    if (q) {
        aSig0 -= bSig;
    }
    expDiff -= 64;
    while (0 < expDiff) {
        q = estimateDiv128To64(aSig0, aSig1, bSig);
        q = (2 < q) ? q - 2 : 0;
        mul64To128(bSig, q, &term0, &term1);
        sub128(aSig0, aSig1, term0, term1, &aSig0, &aSig1);
        shortShift128Left(aSig0, aSig1, 62, &aSig0, &aSig1);
        expDiff -= 62;
    }
    expDiff += 64;
    if (0 < expDiff) {
        q = estimateDiv128To64(aSig0, aSig1, bSig);
        q = (2 < q) ? q - 2 : 0;
        q >>= 64 - expDiff;
        mul64To128(bSig, q << (64 - expDiff), &term0, &term1);
        sub128(aSig0, aSig1, term0, term1, &aSig0, &aSig1);
        shortShift128Left(0, bSig, 64 - expDiff, &term0, &term1);
        while (le128(term0, term1, aSig0, aSig1)) {
            ++q;
            sub128(aSig0, aSig1, term0, term1, &aSig0, &aSig1);
        }
    } else {
        term1 = 0;
        term0 = bSig;
    }
    sub128(term0, term1, aSig0, aSig1, &alternateASig0, &alternateASig1);
    if (lt128(alternateASig0, alternateASig1, aSig0, aSig1) || (eq128(alternateASig0, alternateASig1, aSig0, aSig1) && (q & 1))) {
        aSig0 = alternateASig0;
        aSig1 = alternateASig1;
        zSign = !zSign;
    }
    return normalizeRoundAndPackFloatx80(
        80, zSign, bExp + expDiff, aSig0, aSig1);
}

/*----------------------------------------------------------------------------
| Returns the square root of the extended double-precision floating-point
| value `a'.  The operation is performed according to the IEC/IEEE Standard
| for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

floatx80 floatx80_sqrt(floatx80 a)
{
    flag aSign;
    int32 aExp, zExp;
    bits64 aSig0, aSig1, zSig0, zSig1, doubleZSig0;
    bits64 rem0, rem1, rem2, rem3, term0, term1, term2, term3;
    floatx80 z;

    aSig0 = extractFloatx80Frac(a);
    aExp = extractFloatx80Exp(a);
    aSign = extractFloatx80Sign(a);
    if (aExp == 0x7FFF) {
        if ((bits64)(aSig0 << 1)) {
            return propagateFloatx80NaN(a, a);
        }
        if (!aSign) {
            return a;
        }
        goto invalid;
    }
    if (aSign) {
        if ((aExp | aSig0) == 0) {
            return a;
        }
    invalid:
        float_raise(float_flag_invalid);
        z.low = floatx80_default_nan_low;
        z.high = floatx80_default_nan_high;
        return z;
    }
    if (aExp == 0) {
        if (aSig0 == 0) {
            return packFloatx80(0, 0, 0);
        }
        normalizeFloatx80Subnormal(aSig0, &aExp, &aSig0);
    }
    zExp = ((aExp - 0x3FFF) >> 1) + 0x3FFF;
    zSig0 = estimateSqrt32(aExp, aSig0 >> 32);
    shift128Right(aSig0, 0, 2 + (aExp & 1), &aSig0, &aSig1);
    zSig0 = estimateDiv128To64(aSig0, aSig1, zSig0 << 32) + (zSig0 << 30);
    doubleZSig0 = zSig0 << 1;
    mul64To128(zSig0, zSig0, &term0, &term1);
    sub128(aSig0, aSig1, term0, term1, &rem0, &rem1);
    while ((sbits64)rem0 < 0) {
        --zSig0;
        doubleZSig0 -= 2;
        add128(rem0, rem1, zSig0 >> 63, doubleZSig0 | 1, &rem0, &rem1);
    }
    zSig1 = estimateDiv128To64(rem1, 0, doubleZSig0);
    if ((zSig1 & LIT64(0x3FFFFFFFFFFFFFFF)) <= 5) {
        if (zSig1 == 0) {
            zSig1 = 1;
        }
        mul64To128(doubleZSig0, zSig1, &term1, &term2);
        sub128(rem1, 0, term1, term2, &rem1, &rem2);
        mul64To128(zSig1, zSig1, &term2, &term3);
        sub192(rem1, rem2, 0, 0, term2, term3, &rem1, &rem2, &rem3);
        while ((sbits64)rem1 < 0) {
            --zSig1;
            shortShift128Left(0, zSig1, 1, &term2, &term3);
            term3 |= 1;
            term2 |= doubleZSig0;
            add192(rem1, rem2, rem3, 0, term2, term3, &rem1, &rem2, &rem3);
        }
        zSig1 |= ((rem1 | rem2 | rem3) != 0);
    }
    shortShift128Left(0, zSig1, 1, &zSig0, &zSig1);
    zSig0 |= doubleZSig0;
    return roundAndPackFloatx80(
        floatx80_rounding_precision, 0, zExp, zSig0, zSig1);
}

/*----------------------------------------------------------------------------
| Returns 1 if the extended double-precision floating-point value `a' is
| equal to the corresponding value `b', and 0 otherwise.  The comparison is
| performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

flag floatx80_eq(floatx80 a, floatx80 b)
{
    if (((extractFloatx80Exp(a) == 0x7FFF) && (bits64)(extractFloatx80Frac(a) << 1)) || ((extractFloatx80Exp(b) == 0x7FFF) && (bits64)(extractFloatx80Frac(b) << 1))) {
        if (floatx80_is_signaling_nan(a) || floatx80_is_signaling_nan(b)) {
            float_raise(float_flag_invalid);
        }
        return 0;
    }
    return (a.low == b.low) && ((a.high == b.high) || ((a.low == 0) && ((bits16)((a.high | b.high) << 1) == 0)));
}

/*----------------------------------------------------------------------------
| Returns 1 if the extended double-precision floating-point value `a' is
| less than or equal to the corresponding value `b', and 0 otherwise.  The
| comparison is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag floatx80_le(floatx80 a, floatx80 b)
{
    flag aSign, bSign;

    if (((extractFloatx80Exp(a) == 0x7FFF) && (bits64)(extractFloatx80Frac(a) << 1)) || ((extractFloatx80Exp(b) == 0x7FFF) && (bits64)(extractFloatx80Frac(b) << 1))) {
        float_raise(float_flag_invalid);
        return 0;
    }
    aSign = extractFloatx80Sign(a);
    bSign = extractFloatx80Sign(b);
    if (aSign != bSign) {
        return aSign || ((((bits16)((a.high | b.high) << 1)) | a.low | b.low) == 0);
    }
    return aSign ? le128(b.high, b.low, a.high, a.low)
                 : le128(a.high, a.low, b.high, b.low);
}

/*----------------------------------------------------------------------------
| Returns 1 if the extended double-precision floating-point value `a' is
| less than the corresponding value `b', and 0 otherwise.  The comparison
| is performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

flag floatx80_lt(floatx80 a, floatx80 b)
{
    flag aSign, bSign;

    if (((extractFloatx80Exp(a) == 0x7FFF) && (bits64)(extractFloatx80Frac(a) << 1)) || ((extractFloatx80Exp(b) == 0x7FFF) && (bits64)(extractFloatx80Frac(b) << 1))) {
        float_raise(float_flag_invalid);
        return 0;
    }
    aSign = extractFloatx80Sign(a);
    bSign = extractFloatx80Sign(b);
    if (aSign != bSign) {
        return aSign && ((((bits16)((a.high | b.high) << 1)) | a.low | b.low) != 0);
    }
    return aSign ? lt128(b.high, b.low, a.high, a.low)
                 : lt128(a.high, a.low, b.high, b.low);
}

/*----------------------------------------------------------------------------
| Returns 1 if the extended double-precision floating-point value `a' is equal
| to the corresponding value `b', and 0 otherwise.  The invalid exception is
| raised if either operand is a NaN.  Otherwise, the comparison is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag floatx80_eq_signaling(floatx80 a, floatx80 b)
{
    if (((extractFloatx80Exp(a) == 0x7FFF) && (bits64)(extractFloatx80Frac(a) << 1)) || ((extractFloatx80Exp(b) == 0x7FFF) && (bits64)(extractFloatx80Frac(b) << 1))) {
        float_raise(float_flag_invalid);
        return 0;
    }
    return (a.low == b.low) && ((a.high == b.high) || ((a.low == 0) && ((bits16)((a.high | b.high) << 1) == 0)));
}

/*----------------------------------------------------------------------------
| Returns 1 if the extended double-precision floating-point value `a' is less
| than or equal to the corresponding value `b', and 0 otherwise.  Quiet NaNs
| do not cause an exception.  Otherwise, the comparison is performed according
| to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag floatx80_le_quiet(floatx80 a, floatx80 b)
{
    flag aSign, bSign;

    if (((extractFloatx80Exp(a) == 0x7FFF) && (bits64)(extractFloatx80Frac(a) << 1)) || ((extractFloatx80Exp(b) == 0x7FFF) && (bits64)(extractFloatx80Frac(b) << 1))) {
        if (floatx80_is_signaling_nan(a) || floatx80_is_signaling_nan(b)) {
            float_raise(float_flag_invalid);
        }
        return 0;
    }
    aSign = extractFloatx80Sign(a);
    bSign = extractFloatx80Sign(b);
    if (aSign != bSign) {
        return aSign || ((((bits16)((a.high | b.high) << 1)) | a.low | b.low) == 0);
    }
    return aSign ? le128(b.high, b.low, a.high, a.low)
                 : le128(a.high, a.low, b.high, b.low);
}

/*----------------------------------------------------------------------------
| Returns 1 if the extended double-precision floating-point value `a' is less
| than the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause
| an exception.  Otherwise, the comparison is performed according to the
| IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag floatx80_lt_quiet(floatx80 a, floatx80 b)
{
    flag aSign, bSign;

    if (((extractFloatx80Exp(a) == 0x7FFF) && (bits64)(extractFloatx80Frac(a) << 1)) || ((extractFloatx80Exp(b) == 0x7FFF) && (bits64)(extractFloatx80Frac(b) << 1))) {
        if (floatx80_is_signaling_nan(a) || floatx80_is_signaling_nan(b)) {
            float_raise(float_flag_invalid);
        }
        return 0;
    }
    aSign = extractFloatx80Sign(a);
    bSign = extractFloatx80Sign(b);
    if (aSign != bSign) {
        return aSign && ((((bits16)((a.high | b.high) << 1)) | a.low | b.low) != 0);
    }
    return aSign ? lt128(b.high, b.low, a.high, a.low)
                 : lt128(a.high, a.low, b.high, b.low);
}

#endif

#ifdef FLOAT128

/*----------------------------------------------------------------------------
| Returns the result of converting the quadruple-precision floating-point
| value `a' to the 32-bit two's complement integer format.  The conversion
| is performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic---which means in particular that the conversion is rounded
| according to the current rounding mode.  If `a' is a NaN, the largest
| positive integer is returned.  Otherwise, if the conversion overflows, the
| largest integer with the same sign as `a' is returned.
*----------------------------------------------------------------------------*/

int32 float128_to_int32(float128 a)
{
    flag aSign;
    int32 aExp, shiftCount;
    bits64 aSig0, aSig1;

    aSig1 = extractFloat128Frac1(a);
    aSig0 = extractFloat128Frac0(a);
    aExp = extractFloat128Exp(a);
    aSign = extractFloat128Sign(a);
    if ((aExp == 0x7FFF) && (aSig0 | aSig1)) {
        aSign = 0;
    }
    if (aExp) {
        aSig0 |= LIT64(0x0001000000000000);
    }
    aSig0 |= (aSig1 != 0);
    shiftCount = 0x4028 - aExp;
    if (0 < shiftCount) {
        shift64RightJamming(aSig0, shiftCount, &aSig0);
    }
    return roundAndPackInt32(aSign, aSig0);
}

/*----------------------------------------------------------------------------
| Returns the result of converting the quadruple-precision floating-point
| value `a' to the 32-bit two's complement integer format.  The conversion
| is performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic, except that the conversion is always rounded toward zero.  If
| `a' is a NaN, the largest positive integer is returned.  Otherwise, if the
| conversion overflows, the largest integer with the same sign as `a' is
| returned.
*----------------------------------------------------------------------------*/

int32 float128_to_int32_round_to_zero(float128 a)
{
    flag aSign;
    int32 aExp, shiftCount;
    bits64 aSig0, aSig1, savedASig;
    int32 z;

    aSig1 = extractFloat128Frac1(a);
    aSig0 = extractFloat128Frac0(a);
    aExp = extractFloat128Exp(a);
    aSign = extractFloat128Sign(a);
    aSig0 |= (aSig1 != 0);
    if (0x401E < aExp) {
        if ((aExp == 0x7FFF) && aSig0) {
            aSign = 0;
        }
        goto invalid;
    } else if (aExp < 0x3FFF) {
        if (aExp || aSig0) {
            float_exception_flags |= float_flag_inexact;
        }
        return 0;
    }
    aSig0 |= LIT64(0x0001000000000000);
    shiftCount = 0x402F - aExp;
    savedASig = aSig0;
    aSig0 >>= shiftCount;
    z = aSig0;
    if (aSign) {
        z = -z;
    }
    if ((z < 0) ^ aSign) {
    invalid:
        float_raise(float_flag_invalid);
        return aSign ? (sbits32)0x80000000 : 0x7FFFFFFF;
    }
    if ((aSig0 << shiftCount) != savedASig) {
        float_exception_flags |= float_flag_inexact;
    }
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of converting the quadruple-precision floating-point
| value `a' to the 64-bit two's complement integer format.  The conversion
| is performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic---which means in particular that the conversion is rounded
| according to the current rounding mode.  If `a' is a NaN, the largest
| positive integer is returned.  Otherwise, if the conversion overflows, the
| largest integer with the same sign as `a' is returned.
*----------------------------------------------------------------------------*/

int64 float128_to_int64(float128 a)
{
    flag aSign;
    int32 aExp, shiftCount;
    bits64 aSig0, aSig1;

    aSig1 = extractFloat128Frac1(a);
    aSig0 = extractFloat128Frac0(a);
    aExp = extractFloat128Exp(a);
    aSign = extractFloat128Sign(a);
    if (aExp) {
        aSig0 |= LIT64(0x0001000000000000);
    }
    shiftCount = 0x402F - aExp;
    if (shiftCount <= 0) {
        if (0x403E < aExp) {
            float_raise(float_flag_invalid);
            if (!aSign || ((aExp == 0x7FFF) && (aSig1 || (aSig0 != LIT64(0x0001000000000000))))) {
                return LIT64(0x7FFFFFFFFFFFFFFF);
            }
            return (sbits64)LIT64(0x8000000000000000);
        }
        shortShift128Left(aSig0, aSig1, -shiftCount, &aSig0, &aSig1);
    } else {
        shift64ExtraRightJamming(aSig0, aSig1, shiftCount, &aSig0, &aSig1);
    }
    return roundAndPackInt64(aSign, aSig0, aSig1);
}

/*----------------------------------------------------------------------------
| Returns the result of converting the quadruple-precision floating-point
| value `a' to the 64-bit two's complement integer format.  The conversion
| is performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic, except that the conversion is always rounded toward zero.
| If `a' is a NaN, the largest positive integer is returned.  Otherwise, if
| the conversion overflows, the largest integer with the same sign as `a' is
| returned.
*----------------------------------------------------------------------------*/

int64 float128_to_int64_round_to_zero(float128 a)
{
    flag aSign;
    int32 aExp, shiftCount;
    bits64 aSig0, aSig1;
    int64 z;

    aSig1 = extractFloat128Frac1(a);
    aSig0 = extractFloat128Frac0(a);
    aExp = extractFloat128Exp(a);
    aSign = extractFloat128Sign(a);
    if (aExp) {
        aSig0 |= LIT64(0x0001000000000000);
    }
    shiftCount = aExp - 0x402F;
    if (0 < shiftCount) {
        if (0x403E <= aExp) {
            aSig0 &= LIT64(0x0000FFFFFFFFFFFF);
            if ((a.high == LIT64(0xC03E000000000000)) && (aSig1 < LIT64(0x0002000000000000))) {
                if (aSig1) {
                    float_exception_flags |= float_flag_inexact;
                }
            } else {
                float_raise(float_flag_invalid);
                if (!aSign || ((aExp == 0x7FFF) && (aSig0 | aSig1))) {
                    return LIT64(0x7FFFFFFFFFFFFFFF);
                }
            }
            return (sbits64)LIT64(0x8000000000000000);
        }
        z = (aSig0 << shiftCount) | (aSig1 >> ((-shiftCount) & 63));
        if ((bits64)(aSig1 << shiftCount)) {
            float_exception_flags |= float_flag_inexact;
        }
    } else {
        if (aExp < 0x3FFF) {
            if (aExp | aSig0 | aSig1) {
                float_exception_flags |= float_flag_inexact;
            }
            return 0;
        }
        z = aSig0 >> (-shiftCount);
        if (aSig1 || (shiftCount && (bits64)(aSig0 << (shiftCount & 63)))) {
            float_exception_flags |= float_flag_inexact;
        }
    }
    if (aSign) {
        z = -z;
    }
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of converting the quadruple-precision floating-point
| value `a' to the single-precision floating-point format.  The conversion
| is performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

float32 float128_to_float32(float128 a)
{
    flag aSign;
    int32 aExp;
    bits64 aSig0, aSig1;
    bits32 zSig;

    aSig1 = extractFloat128Frac1(a);
    aSig0 = extractFloat128Frac0(a);
    aExp = extractFloat128Exp(a);
    aSign = extractFloat128Sign(a);
    if (aExp == 0x7FFF) {
        if (aSig0 | aSig1) {
            return commonNaNToFloat32(float128ToCommonNaN(a));
        }
        return packFloat32(aSign, 0xFF, 0);
    }
    aSig0 |= (aSig1 != 0);
    shift64RightJamming(aSig0, 18, &aSig0);
    zSig = aSig0;
    if (aExp || zSig) {
        zSig |= 0x40000000;
        aExp -= 0x3F81;
    }
    return roundAndPackFloat32(aSign, aExp, zSig);
}

/*----------------------------------------------------------------------------
| Returns the result of converting the quadruple-precision floating-point
| value `a' to the double-precision floating-point format.  The conversion
| is performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

float64 float128_to_float64(float128 a)
{
    flag aSign;
    int32 aExp;
    bits64 aSig0, aSig1;

    aSig1 = extractFloat128Frac1(a);
    aSig0 = extractFloat128Frac0(a);
    aExp = extractFloat128Exp(a);
    aSign = extractFloat128Sign(a);
    if (aExp == 0x7FFF) {
        if (aSig0 | aSig1) {
            return commonNaNToFloat64(float128ToCommonNaN(a));
        }
        return packFloat64(aSign, 0x7FF, 0);
    }
    shortShift128Left(aSig0, aSig1, 14, &aSig0, &aSig1);
    aSig0 |= (aSig1 != 0);
    if (aExp || aSig0) {
        aSig0 |= LIT64(0x4000000000000000);
        aExp -= 0x3C01;
    }
    return roundAndPackFloat64(aSign, aExp, aSig0);
}

#ifdef FLOATX80

/*----------------------------------------------------------------------------
| Returns the result of converting the quadruple-precision floating-point
| value `a' to the extended double-precision floating-point format.  The
| conversion is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

floatx80 float128_to_floatx80(float128 a)
{
    flag aSign;
    int32 aExp;
    bits64 aSig0, aSig1;

    aSig1 = extractFloat128Frac1(a);
    aSig0 = extractFloat128Frac0(a);
    aExp = extractFloat128Exp(a);
    aSign = extractFloat128Sign(a);
    if (aExp == 0x7FFF) {
        if (aSig0 | aSig1) {
            return commonNaNToFloatx80(float128ToCommonNaN(a));
        }
        return packFloatx80(aSign, 0x7FFF, LIT64(0x8000000000000000));
    }
    if (aExp == 0) {
        if ((aSig0 | aSig1) == 0) {
            return packFloatx80(aSign, 0, 0);
        }
        normalizeFloat128Subnormal(aSig0, aSig1, &aExp, &aSig0, &aSig1);
    } else {
        aSig0 |= LIT64(0x0001000000000000);
    }
    shortShift128Left(aSig0, aSig1, 15, &aSig0, &aSig1);
    return roundAndPackFloatx80(80, aSign, aExp, aSig0, aSig1);
}

#endif

/*----------------------------------------------------------------------------
| Rounds the quadruple-precision floating-point value `a' to an integer, and
| returns the result as a quadruple-precision floating-point value.  The
| operation is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float128 float128_round_to_int(float128 a)
{
    flag aSign;
    int32 aExp;
    bits64 lastBitMask, roundBitsMask;
    int8 roundingMode;
    float128 z;

    aExp = extractFloat128Exp(a);
    if (0x402F <= aExp) {
        if (0x406F <= aExp) {
            if ((aExp == 0x7FFF) && (extractFloat128Frac0(a) | extractFloat128Frac1(a))) {
                return propagateFloat128NaN(a, a);
            }
            return a;
        }
        lastBitMask = 1;
        lastBitMask = (lastBitMask << (0x406E - aExp)) << 1;
        roundBitsMask = lastBitMask - 1;
        z = a;
        roundingMode = float_rounding_mode;
        if (roundingMode == float_round_nearest_even) {
            if (lastBitMask) {
                add128(z.high, z.low, 0, lastBitMask >> 1, &z.high, &z.low);
                if ((z.low & roundBitsMask) == 0) {
                    z.low &= ~lastBitMask;
                }
            } else {
                if ((sbits64)z.low < 0) {
                    ++z.high;
                    if ((bits64)(z.low << 1) == 0) {
                        z.high &= ~1;
                    }
                }
            }
        } else if (roundingMode != float_round_to_zero) {
            if (extractFloat128Sign(z) ^ (roundingMode == float_round_up)) {
                add128(z.high, z.low, 0, roundBitsMask, &z.high, &z.low);
            }
        }
        z.low &= ~roundBitsMask;
    } else {
        if (aExp < 0x3FFF) {
            if ((((bits64)(a.high << 1)) | a.low) == 0) {
                return a;
            }
            float_exception_flags |= float_flag_inexact;
            aSign = extractFloat128Sign(a);
            switch (float_rounding_mode) {
                case float_round_nearest_even:
                    if ((aExp == 0x3FFE) && (extractFloat128Frac0(a) | extractFloat128Frac1(a))) {
                        return packFloat128(aSign, 0x3FFF, 0, 0);
                    }
                    break;
                case float_round_down:
                    return aSign ? packFloat128(1, 0x3FFF, 0, 0)
                                 : packFloat128(0, 0, 0, 0);
                case float_round_up:
                    return aSign ? packFloat128(1, 0, 0, 0)
                                 : packFloat128(0, 0x3FFF, 0, 0);
            }
            return packFloat128(aSign, 0, 0, 0);
        }
        lastBitMask = 1;
        lastBitMask <<= 0x402F - aExp;
        roundBitsMask = lastBitMask - 1;
        z.low = 0;
        z.high = a.high;
        roundingMode = float_rounding_mode;
        if (roundingMode == float_round_nearest_even) {
            z.high += lastBitMask >> 1;
            if (((z.high & roundBitsMask) | a.low) == 0) {
                z.high &= ~lastBitMask;
            }
        } else if (roundingMode != float_round_to_zero) {
            if (extractFloat128Sign(z) ^ (roundingMode == float_round_up)) {
                z.high |= (a.low != 0);
                z.high += roundBitsMask;
            }
        }
        z.high &= ~roundBitsMask;
    }
    if ((z.low != a.low) || (z.high != a.high)) {
        float_exception_flags |= float_flag_inexact;
    }
    return z;
}

/*----------------------------------------------------------------------------
| Returns the result of adding the absolute values of the quadruple-precision
| floating-point values `a' and `b'.  If `zSign' is 1, the sum is negated
| before being returned.  `zSign' is ignored if the result is a NaN.
| The addition is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

static float128 addFloat128Sigs(float128 a, float128 b, flag zSign)
{
    int32 aExp, bExp, zExp;
    bits64 aSig0, aSig1, bSig0, bSig1, zSig0, zSig1, zSig2;
    int32 expDiff;

    aSig1 = extractFloat128Frac1(a);
    aSig0 = extractFloat128Frac0(a);
    aExp = extractFloat128Exp(a);
    bSig1 = extractFloat128Frac1(b);
    bSig0 = extractFloat128Frac0(b);
    bExp = extractFloat128Exp(b);
    expDiff = aExp - bExp;
    if (0 < expDiff) {
        if (aExp == 0x7FFF) {
            if (aSig0 | aSig1) {
                return propagateFloat128NaN(a, b);
            }
            return a;
        }
        if (bExp == 0) {
            --expDiff;
        } else {
            bSig0 |= LIT64(0x0001000000000000);
        }
        shift128ExtraRightJamming(
            bSig0, bSig1, 0, expDiff, &bSig0, &bSig1, &zSig2);
        zExp = aExp;
    } else if (expDiff < 0) {
        if (bExp == 0x7FFF) {
            if (bSig0 | bSig1) {
                return propagateFloat128NaN(a, b);
            }
            return packFloat128(zSign, 0x7FFF, 0, 0);
        }
        if (aExp == 0) {
            ++expDiff;
        } else {
            aSig0 |= LIT64(0x0001000000000000);
        }
        shift128ExtraRightJamming(
            aSig0, aSig1, 0, -expDiff, &aSig0, &aSig1, &zSig2);
        zExp = bExp;
    } else {
        if (aExp == 0x7FFF) {
            if (aSig0 | aSig1 | bSig0 | bSig1) {
                return propagateFloat128NaN(a, b);
            }
            return a;
        }
        add128(aSig0, aSig1, bSig0, bSig1, &zSig0, &zSig1);
        if (aExp == 0) {
            return packFloat128(zSign, 0, zSig0, zSig1);
        }
        zSig2 = 0;
        zSig0 |= LIT64(0x0002000000000000);
        zExp = aExp;
        goto shiftRight1;
    }
    aSig0 |= LIT64(0x0001000000000000);
    add128(aSig0, aSig1, bSig0, bSig1, &zSig0, &zSig1);
    --zExp;
    if (zSig0 < LIT64(0x0002000000000000)) {
        goto roundAndPack;
    }
    ++zExp;
shiftRight1:
    shift128ExtraRightJamming(
        zSig0, zSig1, zSig2, 1, &zSig0, &zSig1, &zSig2);
roundAndPack:
    return roundAndPackFloat128(zSign, zExp, zSig0, zSig1, zSig2);
}

/*----------------------------------------------------------------------------
| Returns the result of subtracting the absolute values of the quadruple-
| precision floating-point values `a' and `b'.  If `zSign' is 1, the
| difference is negated before being returned.  `zSign' is ignored if the
| result is a NaN.  The subtraction is performed according to the IEC/IEEE
| Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

static float128 subFloat128Sigs(float128 a, float128 b, flag zSign)
{
    int32 aExp, bExp, zExp;
    bits64 aSig0, aSig1, bSig0, bSig1, zSig0, zSig1;
    int32 expDiff;
    float128 z;

    aSig1 = extractFloat128Frac1(a);
    aSig0 = extractFloat128Frac0(a);
    aExp = extractFloat128Exp(a);
    bSig1 = extractFloat128Frac1(b);
    bSig0 = extractFloat128Frac0(b);
    bExp = extractFloat128Exp(b);
    expDiff = aExp - bExp;
    shortShift128Left(aSig0, aSig1, 14, &aSig0, &aSig1);
    shortShift128Left(bSig0, bSig1, 14, &bSig0, &bSig1);
    if (0 < expDiff) {
        goto aExpBigger;
    }
    if (expDiff < 0) {
        goto bExpBigger;
    }
    if (aExp == 0x7FFF) {
        if (aSig0 | aSig1 | bSig0 | bSig1) {
            return propagateFloat128NaN(a, b);
        }
        float_raise(float_flag_invalid);
        z.low = float128_default_nan_low;
        z.high = float128_default_nan_high;
        return z;
    }
    if (aExp == 0) {
        aExp = 1;
        bExp = 1;
    }
    if (bSig0 < aSig0) {
        goto aBigger;
    }
    if (aSig0 < bSig0) {
        goto bBigger;
    }
    if (bSig1 < aSig1) {
        goto aBigger;
    }
    if (aSig1 < bSig1) {
        goto bBigger;
    }
    return packFloat128(float_rounding_mode == float_round_down, 0, 0, 0);
bExpBigger:
    if (bExp == 0x7FFF) {
        if (bSig0 | bSig1) {
            return propagateFloat128NaN(a, b);
        }
        return packFloat128(zSign ^ 1, 0x7FFF, 0, 0);
    }
    if (aExp == 0) {
        ++expDiff;
    } else {
        aSig0 |= LIT64(0x4000000000000000);
    }
    shift128RightJamming(aSig0, aSig1, -expDiff, &aSig0, &aSig1);
    bSig0 |= LIT64(0x4000000000000000);
bBigger:
    sub128(bSig0, bSig1, aSig0, aSig1, &zSig0, &zSig1);
    zExp = bExp;
    zSign ^= 1;
    goto normalizeRoundAndPack;
aExpBigger:
    if (aExp == 0x7FFF) {
        if (aSig0 | aSig1) {
            return propagateFloat128NaN(a, b);
        }
        return a;
    }
    if (bExp == 0) {
        --expDiff;
    } else {
        bSig0 |= LIT64(0x4000000000000000);
    }
    shift128RightJamming(bSig0, bSig1, expDiff, &bSig0, &bSig1);
    aSig0 |= LIT64(0x4000000000000000);
aBigger:
    sub128(aSig0, aSig1, bSig0, bSig1, &zSig0, &zSig1);
    zExp = aExp;
normalizeRoundAndPack:
    --zExp;
    return normalizeRoundAndPackFloat128(zSign, zExp - 14, zSig0, zSig1);
}

/*----------------------------------------------------------------------------
| Returns the result of adding the quadruple-precision floating-point values
| `a' and `b'.  The operation is performed according to the IEC/IEEE Standard
| for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float128 float128_add(float128 a, float128 b)
{
    flag aSign, bSign;

    aSign = extractFloat128Sign(a);
    bSign = extractFloat128Sign(b);
    if (aSign == bSign) {
        return addFloat128Sigs(a, b, aSign);
    } else {
        return subFloat128Sigs(a, b, aSign);
    }
}

/*----------------------------------------------------------------------------
| Returns the result of subtracting the quadruple-precision floating-point
| values `a' and `b'.  The operation is performed according to the IEC/IEEE
| Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float128 float128_sub(float128 a, float128 b)
{
    flag aSign, bSign;

    aSign = extractFloat128Sign(a);
    bSign = extractFloat128Sign(b);
    if (aSign == bSign) {
        return subFloat128Sigs(a, b, aSign);
    } else {
        return addFloat128Sigs(a, b, aSign);
    }
}

/*----------------------------------------------------------------------------
| Returns the result of multiplying the quadruple-precision floating-point
| values `a' and `b'.  The operation is performed according to the IEC/IEEE
| Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float128 float128_mul(float128 a, float128 b)
{
    flag aSign, bSign, zSign;
    int32 aExp, bExp, zExp;
    bits64 aSig0, aSig1, bSig0, bSig1, zSig0, zSig1, zSig2, zSig3;
    float128 z;

    aSig1 = extractFloat128Frac1(a);
    aSig0 = extractFloat128Frac0(a);
    aExp = extractFloat128Exp(a);
    aSign = extractFloat128Sign(a);
    bSig1 = extractFloat128Frac1(b);
    bSig0 = extractFloat128Frac0(b);
    bExp = extractFloat128Exp(b);
    bSign = extractFloat128Sign(b);
    zSign = aSign ^ bSign;
    if (aExp == 0x7FFF) {
        if ((aSig0 | aSig1) || ((bExp == 0x7FFF) && (bSig0 | bSig1))) {
            return propagateFloat128NaN(a, b);
        }
        if ((bExp | bSig0 | bSig1) == 0) {
            goto invalid;
        }
        return packFloat128(zSign, 0x7FFF, 0, 0);
    }
    if (bExp == 0x7FFF) {
        if (bSig0 | bSig1) {
            return propagateFloat128NaN(a, b);
        }
        if ((aExp | aSig0 | aSig1) == 0) {
        invalid:
            float_raise(float_flag_invalid);
            z.low = float128_default_nan_low;
            z.high = float128_default_nan_high;
            return z;
        }
        return packFloat128(zSign, 0x7FFF, 0, 0);
    }
    if (aExp == 0) {
        if ((aSig0 | aSig1) == 0) {
            return packFloat128(zSign, 0, 0, 0);
        }
        normalizeFloat128Subnormal(aSig0, aSig1, &aExp, &aSig0, &aSig1);
    }
    if (bExp == 0) {
        if ((bSig0 | bSig1) == 0) {
            return packFloat128(zSign, 0, 0, 0);
        }
        normalizeFloat128Subnormal(bSig0, bSig1, &bExp, &bSig0, &bSig1);
    }
    zExp = aExp + bExp - 0x4000;
    aSig0 |= LIT64(0x0001000000000000);
    shortShift128Left(bSig0, bSig1, 16, &bSig0, &bSig1);
    mul128To256(aSig0, aSig1, bSig0, bSig1, &zSig0, &zSig1, &zSig2, &zSig3);
    add128(zSig0, zSig1, aSig0, aSig1, &zSig0, &zSig1);
    zSig2 |= (zSig3 != 0);
    if (LIT64(0x0002000000000000) <= zSig0) {
        shift128ExtraRightJamming(
            zSig0, zSig1, zSig2, 1, &zSig0, &zSig1, &zSig2);
        ++zExp;
    }
    return roundAndPackFloat128(zSign, zExp, zSig0, zSig1, zSig2);
}

/*----------------------------------------------------------------------------
| Returns the result of dividing the quadruple-precision floating-point value
| `a' by the corresponding value `b'.  The operation is performed according to
| the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float128 float128_div(float128 a, float128 b)
{
    flag aSign, bSign, zSign;
    int32 aExp, bExp, zExp;
    bits64 aSig0, aSig1, bSig0, bSig1, zSig0, zSig1, zSig2;
    bits64 rem0, rem1, rem2, rem3, term0, term1, term2, term3;
    float128 z;

    aSig1 = extractFloat128Frac1(a);
    aSig0 = extractFloat128Frac0(a);
    aExp = extractFloat128Exp(a);
    aSign = extractFloat128Sign(a);
    bSig1 = extractFloat128Frac1(b);
    bSig0 = extractFloat128Frac0(b);
    bExp = extractFloat128Exp(b);
    bSign = extractFloat128Sign(b);
    zSign = aSign ^ bSign;
    if (aExp == 0x7FFF) {
        if (aSig0 | aSig1) {
            return propagateFloat128NaN(a, b);
        }
        if (bExp == 0x7FFF) {
            if (bSig0 | bSig1) {
                return propagateFloat128NaN(a, b);
            }
            goto invalid;
        }
        return packFloat128(zSign, 0x7FFF, 0, 0);
    }
    if (bExp == 0x7FFF) {
        if (bSig0 | bSig1) {
            return propagateFloat128NaN(a, b);
        }
        return packFloat128(zSign, 0, 0, 0);
    }
    if (bExp == 0) {
        if ((bSig0 | bSig1) == 0) {
            if ((aExp | aSig0 | aSig1) == 0) {
            invalid:
                float_raise(float_flag_invalid);
                z.low = float128_default_nan_low;
                z.high = float128_default_nan_high;
                return z;
            }
            float_raise(float_flag_divbyzero);
            return packFloat128(zSign, 0x7FFF, 0, 0);
        }
        normalizeFloat128Subnormal(bSig0, bSig1, &bExp, &bSig0, &bSig1);
    }
    if (aExp == 0) {
        if ((aSig0 | aSig1) == 0) {
            return packFloat128(zSign, 0, 0, 0);
        }
        normalizeFloat128Subnormal(aSig0, aSig1, &aExp, &aSig0, &aSig1);
    }
    zExp = aExp - bExp + 0x3FFD;
    shortShift128Left(
        aSig0 | LIT64(0x0001000000000000), aSig1, 15, &aSig0, &aSig1);
    shortShift128Left(
        bSig0 | LIT64(0x0001000000000000), bSig1, 15, &bSig0, &bSig1);
    if (le128(bSig0, bSig1, aSig0, aSig1)) {
        shift128Right(aSig0, aSig1, 1, &aSig0, &aSig1);
        ++zExp;
    }
    zSig0 = estimateDiv128To64(aSig0, aSig1, bSig0);
    mul128By64To192(bSig0, bSig1, zSig0, &term0, &term1, &term2);
    sub192(aSig0, aSig1, 0, term0, term1, term2, &rem0, &rem1, &rem2);
    while ((sbits64)rem0 < 0) {
        --zSig0;
        add192(rem0, rem1, rem2, 0, bSig0, bSig1, &rem0, &rem1, &rem2);
    }
    zSig1 = estimateDiv128To64(rem1, rem2, bSig0);
    if ((zSig1 & 0x3FFF) <= 4) {
        mul128By64To192(bSig0, bSig1, zSig1, &term1, &term2, &term3);
        sub192(rem1, rem2, 0, term1, term2, term3, &rem1, &rem2, &rem3);
        while ((sbits64)rem1 < 0) {
            --zSig1;
            add192(rem1, rem2, rem3, 0, bSig0, bSig1, &rem1, &rem2, &rem3);
        }
        zSig1 |= ((rem1 | rem2 | rem3) != 0);
    }
    shift128ExtraRightJamming(zSig0, zSig1, 0, 15, &zSig0, &zSig1, &zSig2);
    return roundAndPackFloat128(zSign, zExp, zSig0, zSig1, zSig2);
}

/*----------------------------------------------------------------------------
| Returns the remainder of the quadruple-precision floating-point value `a'
| with respect to the corresponding value `b'.  The operation is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float128 float128_rem(float128 a, float128 b)
{
    flag aSign, zSign;
    int32 aExp, bExp, expDiff;
    bits64 aSig0, aSig1, bSig0, bSig1, q, term0, term1, term2;
    bits64 allZero, alternateASig0, alternateASig1, sigMean1;
    sbits64 sigMean0;
    float128 z;

    aSig1 = extractFloat128Frac1(a);
    aSig0 = extractFloat128Frac0(a);
    aExp = extractFloat128Exp(a);
    aSign = extractFloat128Sign(a);
    bSig1 = extractFloat128Frac1(b);
    bSig0 = extractFloat128Frac0(b);
    bExp = extractFloat128Exp(b);
    //    bSign = extractFloat128Sign( b );
    if (aExp == 0x7FFF) {
        if ((aSig0 | aSig1) || ((bExp == 0x7FFF) && (bSig0 | bSig1))) {
            return propagateFloat128NaN(a, b);
        }
        goto invalid;
    }
    if (bExp == 0x7FFF) {
        if (bSig0 | bSig1) {
            return propagateFloat128NaN(a, b);
        }
        return a;
    }
    if (bExp == 0) {
        if ((bSig0 | bSig1) == 0) {
        invalid:
            float_raise(float_flag_invalid);
            z.low = float128_default_nan_low;
            z.high = float128_default_nan_high;
            return z;
        }
        normalizeFloat128Subnormal(bSig0, bSig1, &bExp, &bSig0, &bSig1);
    }
    if (aExp == 0) {
        if ((aSig0 | aSig1) == 0) {
            return a;
        }
        normalizeFloat128Subnormal(aSig0, aSig1, &aExp, &aSig0, &aSig1);
    }
    expDiff = aExp - bExp;
    if (expDiff < -1) {
        return a;
    }
    shortShift128Left(
        aSig0 | LIT64(0x0001000000000000),
        aSig1,
        15 - (expDiff < 0),
        &aSig0,
        &aSig1);
    shortShift128Left(
        bSig0 | LIT64(0x0001000000000000), bSig1, 15, &bSig0, &bSig1);
    q = le128(bSig0, bSig1, aSig0, aSig1);
    if (q) {
        sub128(aSig0, aSig1, bSig0, bSig1, &aSig0, &aSig1);
    }
    expDiff -= 64;
    while (0 < expDiff) {
        q = estimateDiv128To64(aSig0, aSig1, bSig0);
        q = (4 < q) ? q - 4 : 0;
        mul128By64To192(bSig0, bSig1, q, &term0, &term1, &term2);
        shortShift192Left(term0, term1, term2, 61, &term1, &term2, &allZero);
        shortShift128Left(aSig0, aSig1, 61, &aSig0, &allZero);
        sub128(aSig0, 0, term1, term2, &aSig0, &aSig1);
        expDiff -= 61;
    }
    if (-64 < expDiff) {
        q = estimateDiv128To64(aSig0, aSig1, bSig0);
        q = (4 < q) ? q - 4 : 0;
        q >>= -expDiff;
        shift128Right(bSig0, bSig1, 12, &bSig0, &bSig1);
        expDiff += 52;
        if (expDiff < 0) {
            shift128Right(aSig0, aSig1, -expDiff, &aSig0, &aSig1);
        } else {
            shortShift128Left(aSig0, aSig1, expDiff, &aSig0, &aSig1);
        }
        mul128By64To192(bSig0, bSig1, q, &term0, &term1, &term2);
        sub128(aSig0, aSig1, term1, term2, &aSig0, &aSig1);
    } else {
        shift128Right(aSig0, aSig1, 12, &aSig0, &aSig1);
        shift128Right(bSig0, bSig1, 12, &bSig0, &bSig1);
    }
    do {
        alternateASig0 = aSig0;
        alternateASig1 = aSig1;
        ++q;
        sub128(aSig0, aSig1, bSig0, bSig1, &aSig0, &aSig1);
    } while (0 <= (sbits64)aSig0);
    add128(
        aSig0, aSig1, alternateASig0, alternateASig1, (bits64*)&sigMean0, &sigMean1);
    if ((sigMean0 < 0) || (((sigMean0 | sigMean1) == 0) && (q & 1))) {
        aSig0 = alternateASig0;
        aSig1 = alternateASig1;
    }
    zSign = ((sbits64)aSig0 < 0);
    if (zSign) {
        sub128(0, 0, aSig0, aSig1, &aSig0, &aSig1);
    }
    return normalizeRoundAndPackFloat128(aSign ^ zSign, bExp - 4, aSig0, aSig1);
}

/*----------------------------------------------------------------------------
| Returns the square root of the quadruple-precision floating-point value `a'.
| The operation is performed according to the IEC/IEEE Standard for Binary
| Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

float128 float128_sqrt(float128 a)
{
    flag aSign;
    int32 aExp, zExp;
    bits64 aSig0, aSig1, zSig0, zSig1, zSig2, doubleZSig0;
    bits64 rem0, rem1, rem2, rem3, term0, term1, term2, term3;
    float128 z;

    aSig1 = extractFloat128Frac1(a);
    aSig0 = extractFloat128Frac0(a);
    aExp = extractFloat128Exp(a);
    aSign = extractFloat128Sign(a);
    if (aExp == 0x7FFF) {
        if (aSig0 | aSig1) {
            return propagateFloat128NaN(a, a);
        }
        if (!aSign) {
            return a;
        }
        goto invalid;
    }
    if (aSign) {
        if ((aExp | aSig0 | aSig1) == 0) {
            return a;
        }
    invalid:
        float_raise(float_flag_invalid);
        z.low = float128_default_nan_low;
        z.high = float128_default_nan_high;
        return z;
    }
    if (aExp == 0) {
        if ((aSig0 | aSig1) == 0) {
            return packFloat128(0, 0, 0, 0);
        }
        normalizeFloat128Subnormal(aSig0, aSig1, &aExp, &aSig0, &aSig1);
    }
    zExp = ((aExp - 0x3FFF) >> 1) + 0x3FFE;
    aSig0 |= LIT64(0x0001000000000000);
    zSig0 = estimateSqrt32(aExp, aSig0 >> 17);
    shortShift128Left(aSig0, aSig1, 13 - (aExp & 1), &aSig0, &aSig1);
    zSig0 = estimateDiv128To64(aSig0, aSig1, zSig0 << 32) + (zSig0 << 30);
    doubleZSig0 = zSig0 << 1;
    mul64To128(zSig0, zSig0, &term0, &term1);
    sub128(aSig0, aSig1, term0, term1, &rem0, &rem1);
    while ((sbits64)rem0 < 0) {
        --zSig0;
        doubleZSig0 -= 2;
        add128(rem0, rem1, zSig0 >> 63, doubleZSig0 | 1, &rem0, &rem1);
    }
    zSig1 = estimateDiv128To64(rem1, 0, doubleZSig0);
    if ((zSig1 & 0x1FFF) <= 5) {
        if (zSig1 == 0) {
            zSig1 = 1;
        }
        mul64To128(doubleZSig0, zSig1, &term1, &term2);
        sub128(rem1, 0, term1, term2, &rem1, &rem2);
        mul64To128(zSig1, zSig1, &term2, &term3);
        sub192(rem1, rem2, 0, 0, term2, term3, &rem1, &rem2, &rem3);
        while ((sbits64)rem1 < 0) {
            --zSig1;
            shortShift128Left(0, zSig1, 1, &term2, &term3);
            term3 |= 1;
            term2 |= doubleZSig0;
            add192(rem1, rem2, rem3, 0, term2, term3, &rem1, &rem2, &rem3);
        }
        zSig1 |= ((rem1 | rem2 | rem3) != 0);
    }
    shift128ExtraRightJamming(zSig0, zSig1, 0, 14, &zSig0, &zSig1, &zSig2);
    return roundAndPackFloat128(0, zExp, zSig0, zSig1, zSig2);
}

/*----------------------------------------------------------------------------
| Returns 1 if the quadruple-precision floating-point value `a' is equal to
| the corresponding value `b', and 0 otherwise.  The comparison is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float128_eq(float128 a, float128 b)
{
    if (((extractFloat128Exp(a) == 0x7FFF) && (extractFloat128Frac0(a) | extractFloat128Frac1(a))) || ((extractFloat128Exp(b) == 0x7FFF) && (extractFloat128Frac0(b) | extractFloat128Frac1(b)))) {
        if (float128_is_signaling_nan(a) || float128_is_signaling_nan(b)) {
            float_raise(float_flag_invalid);
        }
        return 0;
    }
    return (a.low == b.low) && ((a.high == b.high) || ((a.low == 0) && ((bits64)((a.high | b.high) << 1) == 0)));
}

/*----------------------------------------------------------------------------
| Returns 1 if the quadruple-precision floating-point value `a' is less than
| or equal to the corresponding value `b', and 0 otherwise.  The comparison
| is performed according to the IEC/IEEE Standard for Binary Floating-Point
| Arithmetic.
*----------------------------------------------------------------------------*/

flag float128_le(float128 a, float128 b)
{
    flag aSign, bSign;

    if (((extractFloat128Exp(a) == 0x7FFF) && (extractFloat128Frac0(a) | extractFloat128Frac1(a))) || ((extractFloat128Exp(b) == 0x7FFF) && (extractFloat128Frac0(b) | extractFloat128Frac1(b)))) {
        float_raise(float_flag_invalid);
        return 0;
    }
    aSign = extractFloat128Sign(a);
    bSign = extractFloat128Sign(b);
    if (aSign != bSign) {
        return aSign || ((((bits64)((a.high | b.high) << 1)) | a.low | b.low) == 0);
    }
    return aSign ? le128(b.high, b.low, a.high, a.low)
                 : le128(a.high, a.low, b.high, b.low);
}

/*----------------------------------------------------------------------------
| Returns 1 if the quadruple-precision floating-point value `a' is less than
| the corresponding value `b', and 0 otherwise.  The comparison is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float128_lt(float128 a, float128 b)
{
    flag aSign, bSign;

    if (((extractFloat128Exp(a) == 0x7FFF) && (extractFloat128Frac0(a) | extractFloat128Frac1(a))) || ((extractFloat128Exp(b) == 0x7FFF) && (extractFloat128Frac0(b) | extractFloat128Frac1(b)))) {
        float_raise(float_flag_invalid);
        return 0;
    }
    aSign = extractFloat128Sign(a);
    bSign = extractFloat128Sign(b);
    if (aSign != bSign) {
        return aSign && ((((bits64)((a.high | b.high) << 1)) | a.low | b.low) != 0);
    }
    return aSign ? lt128(b.high, b.low, a.high, a.low)
                 : lt128(a.high, a.low, b.high, b.low);
}

/*----------------------------------------------------------------------------
| Returns 1 if the quadruple-precision floating-point value `a' is equal to
| the corresponding value `b', and 0 otherwise.  The invalid exception is
| raised if either operand is a NaN.  Otherwise, the comparison is performed
| according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float128_eq_signaling(float128 a, float128 b)
{
    if (((extractFloat128Exp(a) == 0x7FFF) && (extractFloat128Frac0(a) | extractFloat128Frac1(a))) || ((extractFloat128Exp(b) == 0x7FFF) && (extractFloat128Frac0(b) | extractFloat128Frac1(b)))) {
        float_raise(float_flag_invalid);
        return 0;
    }
    return (a.low == b.low) && ((a.high == b.high) || ((a.low == 0) && ((bits64)((a.high | b.high) << 1) == 0)));
}

/*----------------------------------------------------------------------------
| Returns 1 if the quadruple-precision floating-point value `a' is less than
| or equal to the corresponding value `b', and 0 otherwise.  Quiet NaNs do not
| cause an exception.  Otherwise, the comparison is performed according to the
| IEC/IEEE Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float128_le_quiet(float128 a, float128 b)
{
    flag aSign, bSign;

    if (((extractFloat128Exp(a) == 0x7FFF) && (extractFloat128Frac0(a) | extractFloat128Frac1(a))) || ((extractFloat128Exp(b) == 0x7FFF) && (extractFloat128Frac0(b) | extractFloat128Frac1(b)))) {
        if (float128_is_signaling_nan(a) || float128_is_signaling_nan(b)) {
            float_raise(float_flag_invalid);
        }
        return 0;
    }
    aSign = extractFloat128Sign(a);
    bSign = extractFloat128Sign(b);
    if (aSign != bSign) {
        return aSign || ((((bits64)((a.high | b.high) << 1)) | a.low | b.low) == 0);
    }
    return aSign ? le128(b.high, b.low, a.high, a.low)
                 : le128(a.high, a.low, b.high, b.low);
}

/*----------------------------------------------------------------------------
| Returns 1 if the quadruple-precision floating-point value `a' is less than
| the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an
| exception.  Otherwise, the comparison is performed according to the IEC/IEEE
| Standard for Binary Floating-Point Arithmetic.
*----------------------------------------------------------------------------*/

flag float128_lt_quiet(float128 a, float128 b)
{
    flag aSign, bSign;

    if (((extractFloat128Exp(a) == 0x7FFF) && (extractFloat128Frac0(a) | extractFloat128Frac1(a))) || ((extractFloat128Exp(b) == 0x7FFF) && (extractFloat128Frac0(b) | extractFloat128Frac1(b)))) {
        if (float128_is_signaling_nan(a) || float128_is_signaling_nan(b)) {
            float_raise(float_flag_invalid);
        }
        return 0;
    }
    aSign = extractFloat128Sign(a);
    bSign = extractFloat128Sign(b);
    if (aSign != bSign) {
        return aSign && ((((bits64)((a.high | b.high) << 1)) | a.low | b.low) != 0);
    }
    return aSign ? lt128(b.high, b.low, a.high, a.low)
                 : lt128(a.high, a.low, b.high, b.low);
}

#endif
/* -- End embedded musashi/softfloat.c -- */

#endif /* MUSASHI_IMPLEMENTATION */
